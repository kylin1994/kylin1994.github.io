<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kylin Xiang&#39;s Blog</title>
  
  <subtitle>technical blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kylin1994.github.io/"/>
  <updated>2019-06-09T14:04:44.901Z</updated>
  <id>https://kylin1994.github.io/</id>
  
  <author>
    <name>Kylin Xiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DDD笔记3-分离领域</title>
    <link href="https://kylin1994.github.io/2019/06/05/DDD%E7%AC%94%E8%AE%B03-%E5%88%86%E7%A6%BB%E9%A2%86%E5%9F%9F/"/>
    <id>https://kylin1994.github.io/2019/06/05/DDD笔记3-分离领域/</id>
    <published>2019-06-05T05:51:54.517Z</published>
    <updated>2019-06-09T14:04:44.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDD笔记3-分离领域"><a href="#DDD笔记3-分离领域" class="headerlink" title="DDD笔记3-分离领域"></a>DDD笔记3-分离领域</h1><blockquote><p>本文整理自《领域驱动设计：软件核心复杂性应对之道》第三章 </p></blockquote><p>下图为一章导航图，用来描述模式以及模式之间的关系。这些模式将会在后文以及DDD系列笔记中出现。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/20190605100024.png" height="300"></p><h2 id="模式：LAYERED-ARCHITECTURE"><a href="#模式：LAYERED-ARCHITECTURE" class="headerlink" title="模式：LAYERED ARCHITECTURE"></a>模式：LAYERED ARCHITECTURE</h2><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/20190605104000.png" height="250"></p><p>跟具软件行业的经验和惯例，普遍采用LAYERD ARCHITECTURE。大多数成功的架构使用的分层架构都包含一下四个概念层：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/20190605104648.png" alt=""></p><p>将领域层分离出来才是实现<strong>MODEL-DRIVEN DESIGN</strong>的关键。</p><p>因此：</p><p><strong>给复杂的应用程序划分层次。在每一层内分别进行设计，使其具有内聚性并且只依赖于它的下层。采用标准的架构模式，只与上层进行松散连接。将所有与领域模型相关的代码放在一个层中，并把它与用户界面层、应用层以及基础设施层的代码分开。领域对象应该将重点放在如何表达模型上，而不需考虑自己的显示和存储问题，也无需搭理应用任务等内容。这使得模型的含义足够丰富，结构足够清晰，可以捕捉到基本的业务知识，并有效地使用这些知识。</strong></p><p><strong>负责处理基本业务规则的是领域层，而不是应用层</strong></p><p>下面看一个银行转账的例子，a123转账给a234：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/20190605142834.png" alt=""></p><h3 id="将各层连接起来"><a href="#将各层连接起来" class="headerlink" title="将各层连接起来"></a>将各层连接起来</h3><p>各层之间是松散连接的，层与层的之间的关系是单向的。上层可以直接使用或操作下层元素。下层元素和下层元素通信(不只是简单的查询返回)，可以使用<strong>回调</strong>或者<strong>OBSERVER模式</strong>。</p><p>用户界面层、应用层和领域层的连接方式：<strong>MODEL-VIEW-CONTROLLE</strong>以及其变体。</p><p>通常基础设施层不会发起领域层中的操作，它处于领域层”之下”，不包含其所服务的领域中的知识。基础设计层通常以SERVICE的形式提供各种技术能力，比如emai发送服务等。应用层和领域层可以通过公开接口访问这些SERVICE。</p><h3 id="架构框架"><a href="#架构框架" class="headerlink" title="架构框架"></a>架构框架</h3><p>好的架构框架技能解决复杂的的技术问题，也能让开发人员集中精力去表达模型，而不去考虑其他问题。项目团队在使用框架时，要明确其使用目的：建立一种可以表达领域模型的实现并且用它来解决重要问题。</p><h2 id="模型属于领域层"><a href="#模型属于领域层" class="headerlink" title="模型属于领域层"></a>模型属于领域层</h2><p>大部分软件都采用了<strong>LAYERED ARCHITECTURE</strong>，只是采用的分层方案存在不同而已。许多类型的开发工作都能从分层中获益，领域驱动设计只需要一个特定的层即可。</p><p>领域模型是一些列概念的集合。”领域层”则是领域模型以及所有与其直接相关的设计元素的表现，他由业务逻辑的设计和实现组成。在<strong>MODEL-DRIVEN DESIGN</strong>，领域层的软件构造放映了模型概念。</p><p>如果领域逻辑与程序中的其他关注点混在一起，就不能实现这种一致性。<strong>将领域实现独立出来是领域驱动设计的前提。</strong></p><h3 id="反模式：THE-SMART-UI"><a href="#反模式：THE-SMART-UI" class="headerlink" title="反模式：THE SMART UI"></a>反模式：THE SMART UI</h3><p>很多软件都采用了一种不那么复杂的是设计方法，作者称其为<strong>SMART UI（智能用户界面）</strong>。但是<strong>SMART UI与领域驱动设计迥然不同却互不兼容</strong>。所以这里称其为反模式，主要用来和领域驱动设计作对比。</p><p>MODEL-DRIVEN DESIGN并不适合小项目，因为学习过程十分艰难，周期很长，技术复杂。没有充裕的时间和专家的帮助，团队成员很难掌握这一项技术。</p><p>使用领域驱动设计，必然就选择了UI和领域的分离，应用程序和领域的分离。</p><p><strong><em>如果一个架构能把那些与领域相关的代码隔离出来，得到一个内聚的领域设计，同时又使领域与系统设计其他部分保持松散连接，那么这种架构也许可以支持领域驱动设计。</em></strong></p><h3 id="其他分离方式"><a href="#其他分离方式" class="headerlink" title="其他分离方式"></a>其他分离方式</h3><p><strong>BOUNDED CONTEXT</strong>和<strong>ANTICORRUPTION LAYER</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DDD笔记3-分离领域&quot;&gt;&lt;a href=&quot;#DDD笔记3-分离领域&quot; class=&quot;headerlink&quot; title=&quot;DDD笔记3-分离领域&quot;&gt;&lt;/a&gt;DDD笔记3-分离领域&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文整理自《领域驱动设计：软件核心复杂性应
      
    
    </summary>
    
      <category term="DDD" scheme="https://kylin1994.github.io/categories/DDD/"/>
    
    
      <category term="DDD" scheme="https://kylin1994.github.io/tags/DDD/"/>
    
      <category term="Design" scheme="https://kylin1994.github.io/tags/Design/"/>
    
      <category term="Modeling" scheme="https://kylin1994.github.io/tags/Modeling/"/>
    
      <category term="domain" scheme="https://kylin1994.github.io/tags/domain/"/>
    
  </entry>
  
  <entry>
    <title>DDD笔记2-绑定模型和实现</title>
    <link href="https://kylin1994.github.io/2019/06/04/DDD%E7%AC%94%E8%AE%B02-%E7%BB%91%E5%AE%9A%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <id>https://kylin1994.github.io/2019/06/04/DDD笔记2-绑定模型和实现/</id>
    <published>2019-06-04T14:00:40.301Z</published>
    <updated>2019-06-05T05:52:57.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDD笔记2-绑定模型和实现"><a href="#DDD笔记2-绑定模型和实现" class="headerlink" title="DDD笔记2-绑定模型和实现"></a>DDD笔记2-绑定模型和实现</h1><blockquote><p>本文整理自《领域驱动设计：软件核心复杂性应对之道》第三章</p></blockquote><p>问题：开发人员很难将分析人员分析出的错综复杂的关系转换成可存储、可检索的并且具有事务完整性的单元。</p><p>领域驱动设计要求模型不仅能知道早期的分析工作，更应该成为设计的基础。这种设计方法对代码的编写有重要的暗示作用。</p><p>领域驱动设计需要一种不同的建模方法。</p><h2 id="模式：MODEL-DRIVEN-DESIGN"><a href="#模式：MODEL-DRIVEN-DESIGN" class="headerlink" title="模式：MODEL-DRIVEN DESIGN"></a>模式：MODEL-DRIVEN DESIGN</h2><p><strong>模型和程序设计应该保持紧密的联系。</strong></p><p>分析模型：提倡设计方法和程序设计分离，因为在分析模型时，并没有考虑到程序设计的问题，因此分析模型很有可能无法满足程序设计的需求。</p><p><strong>如果整个程序设计或者其核心部分没有与领域模型相对应，那么这个模型是没有价值的，软件的正确性也值得怀疑。同时，模型和设计功能之间太过复杂的对应关系也是难于理解，在实际项目中改变设计时也无法维护这种关系。分析和设计工作全无关联，导致这两个过程中所获得的知识无法彼此共享。</strong></p><p>分析工作：要抓住领域内的基础概念，简洁地表达出来(可以参考”大声的”建模)。</p><p>设计工作：需要制定一套可以由项目中使用的编程工具创建的组件，是项目可以在目标环境中高效运行，并且能正确解决应用程序遇到的问题。</p><p><strong>Model-Driven Desgin（模型驱动设计）不再将分析模型和程序分离开，而是寻求一种满足这两方面需求的单一模型。</strong></p><p><strong>绑定模型和程序设计</strong>是可行的：有很多方法可以对领域进行抽象，也有很多设计可以解决应用程序的问题。</p><p>模型和设计的绑定需要的是<strong>在分析和程序设计阶段都能发挥良好作用的模型</strong>。</p><p>建模和程序设计是一个统一的迭代开发的过程。</p><p>将领域模型和程序设计紧密联系在一起绝对是必要的。</p><p>因此：</p><p><strong>软件系统的各个部分的设计应该忠实地反应领域模型，以便体现出这二者之间的明确对应的关系。我们应该反复检查并修改模型，在软件中更加自然地实现模型，即使想让它反应出更深层次的领域概念也应如此。我们需要的模型不但应该满足这两种需求，还应该能够支持健壮的UBIQUITOUS LANGUAGE。</strong></p><p><strong>从模型中获取用于程序设计和基本任务分配的术语。程序代码就是模型的表达，修改代码可能就是改变模型。而模型的改变势必会影响到接下来相应的项目活动。</strong></p><p><strong>完全依赖模型的实现通常需要支持建模范式的软件开工具和语言，比如OOP。</strong></p><h2 id="建模范式和工具支持"><a href="#建模范式和工具支持" class="headerlink" title="建模范式和工具支持"></a>建模范式和工具支持</h2><p>为了使<strong>MODEL-DRIVEN DESIGN</strong>发挥作用，一定要在可控范围内严格保证模型与设计之间的一致性。要实现这种严格的一致性，必须要运用软件工具支持的建模范式，它可以直接模拟模型中的概念。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/20190604200453.png" alt=""></p><p><strong>MODEL-DRIVEN DESIGN</strong>并不适用于面向过程的语言。</p><p><strong>MODEL-DRIVEN DESIGN</strong>并适用于面向对象的语言，因为它基于建模范式，并且为模型构造提供了实现方式。</p><p>在<strong>MODEL-DRIVEN DESIGN</strong>中，建模范式是一种逻辑，而模型则是一组逻辑规则以及这些规则所依据的事实。</p><p>面向对象设计是目前大多数大型项目所使用的建模范式，也是DDD中使用的主要方法。</p><p><strong>MODEL-DRIVEN DESIGN</strong>也为测试提供了方便。它的组件都具有定义完善的接口，可以进行单元测试。</p><h2 id="揭示主旨：为什么模型对客户至关重要"><a href="#揭示主旨：为什么模型对客户至关重要" class="headerlink" title="揭示主旨：为什么模型对客户至关重要"></a>揭示主旨：为什么模型对客户至关重要</h2><p>大多数情况下，没有经过处理的领域模型肯定不便于用户使用。用户界面中出现与领域模型不同的”映像”将会使用户产生迷惑。</p><h2 id="模式：HANDS-ON-MODELER"><a href="#模式：HANDS-ON-MODELER" class="headerlink" title="模式：HANDS-ON MODELER"></a>模式：HANDS-ON MODELER</h2><p>开发团队中的每个成员都有自己的职责，但是将分析、建模、设计和编程工作完全分离会对<strong>MODEL-DRIVEN DESIGN</strong>产生不良影响。</p><p>有些时候，领域专家和开发负责人通过消化知识得到的模型，但是这些模型可能并没有派上用场。原因有两个：</p><ol><li>在模型递交给开发员的过程中，模型的一些意图并没有向他们说明。(也就是说，开发人员不能完全理解模型)</li><li>模型与程序实现及技术相互影响，上述情况下，模型无法感知程序实现的反馈。</li></ol><p>开发人员应该意识到修改代码就是修改模型，那么对程序的重构就会增强模型的作用。</p><p><strong>MODEL-DRIVEN DESIGN</strong>的两个基本要素：模型要支持有效的实现并抽象出关键的领域知识。如果如果设计和实现分离，那么使用<strong>MODEL-DRIVEN DESIGN</strong>就不能建立有效的模型。</p><p><strong>HANDS-ON MODELER（建模人员参与程序开发）</strong>并不意味这团队成员不能有自己的专业角色。但是将设计和实现分离开就会产生问题。</p><p>因此：</p><p><strong>任何参与建模的技术人员，不管在项目中的主要职责是什么，都必须花时间了解代码。任何负责修改代码的人员则必须学会用代码来表达模型。每一个开发人员都必须不同程度地参与模型讨论并与领域专家保持联系。参与不同工作的人都必须有意识地通过UBIQUITOUS LANGUAGE与接触代码的人及时交换关于模型的想法。</strong></p><p><em>后续文章将会陆续带来DODEL-DRIVEN DESIGN的模式，下图为各种模式和其之间的关系</em>：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/20190605100024.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DDD笔记2-绑定模型和实现&quot;&gt;&lt;a href=&quot;#DDD笔记2-绑定模型和实现&quot; class=&quot;headerlink&quot; title=&quot;DDD笔记2-绑定模型和实现&quot;&gt;&lt;/a&gt;DDD笔记2-绑定模型和实现&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文整理自《领域驱
      
    
    </summary>
    
      <category term="DDD" scheme="https://kylin1994.github.io/categories/DDD/"/>
    
    
      <category term="DDD" scheme="https://kylin1994.github.io/tags/DDD/"/>
    
      <category term="Design" scheme="https://kylin1994.github.io/tags/Design/"/>
    
      <category term="Modeling" scheme="https://kylin1994.github.io/tags/Modeling/"/>
    
      <category term="domain" scheme="https://kylin1994.github.io/tags/domain/"/>
    
  </entry>
  
  <entry>
    <title>DDD笔记1-语言的交流使用</title>
    <link href="https://kylin1994.github.io/2019/06/03/DDD%E7%AC%94%E8%AE%B01-%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BA%A4%E6%B5%81%E4%BD%BF%E7%94%A8/"/>
    <id>https://kylin1994.github.io/2019/06/03/DDD笔记1-语言的交流使用/</id>
    <published>2019-06-03T01:16:12.956Z</published>
    <updated>2019-06-05T05:53:35.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDD笔记1-语言的交流使用"><a href="#DDD笔记1-语言的交流使用" class="headerlink" title="DDD笔记1-语言的交流使用"></a>DDD笔记1-语言的交流使用</h1><blockquote><p>本文整理自《领域驱动设计：软件核心复杂性应对之道》第二章</p></blockquote><p><strong>领域模型是软件模型的公共语言的核心</strong>。模型是与项目有关的概念集合，它用<strong>术语</strong>和<strong>关系</strong>反映了领域的深层次含义。<strong>术语</strong>和<strong>关系</strong>提供了模型语言的语义，是一条至关重要的纽带，将<strong>模型与开发活动结合</strong>在一起，并使模型与代码紧密绑定。</p><p>建模需要充分的交流，基于模型提高文本文档的实用性，也提高了敏捷过程中反复强调的非正式和临时交谈的实用性。他提高了代码本身和代码测试的沟通能力。</p><h2 id="模式：通用语言（UBIQUIOUS-LANGUAGE）"><a href="#模式：通用语言（UBIQUIOUS-LANGUAGE）" class="headerlink" title="模式：通用语言（UBIQUIOUS LANGUAGE）"></a>模式：通用语言（UBIQUIOUS LANGUAGE）</h2><p>领域专家和开发人员需要高效地、准确地交流沟通才能使消化的知识变成相应的模型。但领域专家有自己的行话，开发人员用自己的语言从设计角度讨论领域，为了消除这种语言鸿沟，所以领域专家和开发人员需要一种公共语言。<strong>领域模型可以是这种公共语言的核心，同时将团队沟通和软件实现紧密联系到一起。这种公共语言就是整个团队中的UBIQUITOUS LANGUAGE（通用语言）。</strong></p><p><strong>原则</strong>：</p><ul><li>将模型作为语言的中心。确保团队在所有交流活动和代码中坚持使用这种语言。在画图、写东西、特别是讲话时也要使用这种语言。</li><li>通过尝试不同的表示方法（它们反应不同的模型）来消除难点。然后重构代码，并对类、方法和模块重命名，以便与新模型相一致。解决交谈中的术语混淆问题，就像我们队普通词汇形成一个公认的理解一样。</li><li>UBIQUITOUS LANGUAGE的更改就是对模型的更改。</li><li>领域专家应该避免使用拗口或无法表达领域理解的数据或结构，开发人员应该密切监视那些将会妨碍设计的有歧义和不一致的地方。</li></ul><h2 id="模式：”大声地”建模"><a href="#模式：”大声地”建模" class="headerlink" title="模式：”大声地”建模"></a>模式：”大声地”建模</h2><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/20190603162751.png" alt=""></p><p>大声地建模强调使用单词和短语，以简单的形式来表述建模过程中的各种元素。</p><p>所以”大声地”建模可以看做是对UBIQUITOUS LANGUAGE模式的一种补充：</p><p>讨论系统时需要结合模型。使用模型的元素以及模型中各元素之间的交互来大声描述场景，并且按照模型允许的方式将各种概念结合到一起。找到更简单的表达方式来讲出你要将的话，然后将这些新的思想应用到图和代码中。</p><h2 id="一个团队，一种语言"><a href="#一个团队，一种语言" class="headerlink" title="一个团队，一种语言"></a>一个团队，一种语言</h2><p>用一个团队中，在语言上不应该有分歧。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/20190603165343.png" alt=""></p><p>有了UBIQUITOUS LANGUAGE之后，开发人员之间的对话、领域专家之间的讨论以及代码本身的表达都基于同一种语言，都来自于一个共享的领域模型。</p><h2 id="文档和图"><a href="#文档和图" class="headerlink" title="文档和图"></a>文档和图</h2><p>简洁的小图可以更有效的沟通和解释，而整个对象模型的综合性大图反而失去了沟通和解释的能力，因为会将读者淹没在大量的细节中。因此，我们应该使用只包含对象模型重要概念的简洁的图，这部分对理解设计非常重要。它们体现了设计的纲要。</p><p><strong>设计的重要细节应该在代码中体现出来。</strong></p><p><strong>模型不是图。</strong>图的目的是帮助表达和解释模型，代码可以表述设计细节。</p><h3 id="书面文档设计"><a href="#书面文档设计" class="headerlink" title="书面文档设计"></a>书面文档设计</h3><ul><li>文档必不可少</li><li>文档应作为代码和口头交流的补充</li><li><strong>文档不应在重复表示代码已经明确表达的内容</strong>。代码已经含有各个细节，它本身就是精确的程序行为说明。</li><li>文档应努力寻求生存之道并保持更新。</li><li><p>文档必须深入到各个项目活动中去。</p></li><li><p>根据UBIQUITOUS LANGUAGE及其演变来选择那些需要保持更新并与项目活动紧密交互的文档。</p></li></ul><h2 id="解释模型"><a href="#解释模型" class="headerlink" title="解释模型"></a>解释模型</h2><ul><li>解释模型可以包含提供上下文的那些领域方面，用户澄清范围上收到严格限制的技术模型。</li><li>解释模型提供了一定自由度，可以专门为某个特殊主题定制一些表达更强的风格。</li><li>解释模型还可以以一种不同的方式来呈现领域，各种不同角度的解释有助于人们更好的学习。</li><li>解释模型不必是对象模型，而且最好不是。</li></ul><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/20190603213107.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DDD笔记1-语言的交流使用&quot;&gt;&lt;a href=&quot;#DDD笔记1-语言的交流使用&quot; class=&quot;headerlink&quot; title=&quot;DDD笔记1-语言的交流使用&quot;&gt;&lt;/a&gt;DDD笔记1-语言的交流使用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文整理自《领域驱
      
    
    </summary>
    
      <category term="DDD" scheme="https://kylin1994.github.io/categories/DDD/"/>
    
    
      <category term="DDD" scheme="https://kylin1994.github.io/tags/DDD/"/>
    
      <category term="Design" scheme="https://kylin1994.github.io/tags/Design/"/>
    
      <category term="Modeling" scheme="https://kylin1994.github.io/tags/Modeling/"/>
    
      <category term="domain" scheme="https://kylin1994.github.io/tags/domain/"/>
    
  </entry>
  
  <entry>
    <title>serverless</title>
    <link href="https://kylin1994.github.io/2019/06/02/Serverless%E6%9E%B6%E6%9E%84/"/>
    <id>https://kylin1994.github.io/2019/06/02/Serverless架构/</id>
    <published>2019-06-02T00:03:04.568Z</published>
    <updated>2019-06-03T13:57:05.063Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理自Mike Roberts的文章，原文链接：<a href="https://martinfowler.com/articles/serverless.html" target="_blank" rel="noopener">https://martinfowler.com/articles/serverless.html</a><br>本文首先用较长的篇幅举例说明了什么是Serverless，从不同角度阐述了Serverless的利弊；并且与现有的系统架构做了对比，引入其他业界权威人士关于Serverlss的讨论，到目前为止这是我看到的对Serverless表述最全面的文章。</p></blockquote><blockquote><p><em>Serverless架构是将第三方“Backend as a Service”（BaaS）服务和/或包括在“Function as a Service”（FaaS）平台上托管的、短暂的容器中运行的自定义代码的应用程序设计。通过使用这些以及相关的思想（如单页应用程序），这种体系结构消除了对传统的始终在线服务器组件的大量需求。Serverless架构可能受益于显著降低的运营成本、复杂性和工程交付周期，同时增加了对供应商依赖性和相对不成熟的支持服务的依赖。</em></p></blockquote><h2 id="什么是Serverless架构"><a href="#什么是Serverless架构" class="headerlink" title="什么是Serverless架构"></a>什么是Serverless架构</h2><p>可以将Serverless理解为两个不同却又有重叠的两个部分：</p><ol><li>首先，Serverless用于描述大量或完全结合第三方、云托管应用程序和服务的应用程序，以管理服务器端逻辑和状态。这些通常是“富客户端”应用程序，例如单页Web应用程序，或使用云可访问数据库（如Parse、FireBase）、身份验证服务（如Auth0、AWS Cognito）等庞大生态系统的移动应用程序。这些类型的服务以前被描述为“<a href="https://en.wikipedia.org/wiki/Mobile_backend_as_a_service" target="_blank" rel="noopener">(Mobile) Backend as a Service</a>”。</li><li>Serverless也可以表示服务器端逻辑仍由应用程序开发人员编写的应用程序，但与传统体系结构不同，它运行在无状态计算容器中，这些容器是事件触发的、短暂的（可能只持续一次调用），并且完全由第三方管理。考虑到这一点的一种方法是“Function as a Service”或“FaaS”。</li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="UI驱动的应用（UI-driven-applications）"><a href="#UI驱动的应用（UI-driven-applications）" class="headerlink" title="UI驱动的应用（UI-driven applications）"></a>UI驱动的应用（UI-driven applications）</h3><p>让我们考虑一个具有服务器端逻辑的传统的面向客户端的三层架构系统。一个很好的例子是一个典型的电子商务应用程序，比如说一个在线宠物商店：<br>传统上，架构如下图所示。假设它是用服务器端是用Java或JavaScript实现的，HTML+JavaScript组件作为客户端：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/006tNc79gy1g3m3r8rii4j30h804ojrl.jpg" alt="Traditional three-tier architecture"></p><p>这样架构相对来说不是特别智能，因为在服务器应用中实现了太多的系统逻辑，比如认证授权，页面导航，搜索，事务。</p><p>对于Serverless架构，最终可能会看起来更像这样：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/006tNc79gy1g3m3r8at5jj30h70a4q3s.jpg" alt="Serverless architecture"></p><p>这是一个大大简化的视图，但即使在这里，我们也看到了一些重要的变化：</p><ol><li>我们删除了原始应用程序中的身份验证逻辑，并将其替换为第三方BaaS服务（例如，auth0）。</li><li>使用BaaS的另一个例子，我们允许客户直接访问我们的数据库的一个子集（用于产品列表），它本身完全由第三方（如Google FireBase）托管。与访问数据库的服务器资源相比，我们可能有不同的客户访问数据库的安全配置文件。</li><li>前两点暗示了一个非常重要的第三点：宠物店服务器中的一些逻实现在客户端中——例如，跟踪用户会话、了解应用程序的UX结构、从数据库中读取数据并将其转换为可用视图等。客户机正在很好地成为单页应用程序（<a href="https://en.wikipedia.org/wiki/Single-page_application" target="_blank" rel="noopener">Single Page Application</a>）。</li><li>我们可能希望在服务器中保留一些与UX相关的功能，例如，如果它是计算密集型的，或者需要访问大量数据。在我们的宠物店中，一个例子是“搜索”。我们可以实现FaaS功能，通过API网关响应HTTP请求（稍后描述），而不是像原始体系结构中那样始终运行的服务器。客户机和服务器的“搜索”功能都从同一数据库中读取产品数据。</li><li>最后，我们可以用另一个单独的FaaS Function替换我们的“购买”功能，出于安全原因选择将其保留在服务器端，而不是在客户端中重新实现。它前面也有一个API网关。在使用FaaS时，将不同的逻辑需求分解为单独部署的组件是一种非常常见的方法。</li></ol><p>退一步说，这个例子演示了关于Serverless架构的另一个非常重要的点。在原始版本中，所有流、控制和安全都由中央服务器应用程序管理。在Serverless版本中，这些问题没有中央仲裁器。相反，我们看到了一个偏好—-<strong>choreography over orchestration</strong>，每个组件都扮演着一个更具体系结构意识的角色，这也是微服务方法中常见的一个想法。</p><p>这种方法有很多好处。正如Sam Newman在他的《构建微服务》一书中指出的那样，以这种方式构建的系统通常“更灵活，更易于更改”，无论是作为一个整体，还是通过对组件的独立更新；对问题进行了更好的拆分；还有成本上的好处，这一点Gojko Adzic在<a href="https://gojko.net/2017/10/05/serverless-design-gotocph.html" target="_blank" rel="noopener">这篇精彩的演讲</a>中讨论过。</p><p>当然，这样的设计是一种权衡：它需要更好的分布式监控，而且我们更依赖于底层平台的安全功能。从根本上讲，我们需要处理的移动部件比我们最初使用的单片应用程序要多得多。灵活性和成本的好处是否值得增加多个后端组件的复杂性，这取决于上下文。</p><h3 id="消息驱动的应用（Message-driven-applications）"><a href="#消息驱动的应用（Message-driven-applications）" class="headerlink" title="消息驱动的应用（Message-driven applications）"></a>消息驱动的应用（Message-driven applications）</h3><p>另一个例子是后端数据处理服务。</p><p>假设您正在编写一个以用户为中心的应用程序，它需要快速响应UI请求，其次，它需要捕获正在发生的所有不同类型的用户活动，以便进行后续处理。想想一个在线广告系统：当用户点击一个广告时，你想很快地将他们重定向到该广告的目标。同时，你需要收集点击已经发生的事实，这样你就可以向广告商收费。</p><p>传统上，架构可能如下所示。“Ad Server”同步响应用户（图中未显示），并向Channel发送“点击消息”。然后，“Click Processor”应用程序将异步处理此消息，更新数据库，例如减少广告客户的预算。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/006tNc79gy1g3m3r96yhsj30gu03g74i.jpg" alt="Traditional Message-driven app arch"></p><p>在Serverless的世界中，这看起来如下：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/006tNc79gy1g3m3r4z0l0j30gx03emxf.jpg" alt="Serverless message-driven app arch"></p><p>你能看到区别吗？与第一个例子（Pet store）相比，这里的架构变化要小得多，这就是为什么异步消息处理是Serverless技术非常流行的用例。我们已经用FaaS Function替换了一个长期使用的消息消费者应用程序。此函数在供应商提供的事件驱动上下文中运行。请注意，云平台供应商同时提供消息代理和FaaS环境，这两个系统彼此紧密相连。</p><p>FaaS环境还可以通过实例化函数代码的多个副本并行处理多个消息。这取决于我们如何编写原始过程（original process），这可能是我们需要考虑的一个新概念。</p><h2 id="深入Function-as-a-Service（Unpacking-“Function-as-a-Service”）"><a href="#深入Function-as-a-Service（Unpacking-“Function-as-a-Service”）" class="headerlink" title="深入Function as a Service（Unpacking “Function as a Service”）"></a>深入Function as a Service（Unpacking “Function as a Service”）</h2><p>我们已经提到了很多关于FaaS的东西，是时候深入去看它到底意味着什么。为此，我们首先来看一下亚马逊FaaS产品Lambda的描述。作者在上面加了一些注释：</p><blockquote><p><em>AWS Lambda lets you run code without provisioning or managing servers.</em> <strong>(1)</strong> <em>… With Lambda, you can run code for virtually any type of application or backend service</em> <strong>(2)</strong> <em>- all with zero administration. Just upload your code and Lambda takes care of everything required to run</em> <strong>(3)</strong> <em>and scale</em> <strong>(4)</strong> <em>your code with high availability. You can set up your code to automatically trigger from other AWS services</em> <strong>(5)</strong> <em>or call it directly from any web or mobile app</em> <strong>(6)*</strong>. *</p></blockquote><ol><li><p>从根本上讲，FaaS是在不管理你的服务器系统或你的”长期运行的服务器应用程序“的情况下运行后端代码。当与容器和PaaS（平台即服务）等现代体系结构趋势进行比较时，第二条“长期运行的服务器应用程序”是一个关键区别。</p><p>如果我们回到前面的Click-processing的例子（就是广告那个例子），FaaS通过某种不需要服务器或者不需要应用程序一直运行的方式替换了点击处理服务器（可能是物理机器，但肯定是特定的应用程序）。</p></li><li><p>FaaS产品不需要编码到特定的框架或库中。FaaS函数在语言和环境方面是常规应用程序。例如，AWS lambda函数可以在Javascript、Python、Go、任何JVM语言（Java、Culjule、Scala等）或任何.NET语言中实现“first class”。然而，lambda函数也可以执行与另一个部署项目捆绑在一起的进程，因此您实际上可以使用任何可以编译为Unix进程的语言（参见本文后面的apex）。</p><p>尽管如此，FaaS功能具有显著的体系结构限制，尤其是在状态和执行持续时间方面。</p><p>让我们再次考虑一下我们的点击处理示例。当迁移到FaaS时，唯一需要更改的代码是“主方法”（启动）代码，因为它被删除，并且可能是顶级消息处理程序（消息侦听器接口）实现的特定代码，但这可能只是方法签名的更改。其余的代码（例如，写入数据库的代码）在FaaS世界中没有什么不同。</p></li><li><p>部署与传统系统非常不同，因为我们没有自己运行的服务器。在FaaS环境中，我们将函数的代码上传到FaaS服务提供者，从而执行配置资源、实例化虚拟机、管理进程等所需的所有其他操作。</p></li><li><p>水平伸缩是完全自动的、弹性的，并由提供者管理。如果您的系统需要并行处理100个请求，那么提供者将处理这些请求，而不需要您进行任何额外的配置。执行函数的“计算容器”是短暂的，FaaS提供者创建和销毁它们纯粹是由运行时需求驱动的。最重要的是，有了FaaS，供应商可以处理所有底层的资源配置和分配，用户根本不需要集群或虚拟机管理。</p><p>让我们回到Click-processor。假设我们今天过得很愉快，客户点击的广告数量是平常的十倍。对于传统的体系结构，我们的点击处理应用程序能够处理这个问题吗？例如，我们是否开发了能够一次处理多条消息的应用程序？如果我们这样做了，一个正在运行的应用程序实例是否足以处理负载？如果我们能够运行多个进程，缩放是自动的还是需要手动重新配置？使用FaaS的方式，所有这些问题都已经得到了解答，您需要提前编写函数来假设水平伸缩的并行性，但是从那时起FaaS提供程序会自动处理所有缩放需求。</p></li><li><p>FaaS中的函数通常由提供程序定义的事件类型触发。对于Amazon AWS，此类刺激包括S3（文件/对象）更新、时间（计划任务）和添加到消息总线的消息（例如，Kinesis）。</p></li><li><p>大多数提供者还允许函数作为对入站HTTP请求的响应而触发；在AWS中，通常通过使用API网关来实现这一点。我们在宠物店中使用了API网关作为“搜索”和“购买”功能的示例。函数也可以通过平台提供的API直接调用，可以从外部调用，也可以从同一个云环境中调用，但这是一种比较少见的用法。</p></li></ol><h3 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h3><p>当FaaS函数涉及到本地（机器/实例绑定）状态时，它有很大的限制，即存储在内存变量中的数据，或写入本地磁盘的数据。您确实有这样的存储可用，但是您不能保证这种状态在多个调用中是持久存在的，而且更强烈地说，您不应该假定一个函数的一次调用的状态对同一个函数的另一次调用是可用的。因此，FaaS函数通常被描述为无状态的，但更准确地说，FaaS函数的任何状态（需要持久化）都需要在FaaS函数实例之外进行外部化。</p><p>FaaS Function天生就是无状态的。比如，那些为输入到输出提供纯函数转换的函数，这是不需要考虑状态的。但对于其他人来说，这（无状态）可能会对应用程序体系结构产生很大的影响，尽管这不是一个独特的限制条件，<a href="https://12factor.net/" target="_blank" rel="noopener">“Twelve-Factor app”</a>概念有着<a href="https://12factor.net/processes" target="_blank" rel="noopener">完全相同的限制</a>。这种面向状态的函数通常使用数据库、跨应用程序缓存（如Redis）或网络文件/对象存储（如S3）来存储跨请求的状态，或提供处理请求所需的进一步输入。</p><h3 id="执行时间（Execution-duration）"><a href="#执行时间（Execution-duration）" class="headerlink" title="执行时间（Execution duration）"></a>执行时间（Execution duration）</h3><p>FaaS函数通常允许限制每次调用的时间。目前，对一个AWS lambda函数响应事件的“超时”最多是在被终止之前的五分钟。Microsoft Azure和Google云功能也有类似的限制。</p><p>这意味着，如果没有重新架构（re-architecture），某些长时间运行的任务类不适合FaaS函数，您可能需要创建几个不同的相互协作的FaaS函数，而在传统环境中，您可能有一个长时间运行任务正在执行和相互协作。</p><h3 id="启动延迟和”冷启动”-Startup-latency-and-“cold-starts”"><a href="#启动延迟和”冷启动”-Startup-latency-and-“cold-starts”" class="headerlink" title="启动延迟和”冷启动”(Startup latency and “cold starts”)"></a>启动延迟和”冷启动”(Startup latency and “cold starts”)</h3><p>FaaS平台在每个事件之前初始化函数的实例需要一些时间。即使对于一个特定的函数，启动延迟也会有很大的变化，这取决于大量的因素，并且可能在几毫秒到几秒之间。这听起来很糟糕，但让我们更具体一点，以AWS lambda为例。</p><p>lambda函数的初始化要么是“热启动”——从以前的事件中重用lambda函数及其主机容器的实例，要么是“冷启动”——创建一个新的容器实例，启动函数主机进程等。毫无疑问，在考虑启动延迟时，冷启动最值得关注。</p><p>冷启动延迟取决于许多变量：您使用的语言，您使用的库数量，您拥有的代码数量，Lambda函数环境本身的配置，是否需要连接到VPC资源等等。这些方面受开发人员的控制，因此通常可以减少作为冷启动的一部分而产生的启动延迟。</p><p>和冷启动时间同样的因素是冷启动的频率。例如，如果一个函数每秒处理10个事件，每个事件需要50毫秒来处理，那么每隔100,000-200,000个事件，您可能只会看到Lambda的冷启动。另一方面，如果您每小时处理一次事件，您可能会看到每个事件的冷启动，因为Amazon会在几分钟后退出非活动的Lambda实例。了解这一点有助于您了解冷启动是否会对聚合产生影响，以及您是否希望对您的函数实例执行“保持活跃”，以避免它们被放在pasture上。</p><p>冷启动需要被关注吗？这取决于您的应用程序的风格和流量类型。作者在Intent Media的前团队有一个用Java实现的异步消息处理Lambda应用程序（通常是启动时间最慢的语言），每天处理数亿条消息，他们不关心这个组件的启动延迟。也就是说，如果您正在编写一个低延迟交易应用程序，那么您可能不希望此时使用云托管的FaaS系统，无论您使用何种语言进行实施都没有关系。</p><p>无论您是否认为您的应用程序可能存在这样的问题，您都应该使用类似产品的负载测试性能。</p><p>有关冷启动的更多详细信息，请<a href="https://blog.symphonia.io/learning-lambda-part-8-addfab6b460d" target="_blank" rel="noopener">参阅</a>。</p><h3 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a>API Gateway</h3><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/006tNc79gy1g3m3r5fzfaj30zg08gwfr.jpg" alt="API Gateway"></p><p>前面提到的Serverless的一个方面是“API网关”。API网关是一个HTTP服务器，其中路由（Routes）和端点（endpoints）是在配置中定义的，并且每个路由都与处理该路由的资源相关联。在Serverless架构中，此类处理程序通常是FaaS函数。</p><p>当API网关收到请求时，它会找到与请求匹配的路由配置，如果有一个路由和一个FaaS函数匹配，原始请求将会调用相关的FaaS函数。通常，API网关将允许从HTTP请求参数映射到FaaS函数更简洁的输入，通常为JSON对象，或者允许整个HTTP请求通过。FaaS函数将执行其逻辑并将结果返回到api网关，然后将此结果转换为HTTP响应，并将其传递回原始调用方。</p><p>AWS有自己的API网关（有点让人困惑的名字叫“API网关”），其他供应商也提供类似的功能。亚马逊的API网关是一个BaaS（是的，BaaS！）服务本身就是一个服务，因为它是一个您配置的外部服务，但不需要自己运行或提供。</p><p>除了纯粹的路由请求之外，API网关还可以执行身份验证、输入验证、响应代码映射等。</p><p>有FaaS函数的api网关的一个用例是以Serverless方式创建HTTP前端的微服务，它具有FaaS功能带来的所有扩展、管理和其他好处。</p><h2 id="What-isn’t-Serverless"><a href="#What-isn’t-Serverless" class="headerlink" title="What isn’t Serverless?"></a>What isn’t Serverless?</h2><p>到目前为止，在本文中，我已经将Serverless描述为两种思想的结合：BaaS和FaaS。我还深入研究了后者的能力。为了更准确地了解我所看到的Serverless服务的关键属性（以及为什么我认为更老的服务（如S3）是Serverless的），参考：<a href="https://blog.symphonia.io/defining-serverless-part-1-704d72bc8a32" target="_blank" rel="noopener">定义Serverless</a>。</p><p>在我们开始研究非常重要的优点和缺点之前，我想在定义上再花一点时间。让我们定义一下什么不是Serverless。</p><h3 id="和PaaS对比"><a href="#和PaaS对比" class="headerlink" title="和PaaS对比"></a>和PaaS对比</h3><p>考虑到Serverless FaaS 函数与十二要素应用程序非常相似，它们是否只是“Platform as a Service”（paas）的另一种形式，如heroku？简单地说，我引用了Adrian Cockcroft的推特：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/006tNc79gy1g3m3r6t64qj30e908a3zh.jpg" alt="Serverless-vs-PaaS"></p><p>换句话说，大多数PaaS应用程序并不是为了响应事件而将整个应用程序启动和关闭，而FaaS平台恰恰是这样做的。</p><p>如果我是一个优秀的十二要素应用程序开发人员，这不一定影响我如何编程和设计我的应用程序，但它确实对我如何运维有很大的影响。因为我们都是很好DevOps-savvy工程师，所以我们对运维的思考和对开发的思考一样多，对吧？</p><p>FaaS和PaaS之间的关键操作区别在于可伸缩性。一般来说，对于PaaS，您仍然需要考虑如何缩放，例如，对于Heroku，您希望运行多少个Dyno？对于FaaS应用程序，这是完全透明的。即使将您的PaaS应用程序设置为自动缩放，您也不会将此设置为单个请求的级别（除非您有一个非常具体的流量配置文件），因此在成本方面，FaaS应用程序更高效。</p><p>考虑到这个好处，你为什么还要使用PaaS？有几个原因，但工具可能是最大的。还有一些人使用像CloudFoundry这样的PaaS平台，在公共云和私有云混合的基础上提供共同的开发体验；在撰写本文时，还没有一个与此相当成熟的FaaS。</p><h3 id="和容器对比"><a href="#和容器对比" class="headerlink" title="和容器对比"></a>和容器对比</h3><p>使用无服务器FaaS的原因之一是避免在操作系统级别管理应用程序进程。PaaS服务，如Heroku，也提供了这种功能，我在上面已经描述了PaaS与Serverless FaaS的区别。另一个流行的进程抽象是容器，Docker是这种技术最明显的例子。容器托管系统（如Meos和Kubernetes）从操作系统级部署中抽象出单个应用程序，越来越受欢迎。更进一步，我们可以看到云托管容器平台（如Amazon ECS和EKS）和谷歌容器引擎（如无服务器FaaS），它们让团队完全不必管理自己的服务器主机。考虑到容器的势头，考虑无服务器FaaS是否仍然值得？</p><p>主要地，我对PaaS的观点仍然适用于容器——对于Serverless的FaaS，伸缩是自动管理、透明和细粒度的，这与我前面提到的自动资源配置和分配有关。传统上，容器平台仍然需要您管理集群的大小和形状。</p><p>我还认为容器技术还不成熟和稳定，尽管它越来越接近成熟和稳定（作者的文章写于2017年，当时的容器技术还不够成熟）。当然，这并不是说无服务器FaaS已经成熟了，从两者中挑选一个依然是一个需要考虑的事。</p><p>同样重要的是，现在可以在容器平台中使用自扩展容器集群。 Kubernetes内置了“Horizontal Pod Autoscaling”，而像AWS Fargate这样的服务也实现了“Serverless Container”的承诺。</p><p>当我们看到无服务器FaaS和托管容器之间的管理和扩展差距缩小时，它们之间的选择可能只取决于应用程序的样式和类型。例如，FaaS可能被视为事件驱动样式的更好选择，每个应用程序组件的事件类型很少，容器被视为具有许多入口点（Entry Point）的同步请求驱动（synchronous-request–driven）组件的更好选择。我希望在很短的时间内，许多应用程序和团队都会使用这两种体系结构方法，并且看到这种使用模式的出现将会非常有吸引力。</p><h3 id="No-Ops"><a href="#No-Ops" class="headerlink" title="No Ops"></a>No Ops</h3><p>Serverless并不意味着“No Ops” - 虽然它可能意味着“没有系统管理员”（No sysadmin），这取决于你去的Serverless兔子洞的距离（depending on how far down the Serverless rabbit hole you go）。</p><p>“Ops”比”server administration”意味着更多。它还至少意味着：监控，部署，安全性，网络，支持，以及通常一些生产调试和系统扩展。这些问题在Serverless应用程序中仍然存在，您仍然需要一个策略来处理它们。在某些方面，Ops在Serverless世界中更难，因为其中很多都是如此新潮。</p><p>Sysadmin依然存在，只是你外包给了Serverless。这并不是一件坏事或者好事——我们有很多外包，它的好处和坏处依赖于具体你尝试要去做的事情。无论哪种方式，在某些时候抽象可能会泄漏，你需要知道某个地方的人类系统管理员正在支持你的应用程序。</p><p><a href="https://twitter.com/mipsytipsy" target="_blank" rel="noopener">Charity Majors</a>在第一个Serverlessconf上就<a href="https://www.youtube.com/watch?v=wgT5f0eBhD8" target="_blank" rel="noopener">这个主题进行了很好的讨论</a>。 （您还可以阅读她的两篇文章：<a href="https://charity.wtf/2016/05/31/wtf-is-operations-serverless/" target="_blank" rel="noopener">WTF is operations?</a>和<a href="https://charity.wtf/2016/05/31/operational-best-practices-serverless/" target="_blank" rel="noopener">Operational Best Practices</a>。）</p><h3 id="存储过程即服务（Stored-Procedures-as-a-Service）"><a href="#存储过程即服务（Stored-Procedures-as-a-Service）" class="headerlink" title="存储过程即服务（Stored Procedures as a Service）"></a>存储过程即服务（Stored Procedures as a Service）</h3><p>我看到的另一个主题是Serverless FaaS就是“存储过程即服务”（Stored Procedures as a Service）。我认为这是因为很多FaaS函数的例子（包括我在本文中使用的一些）都是一小段代码，并且与数据库紧密集成。如果这就是我们可以使用FaaS的全部，我认为这个名称会很有用，但因为它实际上只是FaaS功能的一个子集，所以我认为用这些术语来思考FaaS是没有用的。</p><p>话虽如此，值得考虑FaaS是否存在一些存储过程相同的问题，包括Camille在上述推文中提及的技术债务问题。使用存储过程可以获得许多教训，这些存储过程值得在FaaS环境中进行检查并查看它们是否适用。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/006tNc79gy1g3m3r7p6jpj30io0bmgn1.jpg" alt=""></p><p>考虑一下存储过程：</p><ol><li>通常需要特定于供应商的语言，或者至少需要特定于供应商的语言框架/扩展。</li><li>很难测试，因为它们需要在数据库的上下文中执行。</li><li>对版本控制或作为一等应用程序（first class application）处理是棘手的。</li></ol><p>虽然并非所有这些都必然适用于存储过程的所有实现，但它们肯定会遇到问题。让我们看看它们是否适用于FaaS：</p><ul><li><p>For（1）对于我到目前为止看到的FaaS实现绝对不是一个问题，因此我们可以立即从列表中删除它。</p></li><li><p>For（2）因为我们正在处理“只是代码”，所以单元测试绝对和其他任何代码一样简单。集成测试虽然是一个不同的问题，我们将在后面讨论。</p></li><li><p>For（3）再次，因为FaaS功能是“只是代码”版本控制是可以的。直到最近，应用程序打包也是一个问题，但是已经逐渐成熟，使用亚马逊的<a href="https://docs.aws.amazon.com/lambda/latest/dg/serverless_app.html" target="_blank" rel="noopener">Serverless Application Model</a>（SAM）和前面提到的Serverless框架等工具。在2018年初，亚马逊甚至推出了“<a href="https://aws.amazon.com/serverless/serverlessrepo/" target="_blank" rel="noopener">Serverless Application Repository</a>”（SAR），为组织提供了一种基于AWS Serverless服务构建应用程序和应用程序组件的方法。 （更多关于SAR参考：“<a href="https://blog.symphonia.io/examining-the-aws-serverless-application-repository-9ef316e2fd4" target="_blank" rel="noopener">Examining the AWS Serverless Application Repository</a>”）</p></li></ul><h2 id="Benifits"><a href="#Benifits" class="headerlink" title="Benifits"></a>Benifits</h2><p>到目前为止，我主要解释了Serverless Architecture的含义。现在，我将讨论这种设计和部署应用程序的方法的一些优点和缺点。如果没有反复思考和权衡利弊，你绝对不应该决定使用Serverless。</p><p>让我们从<a href="https://www.urbandictionary.com/define.php?term=rainbows%20and%20unicorns" target="_blank" rel="noopener">rainbows and unicorns</a>的地方开始，看看Serverless的好处。</p><h3 id="降低运维成本-Reduced-operational-cost"><a href="#降低运维成本-Reduced-operational-cost" class="headerlink" title="降低运维成本(Reduced operational cost)"></a>降低运维成本(Reduced operational cost)</h3><blockquote><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/006tNc79gy1g3m3r5ypicj32600figrl.jpg" alt="Economies of sacle"></p></blockquote><p>Serverless是最简单的外包解决方案。它允许您向某人付费以管理您自己可能管理的服务器，数据库甚至应用程序逻辑。由于您正在使用许多其他人也将使用的预定义服务，因此我们看到了规模经济（<a href="https://en.wikipedia.org/wiki/Economies_of_scale" target="_blank" rel="noopener">Economy of Scale</a>）效应：因为一个供应商运行着数千个非常相似的数据库，所以你为管理数据库的花费就越低。</p><p>(可以简单理解为：因为量大，所以便宜)。</p><p>降低的成本在两个方面表现为总和。首先是纯粹来自与其他人共享基础设施（例如，硬件，网络）的基础设施成本增益。第二个是人工成本增加：相比自己开发和管理，您可以在外包的Serverless系统上花费更少的时间。</p><p>但是，这种好处与您从基础架构即服务（IaaS）或平台即服务（PaaS）中获得的好处并没有太大差别。但我们可以通过两种主要方式扩展这种优势，每种方式都适用于无服务器BaaS和FaaS。</p><h3 id="BaaS：降低了开发成本-BaaS-reduced-development-cost"><a href="#BaaS：降低了开发成本-BaaS-reduced-development-cost" class="headerlink" title="BaaS：降低了开发成本(BaaS: reduced development cost)"></a>BaaS：降低了开发成本(BaaS: reduced development cost)</h3><p>IaaS和PaaS基于服务器和操作系统管理可以商品化的前提。另一方面，Serverless BaaS是整个应用程序组件商品化的结果。</p><p>身份验证是一个很好的例子许多应用程序编写自己的身份验证功能，这些功能通常包括注册，登录，密码管理以及与其他身份验证提供程序集成等功能。总的来说，这种逻辑在大多数应用程序中非常相似，并且已经创建了像Auth0这样的服务，以允许我们将现成的身份验证功能集成到我们的应用程序中，而无需我们自己开发它。</p><p>同样对于BaaS databases，例如<a href="https://firebase.google.com/docs/database/" target="_blank" rel="noopener">Firebase’s database service</a>。一些移动应用程序团队发现让客户端直接与服务器端数据库通信是有意义的。 BaaS数据库消除了大部分数据库管理开销，并且通常提供以Serverless应用程序所期望的模式对不同类型的用户执行适当授权的机制。</p><p>根据您的背景，这些想法可能会让您感到不安（可能出于我们将在缺陷部分介绍的原因）。但是不可否认的是，那些成功的公司，他们的引人注目的产品可以没有任何服务端代码。Joe Emison在第一届Serverless Conference上给了<a href="http://www.slideshare.net/ServerlessConf/joe-emison-10x-product-development" target="_blank" rel="noopener">几个例子</a>。</p><h3 id="FaaS-伸缩成本-FaaS-scaling-costs"><a href="#FaaS-伸缩成本-FaaS-scaling-costs" class="headerlink" title="FaaS: 伸缩成本(FaaS: scaling costs)"></a>FaaS: 伸缩成本(FaaS: scaling costs)</h3><p>正如前文提到的那样，Serverless FaaS最大的好处就是完全自动化的、弹性的和被第三方托管的横向伸缩。</p><p>这有几个好处，但在基本的基础架构方面，最大的好处是您只需支付所需的计算，在AWS Lambda的情况下，最低可达100ms。依赖于你的流量规模和类型，这将带来巨大的经济收益。</p><h4 id="示例：间隔性的请求-Example-occasional-requests"><a href="#示例：间隔性的请求-Example-occasional-requests" class="headerlink" title="示例：间隔性的请求(Example: occasional requests)"></a>示例：间隔性的请求(Example: occasional requests)</h4><p>假设您正在运行的服务器应用程序每分钟只处理一个请求，处理每个请求需要50毫秒，而您在一小时内的平均CPU使用率为0.1％。如果将此应用程序部署到其自己的专用主机，那么这非常低效。其他一千个类似的应用程序都可以共享这台机器。</p><p>无服务器FaaS捕获了这种低效率，以降低的成本带来收益。使用上面的示例应用程序，您每分钟只需支付100毫秒的计算费用，这是整个时间的0.15％。</p><p>这具有以下连锁效益：</p><ul><li>对于具有非常小的负载要求的潜在微服务，它支持按逻辑/域分解组件，即使这种精细粒度的操作成本可能已经过高。</li><li>这样的成本效益是一个伟大的民主化者。如果公司或团队想要尝试一些新的东西，那么当他们使用FaaS满足他们的计算需求时，可以在很低的成本下开始一段新的旅程（dipping their toe in the water）。实际上，如果您的总工作量相对较小（但并非完全无关紧要），由于某些FaaS供应商提供的“免费套餐”（free tier），您可能根本不需要为任何计算付费。</li></ul><h4 id="示例：变化的流量"><a href="#示例：变化的流量" class="headerlink" title="示例：变化的流量"></a>示例：变化的流量</h4><p>让我们来看另外一个例子。假如你的流量是起伏不定的，并且你的流量的baseline是每秒处理20个请求，但是每间隔5分钟，你每秒会收到20个请求，持续10秒。为了示例，我们还假设您的基准性能（baseline performance）最大化了您的首选主机服务器类型，并且您不希望在流量峰值阶段减少响应时间。你怎么解决这个问题？</p><p>在传统环境中，您可能需要将总硬件数量增加10倍，而不只是处理峰值的情况，即使峰值的总持续时间不到总机器正常运行时间的4％。自动扩展可能不是一个好的选择，因为新的实例启动时，服务器需要长时间才能启动，此时峰值阶段将结束。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/006tNc79gy1g3m3r6d79cj30gs0a23z2.jpg" alt="inconsistent-traffic-pattern-traditional-deployment"></p><p>对于Serverless FaaS来说这并不是一个问题。你的流量配置不会发生任何改变，只需要为波峰阶段的流量额外的计算付费就行。</p><p>显然，我故意在这里选择Serverless FaaS可以节省大量成本的示例，但重点是从扩展的角度来看，FaaS可以为你节约成本。除非你有一个一直使用服务器主机的整个容量、非常稳定的流量形状。</p><p>关于上述内容的一个警告：如果您的流量是统一的并且能够始终如一地利用正在运行的服务器，您可能看不到这种成本效益，并且您实际上使用FaaS可能花费更多。您应该进行一些数学运算，并将当前的提供商成本开销与运行全时服务器进行比较，以确定成本是否可接受。</p><p>有关FaaS成本效益的更多详细信息，我建议使用该文章<a href="http://www.doc.ic.ac.uk/~rbc/papers/fse-serverless-17.pdf" target="_blank" rel="noopener">Serverless Computing: Economic and Architectural Impact</a>。</p><h4 id="优化是节约成本的根本-Optimization-is-the-root-of-some-cost-savings"><a href="#优化是节约成本的根本-Optimization-is-the-root-of-some-cost-savings" class="headerlink" title="优化是节约成本的根本(Optimization is the root of some cost savings)"></a>优化是节约成本的根本(Optimization is the root of some cost savings)</h4><p>对于FaaS成本还有一个有趣的方面：您对代码进行的任何性能优化不仅会提高应用程序的速度，而且还会直接、立即导致运维成本的降低，这具体取决于您的供应商的收费方案的粒度。 例如，假设应用程序最初需要一秒钟来处理事件。 如果通过代码优化将其减少到200毫秒，它将（在AWS Lambda上）立即看到计算成本节省80％而不进行任何基础架构更改。</p><h3 id="运维管理变得更加简单-Easier-operational-management"><a href="#运维管理变得更加简单-Easier-operational-management" class="headerlink" title="运维管理变得更加简单(Easier operational management)"></a>运维管理变得更加简单(Easier operational management)</h3><p>下一部分附带一个巨大的星号 - 运维的某些方面对于Serverless来说仍然很难，但是现在我们仍然坚持我们的<a href="https://www.urbandictionary.com/define.php?term=rainbows%20and%20unicorns" target="_blank" rel="noopener">rainbows and unicorns</a>朋友。</p><p>在Serverless的BaaS方面，很明显为什么运维管理比其他架构更简单：支持更少的组件等于更少的工作。</p><p>在FaaS方面，有许多方面在起作用，我将深入研究其中的几个方面。</p><h4 id="FaaS的伸缩收益不仅仅是基础设施的成本方面（Scaling-benefits-of-FaaS-beyond-infrastructure-costs）"><a href="#FaaS的伸缩收益不仅仅是基础设施的成本方面（Scaling-benefits-of-FaaS-beyond-infrastructure-costs）" class="headerlink" title="FaaS的伸缩收益不仅仅是基础设施的成本方面（Scaling benefits of FaaS beyond infrastructure costs）"></a>FaaS的伸缩收益不仅仅是基础设施的成本方面（Scaling benefits of FaaS beyond infrastructure costs）</h4><p>经过上一节的描述，伸缩(Scaling)在我们脑海中依然是一个新东西。值得注意的是，FaaS的函数级的扩展不仅降低了计算成本，还简化了运维管理，因为伸缩是自动的。</p><p>在最好的情况下，如果您的伸缩过程是手动的，那么需要人明确地向一组服务器添加和删除实例 - 使用FaaS，您可以高兴地忘记这一点并让您的FaaS供应商为您伸缩您的应用程序。</p><p>即使您已经在非FaaS架构中使用自动伸缩，但这仍然需要设置和维护。 FaaS不再需要这项工作。</p><p>类似地，<strong>因为扩展是提供商基于每个请求或事件的</strong> ，因此您不再需要考虑在内存不足或看到太多性能冲击之前可以处理多少并发请求的问题 - 至少系统中的托管的FaaS组件不用考虑这个问题。 考虑到其负载可能显着增加，必须重新考虑下游数据库和非FaaS组件。</p><h4 id="降低了打包和部署的复杂度（Reduced-packaging-and-deployment-complexity）"><a href="#降低了打包和部署的复杂度（Reduced-packaging-and-deployment-complexity）" class="headerlink" title="降低了打包和部署的复杂度（Reduced packaging and deployment complexity）"></a>降低了打包和部署的复杂度（Reduced packaging and deployment complexity）</h4><p>与部署整个服务器相比，打包和部署FaaS Function非常简单。您所做的就是将所有代码打包到一个zip文件中，然后上传它。没有Puppet / Chef，没有启动/停止shell脚本，也没有关于是否在计算机上部署一个或多个容器的决定。如果您刚开始使用，甚至不需要打包任何东西 - 您可以在供应商控制台本身编写代码（显然，这不建议用于生产环境的代码！）。</p><p>这个过程不需要花费很长时间来描述，但对于一些团队而言，这种好处可能非常巨大：完全的Serverless解决方案需要零系统管理。</p><p>PaaS解决方案具有类似的部署优势，但正如我们之前所看到的，在将PaaS与FaaS进行比较时，扩展优势是FaaS独有的。</p><h4 id="上市时间和持续实验（Time-to-market-and-continuous-experimentation）"><a href="#上市时间和持续实验（Time-to-market-and-continuous-experimentation）" class="headerlink" title="上市时间和持续实验（Time to market and continuous experimentation）"></a>上市时间和持续实验（Time to market and continuous experimentation）</h4><p>更容易的运维管理是我们工程师所理解的好处，但这对我们的业务意味着什么？</p><p>显而易见的原因是成本：花在操作上的时间减少等于操作所需的人数减少，正如我已经描述的那样。但在我看来，一个更重要的原因是<a href="https://en.wikipedia.org/wiki/Time_to_market" target="_blank" rel="noopener">上市时间</a>。随着我们的团队和产品越来越多地面向精益和敏捷流程，我们希望不断尝试新事物并快速更新现有系统。虽然在持续交付的情况下进行简单的重新部署可以快速迭代稳定的项目，但是具有良好的新想法到初始部署（<em>new-idea-to-initial-deployment</em>）能力使我们能够以低摩擦和最低成本尝试新的实验。</p><p>FaaS的新想法到初始部署故事通常非常出色，特别是对于由供应商生态系统中的成熟定义事件触发的简单功能。例如，假设您的组织已经在使用AWS Kinesis（一种类似Kafka的消息传递系统），通过您的基础架构广播各种类型的实时事件。使用AWS Lambda，您可以在几分钟内针对该Kinesis流开发和部署新的生产事件监听器 - 您可以在一天内尝试几个不同的实验！</p><p>虽然成本效益是Serverless最容易表达的改进，但这种缩短的交付时间让我最兴奋。它可以实现<a href="https://www.youtube.com/watch?v=mzjhEZLTEpM" target="_blank" rel="noopener">持续实验</a>的产品开发思维，这是我们如何在公司中交付软件的真正革命。</p><h3 id="“更绿色的”计算？-“Greener”-computing"><a href="#“更绿色的”计算？-“Greener”-computing" class="headerlink" title="“更绿色的”计算？(“Greener” computing?)"></a>“更绿色的”计算？(“Greener” computing?)</h3><p>在过去的几十年中，世界上数据中心的数量和规模都在大幅增加。除了建立这些中心所需的物质资源外，相关的能源需求如此之大，以至于苹果，谷歌等都在谈论将一些数据中心托管在可再生能源附近以减少化石燃料燃烧的影响本来是必要的。</p><p>空闲的，但是通电的，服务器消耗了大量的能源 - 而且它们是我们需要这么多，更大的数据中心的重要原因之一：</p><blockquote><p>商业和企业数据中心中的典型服务器在一年中平均提供其最大计算输出的5％到15％。</p><p>— <a href="http://www.forbes.com/sites/benkepes/2015/06/03/30-of-servers-are-sitting-comatose-according-to-research/#2f4944612c2" target="_blank" rel="noopener">Forbes</a></p></blockquote><p>这非常低效，并产生巨大的环境影响。</p><p>一方面，云基础设施可能已经帮助减少了这种影响，因为公司可以按需“购买”更多的服务器，只有当他们绝对需要时，而不是提前很长时间提供所有可能必需的服务器。 然而，人们还可以争辩说，如果没有足够的容量管理，很多服务器都会被丢弃，那么provision服务器的容易程度可能会使情况变得更糟。</p><p>无论我们使用自托管服务器，IaaS还是PaaS基础架构解决方案，我们仍然会手动制定关于我们的应用程序的容量决策，这些决策通常会持续数月或数年。通常，我们对管理容量持谨慎态度，因此我们过度提供资源（over-provison），导致刚才描述的效率低下。使用Serverless方法，我们不再自己做出这样的容量决策 - 我们让Serverless供应商为我们的实时需求提供足够的计算容量。然后，供应商可以在其客户中汇总做出自己的容量决策。</p><p>与传统的容量管理方法相比，这种差异应该可以更有效地跨数据中心使用资源，从而减少对环境的影响。</p><h2 id="缺陷-Drawbacks"><a href="#缺陷-Drawbacks" class="headerlink" title="缺陷(Drawbacks)"></a>缺陷(Drawbacks)</h2><p>所以，亲爱的读者，我希望你在彩虹，独角兽以及所有闪亮而美好的事物中享受你的时光，因为我们即将被现实中的湿鱼给予一记耳光。</p><p>有很多原因让我们喜欢Serverless架构，但是使用Serverless架构前依然需要权衡利弊。有些利弊是这个概念所固有的（trade-offs are inherent to the concepts），并不能通过持续的优化被完全解决掉，所以这些利弊总是需要被考虑。其他的问题已经和现有的实现联系到一起，随着时间流逝，这些问题，总是会被解决掉的。</p><h3 id="固有的缺陷（Inherent-drawbacks）"><a href="#固有的缺陷（Inherent-drawbacks）" class="headerlink" title="固有的缺陷（Inherent drawbacks）"></a>固有的缺陷（Inherent drawbacks）</h3><h4 id="供应商控制（Vendor-control）"><a href="#供应商控制（Vendor-control）" class="headerlink" title="供应商控制（Vendor control）"></a>供应商控制（Vendor control）</h4><p>通过任何外包策略，您可以将某些系统的控制权交给第三方供应商。这种缺乏控制可能表现为系统停机，意外限制，成本变化，功能丧失，强制API升级等。我之前提到的Charity Majors在<a href="https://charity.wtf/2016/05/31/operational-best-practices-serverless/" target="_blank" rel="noopener">这篇文章</a>的权衡部分更详细地解释了这个问题：</p><blockquote><p>[供应商服务]，如果它是智能的，将对您如何使用它施加强大的限制，因此他们更有可能实现其可靠性目标。当用户具有灵活性和选项时，会产生混乱和不可靠性。如果平台必须在您的幸福与成千上万的其他客户的幸福之间做出选择，那么他们每次都会选择多人 - 就像他们应该的那样。</p><p><a href="https://charity.wtf/2016/05/31/operational-best-practices-serverless/" target="_blank" rel="noopener">– Charity Majors</a></p></blockquote><h4 id="多租户问题（Multitenancy-problems）"><a href="#多租户问题（Multitenancy-problems）" class="headerlink" title="多租户问题（Multitenancy problems）"></a>多租户问题（Multitenancy problems）</h4><p>多租户是指多个不同客户（或租户）的多个软件实例在同一台机器上运行，并且可能在同一主机应用程序中运行的情况。这是我们前面提到的实现规模经济效益的战略。服务供应商尽最大努力让客户觉得他们每个人都是唯一使用他们系统的人，通常优秀的服务供应商也能做得很好。但是，没有完美的方案，有时多租户解决方案可能存在安全问题（一个客户能够看到另一个客户的数据），稳健性（一个客户软件中的错误导致另一个客户的软件出现故障）和性能（高负载客户）导致另一个人放慢速度）。</p><p>这些问题并非Serverless系统所独有 - 它们存在于使用多租户的许多其他服务产品中。 AWS Lambda现在已经足够成熟，我们不希望看到这些问题，但是您应该关注任何不太成熟的服务的问题，无论是来自AWS还是其他供应商。</p><h4 id="供应商绑定（Vendor-lock-in）"><a href="#供应商绑定（Vendor-lock-in）" class="headerlink" title="供应商绑定（Vendor lock-in）"></a>供应商绑定（Vendor lock-in）</h4><p>您从一个供应商处使用的Serverless功能很可能会被另一个供应商以不同方式实现。如果您想切换供应商，您几乎肯定需要更新您的操作工具（部署，监控等），您可能需要更改您的代码（例如，以满足不同的FaaS界面），您甚至可能如果竞争厂商的实施行为存在差异，则需要更改您的设计或架构。</p><p>即使您设法轻松迁移生态系统的一部分，您也可能受到另一个体系结构组件的更大影响。例如，假设您使用AWS Lambda来响应AWS Kinesis消息总线上的事件。 AWS Lambda，Google Cloud Functions和Microsoft Azure Functions之间的差异可能相对较小，但您仍然无法将后两个供应商实施直接连接到您的AWS Kinesis流。这意味着，如果不移动基础架构的其他模块，则无法将代码从一个解决方案移动或移植到另一个解决方案。</p><p>很多人都对这个想法感到害怕 - 要知道如果你今天所选择的云供应商明天需要改变，意味着你还有很多工作要做，那就不是很好了。因此，有些人采用“多云”（Muiti-cloud）方法，以与所使用的实际云供应商无关的方式开发和运营应用程序。这通常比单云方法更昂贵 - 因此虽然供应商绑定（Vendor lock-in）是一个合理的问题，但我仍然建议选择一个您满意的供应商并尽可能地利用他们的能力。我在<a href="https://blog.symphonia.io/on-serverless-multi-cloud-and-vendor-lock-in-da930b3993f" target="_blank" rel="noopener">这篇文章</a>中更多地讨论了为什么会这样。</p><h4 id="安全问题（Security-concerns）"><a href="#安全问题（Security-concerns）" class="headerlink" title="安全问题（Security concerns）"></a>安全问题（Security concerns）</h4><p>采用Serverless方法可以解决大量安全问题。这里只是一些细微的事情要考虑 - 一定要探索还有什么可以影响你。</p><ul><li><p>您使用的每个Serverless供应商都会增加您的生态系统所包含的不同安全设施的数量。这增加了恶意攻击的风险，并增加攻击成功的可能性。</p></li><li><p>如果直接从您的移动平台使用BaaS数据库，您将失去一个服务器端应用程序在传统应用程序中提供的保护屏障。虽然这不是一个dealbreaker，但在设计和开发应用程序时需要非常小心。</p></li><li><p>当您的组织接受FaaS时，您可能会遇到整个公司内部FaaS函数的寒武纪大爆发。这些函数中的每一个都提供了另一个问题向量。例如，在AWS Lambda中，每个Lambda函数通常与配置的<a href="https://docs.aws.amazon.com/lambda/latest/dg/access-control-identity-based.html" target="_blank" rel="noopener">IAM policy</a>齐头并进，这很容易出错。这不是一个简单的主题，也不是一个可以忽略的主题。 IAM管理需要仔细考虑，至少在生产AWS账户中是这样。</p></li></ul><h4 id="跨客户端平台的逻辑重复（Repetition-of-logic-across-client-platforms）"><a href="#跨客户端平台的逻辑重复（Repetition-of-logic-across-client-platforms）" class="headerlink" title="跨客户端平台的逻辑重复（Repetition of logic across client platforms）"></a>跨客户端平台的逻辑重复（Repetition of logic across client platforms）</h4><p>使用“完整”的BaaS架构，服务器端不会编写自定义逻辑 - 它都在客户端中。这对您的第一个客户端平台来说可能没问题，但是只要您需要下一个平台，您就需要重复执行该逻辑的一个子集 - 您不需要在更传统的架构中重复干这些事情。例如，如果在这种系统中使用BaaS数据库，那么您的所有客户端应用程序（可能是Web，native iOS和native Android）现在都需要能够与您的供应商数据库进行通信，并且需要了解如何映射数据库schema到应用程序逻辑。</p><p>此外，如果你想在任何时候迁移到新的数据库，你需要在所有客户端复制并且协调代码。</p><h4 id="失去了服务器的优化（Loss-of-server-optimizations）"><a href="#失去了服务器的优化（Loss-of-server-optimizations）" class="headerlink" title="失去了服务器的优化（Loss of server optimizations）"></a>失去了服务器的优化（Loss of server optimizations）</h4><p>使用完整的BaaS架构，您无法为客户端性能来优化服务器设计以。 “<a href="http://samnewman.io/patterns/architectural/bff/" target="_blank" rel="noopener">Backend For Frontend</a>”模式的存在是为了在服务器中抽象整个系统的某些底层方面，部分原因是客户端可以更快地执行操作，并且在移动应用程序中使用更少的电池电量。这种模式不适用于完整的BaaS。</p><p>这一点和前一点都存在于完整的BaaS体系结构中，其中所有自定义逻辑都在客户机中，只有后端服务是由供应商提供的。这两种方法的一个缓解措施是采用FaaS，或者其他类型的轻量级服务器端模式，将某些逻辑移动到服务器上。</p><h4 id="Serverless-FaaS没有服务器内状态（No-in-server-state-for-Serverless-FaaS）"><a href="#Serverless-FaaS没有服务器内状态（No-in-server-state-for-Serverless-FaaS）" class="headerlink" title="Serverless FaaS没有服务器内状态（No in-server state for Serverless FaaS）"></a>Serverless FaaS没有服务器内状态（No in-server state for Serverless FaaS）</h4><p>在经历了几个特定于BaaS的缺点之后，我们暂时谈谈FaaS。我刚才说过：</p><blockquote><p>当涉及到本地状态时，FaaS功能有很大的限制。 ..您不应该假设一次调用函数的状态可用于同一函数的另一次调用。</p></blockquote><p>这种假设的原因是，使用FaaS，我们通常无法控制函数的主机容器何时启动和停止。</p><p>我之前也说过，本地状态的替代方案是遵循Twelve-Factor应用程序的第六个factor，即：</p><blockquote><p>Twelve-factor processes are stateless and share-nothing. Any data that needs to persist must be stored in a stateful backing service, typically a database.</p><p><a href="http://12factor.net/processes" target="_blank" rel="noopener">– The Twelve-Factor App</a></p></blockquote><p>Heroku推荐这种思维方式，但是你可以在运行他们的PaaS时违反这个规则，因为你可以控制Heroku Dynos的启动和停止时间。使用FaaS则不会违反这个规则。</p><p>既然你不能将状态存储在内存中，那么如何在FaaS中使用状态呢？上面的引用是使用数据库，但在更多情况下是使用更快的NoSQL数据库，进程外缓存（比如：Redis），或者外部对象/文件存储（比如：S3）都会是你的选择。但是这些方法都会比内存或本机存储要慢一些。你需要考虑你的应用程序是否适合这些情况。</p><p>在这方面的另一个问题是内存缓存。许多应用从外部读取大型数据集并将其子集存储到内存中缓存中。您可能正在读取数据库中的“参考数据”表并使用Ehcache之类的东西。或者，您可能正在从指定缓存头的HTTP服务中读取，在这种情况下，内存中的HTTP客户端可以提供本地缓存。</p><p>FaaS确实允许使用本地缓存，假设您的功能足够频繁使用，这可能很有用。例如，对于AWS Lambda，我们通常期望一个函数实例可以保持几个小时，只要它每隔几分钟至少使用一次。这意味着我们可以使用Lambda可以为我们提供的（可配置的）3 GB RAM或512 MB本地“/ tmp”空间。对于某些缓存，这可能就足够了。否则，您将不再需要进程内缓存，并且您需要使用像Redis或Memcached这样的低延迟外部缓存。但是，这需要额外的工作，并且根据您的使用情况可能会非常慢。</p><h3 id="实施缺陷（Implementation-drawbacks）"><a href="#实施缺陷（Implementation-drawbacks）" class="headerlink" title="实施缺陷（Implementation drawbacks）"></a>实施缺陷（Implementation drawbacks）</h3><p>以前描述的缺点可能总是存在于Serverless架构中。我们会看到缓和解决方案的改进，但它们总会在那里。</p><p>然而，其余的缺点完全取决于现有技术水平。随着供应商和/或英雄的社区的意愿和投入，这些问题都可以被消灭。事实上，自从本文的第一个版本以来，这个drawback列表已经缩小了。</p><h4 id="配置（Configuration）"><a href="#配置（Configuration）" class="headerlink" title="配置（Configuration）"></a>配置（Configuration）</h4><p>当我编写本文的第一个版本时，AWS几乎没有提供Lambda函数的配置方式。我很高兴地说现在已经修复了，但是如果你使用一个不太成熟的平台，它仍然是值得检查的东西。</p><h4 id="对自己进行DoS攻击（Dos-yourself）"><a href="#对自己进行DoS攻击（Dos-yourself）" class="headerlink" title="对自己进行DoS攻击（Dos yourself）"></a>对自己进行DoS攻击（Dos yourself）</h4><p>这里有一个例子，说明为什么当你处理FaaS时，”买者自负”（caveat emptor）是一个关键词。AWS Lambda限制您在给定时间可以运行的Lambda函数的并发执行次数。说这个限制是一千;这意味着您可以随时执行一千个函数实例。如果你需要超过它，你可能会开始获得异常，排队和/或一般减速。</p><p>这里的问题是这个限制是在整个AWS账户中。有些组织使用相同的AWS账户进行生产和测试。这意味着如果组织中的某个人在您的组织中执行新类型的负载测试并开始尝试执行一千个并发的Lambda函数，那么您将意外地对生产系统发起DoS攻击。Oops。</p><p>即使您使用不同的AWS账户进行生产和开发，一个重载的生产环境的lambda（例如，处理来自客户的批量上载）也可能导致您的单独的实时lambda支持的生产系统API无响应。</p><p>亚马逊在这里做了一些保护，通过保留并发的方式（<a href="https://blog.symphonia.io/aws-lambda-reserved-concurrency-f2c3a32b9f1d" target="_blank" rel="noopener">by way of <strong>reserved concurrency</strong></a>）。保留的并发性允许您限制Lambda函数的并发性，以便它不会炸毁您帐户的其余部分，同时确保无论帐户中的其他功能正在执行什么，总是有可用容量。但是，默认情况下，帐户不会启用保留并发，需要仔细管理。</p><h4 id="执行时间（Execution-duration）-1"><a href="#执行时间（Execution-duration）-1" class="headerlink" title="执行时间（Execution duration）"></a>执行时间（Execution duration）</h4><p>在文章的前面我提到AWS Lambda函数如果运行时间超过五分钟就会中止。这已经持续了几年，并且AWS没有显示出改变它的迹象。</p><h4 id="启动延迟（Startup-latency）"><a href="#启动延迟（Startup-latency）" class="headerlink" title="启动延迟（Startup latency）"></a>启动延迟（Startup latency）</h4><p>我之前谈过冷启动，并提到了我关于这个主题的文章。 AWS随着时间的推移已经改进了这个领域，但是这里仍然存在重大问题，特别是对于偶尔触发的JVM实现的功能和/或需要访问VPC资源的功能。预计该领域将继续改善。</p><h4 id="测试（Testing）"><a href="#测试（Testing）" class="headerlink" title="测试（Testing）"></a>测试（Testing）</h4><p>单元测试Serverless应用程序非常简单，原因我之前已经讨论过：你编写的任何代码都是“只是代码”，并且大多数情况下你不必使用大量的自定义库或你需要实现的接口。</p><p>另一方面，集成测试Serverless应用程序很困难。在BaaS世界中，您有意依赖外部提供的系统，而不是您自己的数据库。那么，集成测试也应该使用外部系统吗？如果是，那么这些系统对测试场景的适应性如何？你能轻易地消除状态吗？您的供应商能否为负载测试提供不同的计费策略？</p><p>如果你想要为外部系统的集成测试打桩，提供商提供的本地桩（local stub）模拟吗？如果是，这些桩的精确度好吗？如果提供商不提供桩你应该怎样自己实现？</p><p>FaaS领域也存在同样的问题，尽管这方面有所改善。现在可以在本地为Lambda和Microsoft Azure运行FaaS Function。但是，没有本地环境可以完全模拟云环境;完全依赖于本地FaaS环境并不是我推荐的策略。实际上，我会进一步建议，运行自动化集成测试的规范环境（至少作为<a href="https://martinfowler.com/bliki/DeploymentPipeline.html" target="_blank" rel="noopener">deployment pipeline</a>的一部分）应该是云，并且您应该使用本地测试环境主要用于交互式开发和调试。这些本地测试环境不断改进 - 例如，<a href="https://github.com/awslabs/aws-sam-cli" target="_blank" rel="noopener">SAM CLI</a>为开发Lambda支持的HTTP API应用程序提供快速反馈。</p><p>还记得我在云端运行集成测试时提到的几个部分以前的跨帐户执行限制吗？您可能希望至少将此类测试与生产云帐户隔离开来，并且可能使用比此更细粒度的帐户。</p><p>考虑集成测试是一件大事的部分原因是，我们与无服务器FAA（即每个功能）的集成单元比与其他架构的集成单元小得多，因此我们比与其他架构风格的集成测试依赖得更多。</p><p>依靠基于云的测试环境而不是在我的笔记本电脑上本地运行所有内容对我来说非常震惊。但是时代变了，我们从云端获得的功能与Google等工程师十多年来的相似。亚马逊现在甚至允许您在云中运行IDE。</p><h4 id="调试（Debugging）"><a href="#调试（Debugging）" class="headerlink" title="调试（Debugging）"></a>调试（Debugging）</h4><p>使用FaaS进行调试是一个有趣的领域。这里取得了一些进展，主要与本地运行FaaS Function有关，与上面讨论的测试更新一致。正如我前面提到的，Microsoft为本地运行但由远程事件触发的函数提供了出色的调试支持。亚马逊提供类似的东西，但尚未被生产事件触发。</p><p>实际在生产云环境中运行的调试功能是另一回事。 Lambda至少对此没有支持，尽管看到这样的能力会很棒。</p><h4 id="部署，打包和版本控制（Deployment-packaging-and-versioning）"><a href="#部署，打包和版本控制（Deployment-packaging-and-versioning）" class="headerlink" title="部署，打包和版本控制（Deployment, packaging, and versioning）"></a>部署，打包和版本控制（Deployment, packaging, and versioning）</h4><p>这是一个正在积极改进的领域。 AWS在改进这一领域方面取得了巨大进步，稍后我将在“Serverless的未来”部分进一步讨论。</p><h4 id="发现机制（Discovery）"><a href="#发现机制（Discovery）" class="headerlink" title="发现机制（Discovery）"></a>发现机制（Discovery）</h4><p>“发现”是微服务领域中经常讨论的主题：它是一个服务如何调用另一个服务的正确版本的问题。在Serverless世界中，几乎没有关于发现的讨论。最初这关心我，但现在我不那么担心了。Serverless的许多用法本质上是事件驱动的，并且在这里事件的消费者通常在某种程度上自我注册。对于面向API的FaaS用法，我们通常在API网关后面使用它们。在这种情况下，我们在API网关前使用DNS，并在网关后面进行自动部署/流量转移。我们甚至可以在API网关前面使用更多层（例如，使用AWS CloudFront）来支持跨区域弹性。</p><p>我将这个想法留在“limitation”中，因为我认为它还没有被证实，但最终它可能会很好。</p><h4 id="监控与可观察性（Monitoring-and-observability）"><a href="#监控与可观察性（Monitoring-and-observability）" class="headerlink" title="监控与可观察性（Monitoring and observability）"></a>监控与可观察性（Monitoring and observability）</h4><p>由于容器的短暂性，监控是FaaS的一个棘手问题。大多数云供应商都为您提供了一些监控支持，我们也从传统的监控供应商那里看到了很多第三方工作。尽管如此，无论他们和你最终能做什么，都取决于供应商为您提供的基本数据。在某些情况下这可能没问题，但对于AWS Lambda，至少它是非常基本的。我们在这方面真正需要的是开放API和第三方服务帮助更多的能力。</p><h4 id="API网关定义和野心勃勃的API网关（API-gateway-definition-and-over-ambitious-API-gateways）"><a href="#API网关定义和野心勃勃的API网关（API-gateway-definition-and-over-ambitious-API-gateways）" class="headerlink" title="API网关定义和野心勃勃的API网关（API gateway definition, and over-ambitious API gateways）"></a>API网关定义和野心勃勃的API网关（API gateway definition, and over-ambitious API gateways）</h4><p>ThoughtWorks，作为它的Technology Radar出版物的一部分，讨论过野心勃勃的API网关(<a href="https://www.thoughtworks.com/radar/platforms/overambitious-api-gateways" target="_blank" rel="noopener">over-ambitious API gateways</a>。）虽然链接通常指的是API网关（例如，对于那些前沿传统部署的微服务），但它绝对可以应用于将API网关用作FaaS函数的HTTP前端。问题在于，API网关提供了在自己的配置/定义域中执行许多特定于应用程序的逻辑的机会。这种逻辑通常很难测试、版本控制，有时还很难定义。通常，这样的逻辑与应用程序的其他部分一样保留在程序代码中要好得多。</p><p>不过这里肯定有紧张气氛。如果我们把一个API网关看作是一个BaaS，那么考虑它为我们提供的所有选项以节省我们的工作是不是很有价值？如果我们为每个请求使用API网关付费，而不是按CPU使用率付费，那么最大限度地使用API网关的功能是否更划算？</p><p>我的指导思想是明智地使用增强的API网关功能，并且只有当它真正在长期内节省您的effort时，包括它的部署、监控和测试方式。绝对不要使用不能在源代码控制的配置文件或部署脚本中表达的API网关功能。</p><p>关于定义的困难，Amazon的API网关用于强制您创建一些复杂的配置，以将HTTP请求和响应映射到lambda函数或从lambda函数映射出来。在<a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-api-as-simple-proxy-for-lambda.html" target="_blank" rel="noopener">Lambda proxy integration</a>中，大部分已经变得更简单了，但是您仍然需要了解一些偶尔棘手的细微差别。使用开源项目（如<a href="https://github.com/serverless/serverless" target="_blank" rel="noopener">Serverless Framework</a> 和 <a href="https://github.com/claudiajs/claudia" target="_blank" rel="noopener">Claudia.js</a>，或者Amazon的<a href="https://docs.aws.amazon.com/lambda/latest/dg/serverless_app.html" target="_blank" rel="noopener">Serverless Application Model</a>）可以使这些元素本身变得更容易。</p><h4 id="Deferring-of-operations"><a href="#Deferring-of-operations" class="headerlink" title="Deferring of operations"></a>Deferring of operations</h4><p>我之前提到过，Serverless不是“No Ops”——从监视、体系结构扩展、安全性和网络角度来看，还有很多工作要做。然而，当你开始的时候很容易忽略运维。这里的危险正在被一种虚假的安全感所麻痹。也许你的应用程序已经启动并运行了，但它却意外地出现在Hacker News上，突然间你有了10倍的流量需要处理，而且很糟糕！你不小心被DoS攻击了，却不知道怎么处理。</p><p>这里的解决办法是教学。使用Serverless系统的团队需要尽早考虑运维，供应商和社区将提供教学，帮助他们理解这意味着什么。诸如先发制人的负载测试和混沌工程（<a href="https://www.oreilly.com/webops-perf/free/chaos-engineering.csp" target="_blank" rel="noopener">chaos engineering</a>）等领域也将帮助团队自学。</p><h2 id="Serverless的未来（The-Future-of-Serverless）"><a href="#Serverless的未来（The-Future-of-Serverless）" class="headerlink" title="Serverless的未来（The Future of Serverless）"></a>Serverless的未来（The Future of Serverless）</h2><p>我们即将结束这个Serverless架构世界的旅程。最后，我将讨论一些我认为Serverless世界可能在未来几个月和几年内发展的领域。</p><h3 id="改善缺陷（Mitigating-the-drawbacks）"><a href="#改善缺陷（Mitigating-the-drawbacks）" class="headerlink" title="改善缺陷（Mitigating the drawbacks）"></a>改善缺陷（Mitigating the drawbacks）</h3><p>Serverless仍然是一个全新的世界。因此，前一节关于缺点的内容非常广泛，我甚至没有涵盖我所能拥有的一切。Serverless的最重要的发展将是减轻固有的缺点，消除或至少改善实现缺点。</p><h4 id="工具（Tooling）"><a href="#工具（Tooling）" class="headerlink" title="工具（Tooling）"></a>工具（Tooling）</h4><p>工具仍然是Serverless的一个问题，这是因为许多科技和技术都是新的。部署、应用程序绑定和配置在过去两年中都得到了改进，Serverless框架和Amazon的Serverless应用程序模型引领了这一进程。然而，“最初的10分钟”的体验并不像它可能的那样令人惊讶，尽管亚马逊和谷歌可以寻求微软和Auth0的更多灵感。</p><p>我很高兴看到云供应商积极解决的一个领域是更高级别的发布方法。在传统系统中，团队通常需要编写自己的流程来处理“traffic-shifting”的想法，如蓝绿部署和金丝雀发布(<a href="https://martinfowler.com/bliki/CanaryRelease.html" target="_blank" rel="noopener">canary releases</a>）。考虑到这一点，亚马逊支持Lambda和API Gateway的<a href="https://docs.aws.amazon.com/lambda/latest/dg/automating-updates-to-serverless-apps.html" target="_blank" rel="noopener">automatic traffic shifting</a>。这些概念在Serverless系统中甚至更有用，在这些系统中，如此多的单独部署的组件一次构成100个Lambda函数的系统原子发布是根本不可能的。事实上，<a href="https://twitter.com/natpryce" target="_blank" rel="noopener">Nat Pryce</a>向我描述了一个“mixing desk”方法的想法，我们可以逐步将一组组件引入和移除流量。</p><p>分布式监控可能是需要最显着改进的领域。我们已经看到亚马逊的<a href="https://aws.amazon.com/xray/" target="_blank" rel="noopener">X-Ray</a>和各种第三方产品的早期工作，但这绝对不是一个已经解决的问题。</p><p>远程调试也是我希望看到更广泛的东西。 Microsoft Azure Functions支持此功能，但Lambda不支持。能够断点远程运行函数是一项非常强大的功能。</p><p>最后，我希望看到“元操作”工具的改进——如何更有效地处理成百上千个FaaS函数、配置的服务等。例如，组织需要能够看到某些服务实例何时不再使用（出于安全目的，如果没有其他的话），它们需要更好地对以及跨服务成本的可视性（尤其是对于具有成本责任的自主团队），等等。</p><h4 id="状态管理（State-management）"><a href="#状态管理（State-management）" class="headerlink" title="状态管理（State management）"></a>状态管理（State management）</h4><p>对于大量应用程序而言，FaaS缺乏持久的服务器内状态是好的，但对于许多其他应用程序而言，这是一个交易破坏者 - 无论是大型缓存集合还是快速访问会话状态。</p><p>高吞吐量应用程序的一种解决方法可能是供应商在事件之间保持函数实例的活动时间更长，并让常规的进程内缓存方法完成它们的工作。对于每个事件，缓存都不会变热，因此这不会100％有效，但这与使用自动缩放的传统部署应用程序已经存在的问题相同。</p><p>更好的解决方案是对进程外数据进行非常低延迟的访问，例如能够以非常低的网络开销查询Redis数据库。鉴于亚马逊已经在他们的<a href="https://aws.amazon.com/elasticache/" target="_blank" rel="noopener">Elasticache</a>产品中提供托管的Redis解决方案，并且他们已经允许使用<a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html" target="_blank" rel="noopener">Placement Groups</a>相对共享位置的EC2（服务器）实例，这似乎没有太大的影响。</p><p>不过，更可能的是，考虑到外部化的状态约束，我认为我们将看到不同类型的混合（Serverless和非Serverless）应用程序体系结构。例如，对于低延迟应用程序，您可能会看到一种常规、长时间运行的服务器处理初始请求的方法，从本地和外部状态收集处理该请求所需的所有上下文，然后将完全上下文化的请求传递给不需要从外部查找数据的FaaS函数场。</p><h4 id="平台改进（Platform-improvements）"><a href="#平台改进（Platform-improvements）" class="headerlink" title="平台改进（Platform improvements）"></a>平台改进（Platform improvements）</h4><p>Serverless FaaS的某些缺点现在归结为平台的实现方式。执行持续时间，启动延迟和cross-function限制是三个显而易见的问题。这些可能会通过新的解决方案或可能的额外成本给出变通方法来解决。例如，我想通过允许客户请求FaaS函数的两个实例始终以低延迟可用，并且客户为此可用性付费，可以减轻启动延迟。 Microsoft Azure Functions具有此功能的元素，包括<a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-overview" target="_blank" rel="noopener">Durable Functions</a>和<a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-scale" target="_blank" rel="noopener">App Service plan-hosted functions</a>。</p><p>当然，除了修正当前的缺陷之外，我们还会看到平台改进，这些也将是令人兴奋的。</p><h4 id="教育（Education）"><a href="#教育（Education）" class="headerlink" title="教育（Education）"></a>教育（Education）</h4><p>许多特定于供应商的Serverless固有缺陷正在通过教育得到缓解。使用此类平台的每个人都需要积极思考，让一个或多个应用程序供应商托管如此多的生态系统意味着什么。我们需要考虑这样的问题：“如果一个供应商不可用，我们是否要考虑来自不同供应商的并行解决方案？”和”在部分中断的情况下，应用程序如何正常降级？“</p><p>另一个教育领域是技术运维。许多团队现在拥有的系统管理员数量比以前少，而Serverless将加速这一变化。但是系统管理员所做的不仅仅是配置Unix盒子和Chef脚本 - 他们通常是支持，网络，安全等一线的人。</p><p>在一个Serverless的世界里，真正的DevOps文化变得更加重要，因为其他非系统管理活动仍然需要完成，而且通常是开发人员现在负责这些活动。这些活动可能不会自然而然地出现在许多开发人员和技术领导面前，因此教育和与运维人员的密切合作至关重要。</p><h4 id="提高供应商的透明度和更清晰的期望（Increased-transparency-and-clearer-expectations-from-vendors）"><a href="#提高供应商的透明度和更清晰的期望（Increased-transparency-and-clearer-expectations-from-vendors）" class="headerlink" title="提高供应商的透明度和更清晰的期望（Increased transparency and clearer expectations from vendors）"></a>提高供应商的透明度和更清晰的期望（Increased transparency and clearer expectations from vendors）</h4><p>最后，关于这个主题的改善：供应商必须更加清楚我们对其平台的期望，因为我们依赖它们来获得更多的托管功能。虽然迁移平台很难，但并非不可能，而且不值得信任的供应商会看到他们的客户将业务转移到其他地方。</p><h3 id="模式的出现（The-emergence-of-patterns）"><a href="#模式的出现（The-emergence-of-patterns）" class="headerlink" title="模式的出现（The emergence of patterns）"></a>模式的出现（The emergence of patterns）</h3><p>我们对如何以及何时使用Serverless架构的理解仍处于起步阶段。现在，团队正在Serverless平台上抛出各种想法并看到了什么。谢天谢地！我们开始看到推荐实践的模式发生，这种知识只会增长。</p><p>我们看到的一些模式是应用程序架构。例如，FaaS功能在变得笨拙之前有多大？假设我们可以原子地部署一组FaaS函数，那么创建此类分组的好方法是什么？他们是否密切关注我们当前如何将逻辑集成到微服务中，或者架构上的差异是否会将我们推向不同的方向？</p><p>Serverless应用程序架构中一个特别有趣的讨论领域是它如何与事件思维交互。 AWS Lambda产品负责人Ajay Nair在2017年对此进行了<a href="https://serverless.com/blog/ajay-nair-good-citizen-event-driven-world-emit-2017/" target="_blank" rel="noopener">精彩的讨论</a>，这是CNCF Serverless Working Group的<a href="https://github.com/cloudevents/spec/blob/master/spec.md" target="_blank" rel="noopener">主要讨论领域之一</a>。</p><p>进一步扩展这一点，在FaaS和传统的“always on”持久服务器组件之间创建混合架构的好方法是什么？将BaaS引入现有生态系统的好方法是什么？而且，相反，完全或大部分BaaS系统需要开始采用或使用更多自定义服务器端代码的警告信号是什么？</p><p>我们还看到了更多的使用模式被讨论。FaaS的一个标准示例是媒体转换，例如，每当一个大型媒体文件存储到S3存储桶中时，就会自动运行一个进程，在另一个存储桶中创建较小的版本。然而，我们现在也看到了Serverless在数据处理管道、高度可扩展的Web API以及在操作中作为通用“粘合”代码的大量使用。其中一些模式可以作为通用组件实现，可以直接部署到组织中；<a href="https://blog.symphonia.io/examining-the-aws-serverless-application-repository-9ef316e2fd4" target="_blank" rel="noopener">我已经写过关于Amazon的Serverless应用程序存储库的文章 </a>，它有一个早期的形式。</p><p>最后，随着工具的改进，我们开始看到推荐的操作模式。我们如何在逻辑上聚合FaaS，BaaS和传统服务器的混合架构的日志记录？我们如何最有效地调试FaaS功能？这些问题的许多答案 - 以及新兴模式 - 来自云供应商本身，我希望这一领域的活动能够增长。</p><h3 id="全球性的的分布式架构（Globally-distributed-architectures）"><a href="#全球性的的分布式架构（Globally-distributed-architectures）" class="headerlink" title="全球性的的分布式架构（Globally distributed architectures）"></a>全球性的的分布式架构（Globally distributed architectures）</h3><p>在我前面给出的宠物店示例中，我们看到单个宠物店服务器被分解为几个服务器端组件和一些逻辑，这些逻辑一直向上移动到客户端，但从根本上讲，这仍然是一个架构，重点是客户端或已知位置的远程服务。</p><p>在Serverless的世界里，我们现在看到的是更加模糊的责任分配。一个例子是亚马逊的lambda@edge产品：一种在亚马逊的CloudFront内容交付网络中运行lambda函数的方法。对于<a href="https://aws.amazon.com/lambda/edge/" target="_blank" rel="noopener">Lambda@Edge</a>，lambda函数现在是全局分布的——工程师的单个上载活动意味着该函数将部署到<a href="https://aws.amazon.com/cloudfront/details/" target="_blank" rel="noopener">全球100多个数据中心</a>。这不是我们习惯的一种设计，它带有许多约束和功能。</p><p>此外，lambda函数可以在设备上运行，机器学习模型可以在移动客户端上运行，在您了解它之前，“客户机端”和“服务器端”的分支似乎不再有意义。事实上，我们现在看到的是组件的局部性，从人类用户那里扩散开来。Serverless将变为无区域的。</p><h3 id="不仅仅是FaaSification（Beyond-“FaaSification”）"><a href="#不仅仅是FaaSification（Beyond-“FaaSification”）" class="headerlink" title="不仅仅是FaaSification（Beyond “FaaSification”）"></a>不仅仅是FaaSification（Beyond “FaaSification”）</h3><p>到目前为止，我所看到的faas的大多数用法主要是利用现有的代码和设计思想，并将它们“简化”：将它们转换为一组无状态函数。这是很强大的，但是我希望我们会看到更多的抽象，可能还有语言，使用FaaS作为底层实现，让开发人员在不考虑将其应用程序作为一组离散函数的情况下获得FaaS的好处。</p><p>例如，我不知道Google是否为其<a href="https://cloud.google.com/dataflow/" target="_blank" rel="noopener">Dataflow</a>产品使用FaaS实现，但我可以想象有人创建了一个类似的产品或开源项目，并使用FaaS作为实现。这里的比较类似于<a href="http://spark.apache.org/" target="_blank" rel="noopener">Apache Spark</a>。 Spark是一种用于大规模数据处理的工具，它提供了非常高级的抽象，可以使用<a href="https://aws.amazon.com/elasticmapreduce/details/spark/" target="_blank" rel="noopener">Amazon EMR and Hadoop</a>作为其底层平台。</p><h3 id="测试（Testing）-1"><a href="#测试（Testing）-1" class="headerlink" title="测试（Testing）"></a>测试（Testing）</h3><p>我认为在Serverless系统的集成和验收测试方面还有很多工作要做，但是很多工作与以传统方式开发的“云原生”微服务系统相同。</p><p>这里的一个激进想法是接受诸如<a href="https://youtu.be/L-WOJmCcA9g" target="_blank" rel="noopener">testing in production</a>和<a href="https://nl.devoteam.com/en/blog-post/monitoring-driven-development-making-money/" target="_blank" rel="noopener">monitoring-driven development</a>之类的想法;一旦代码通过了基本的单元测试验证，就可以部署到流量子集并查看它与之前版本的比较情况。这可以与我前面提到的traffic-shiting工具相结合。这并不适用于所有情况，但对于许多团队来说，它可能是一个令人惊讶的有效工具。</p><h3 id="便携式的实现（Portable-implementations）"><a href="#便携式的实现（Portable-implementations）" class="headerlink" title="便携式的实现（Portable implementations）"></a>便携式的实现（Portable implementations）</h3><p>团队可以通过几种方式使用Serverless，同时减少与特定云供应商的联系。</p><h4 id="夸供应商实现的抽象（Abstractions-over-vendor-implementations）"><a href="#夸供应商实现的抽象（Abstractions-over-vendor-implementations）" class="headerlink" title="夸供应商实现的抽象（Abstractions over vendor implementations）"></a>夸供应商实现的抽象（Abstractions over vendor implementations）</h4><p><a href="http://serverless.com/" target="_blank" rel="noopener">Serverless Framework</a>主要用于简化Serverless应用程序的操作任务，但也提供了关于部署此类应用程序的位置和方式的中立性。例如，根据每个平台的操作功能，即使在AWS API Gateway + Lambda和Auth0 webtask之间轻松切换也很容易。</p><p>这方面的一个棘手问题是对抽象的FaaS编码接口进行建模而没有一些标准化的想法，但这恰恰是CNCF Serverless Working Group在<a href="https://github.com/cloudevents/spec/blob/master/spec.md" target="_blank" rel="noopener">CloudEvents</a>上的工作。</p><p>一旦复杂的操作让人头皮发麻（once complexities of operations rear their ugly heads），那么为多个云平台提供部署抽象是否还有意义。比如：获取一个云的安全权限往往和其他云是不同的。</p><h4 id="可部署的实现（Deployable-implementations）"><a href="#可部署的实现（Deployable-implementations）" class="headerlink" title="可部署的实现（Deployable implementations）"></a>可部署的实现（Deployable implementations）</h4><p>建议我们在不使用第三方提供商的情况下使用Serverless技术可能听起来很奇怪，但请考虑以下想法：</p><ul><li>也许我们是一个大型技术组织，我们希望开始为所有移动应用程序开发团队提供类似Firebase的数据库体验，但我们希望使用现有的数据库架构作为后端。</li><li>我之前谈过“Serverful”FaaS平台 - 能够在我们的一些项目中使用FaaS风格的架构，但提交合规，法律等原因来在我们的非云环境（on premise）运行我们的应用程序。</li></ul><p>在这两种情况下，使用Serverless而不使用来自供应商托管的方法仍然有许多好处。这里有一个先例，将平台视为服务（paas）。最初流行的PaaS都是基于云的（如Heroku），但是，很快，人们就看到了在自己的系统上运行PaaS环境的好处——所谓的“私有”PaaS（如本文前面提到的Cloud Foundry）。</p><p>我可以想象，就像私有PaaS实现一样，我们会看到BaaS和FaaS概念的开源和商业实现变得流行，特别是与Kubernetes等容器平台集成的那些。</p><h3 id="Community（社区）"><a href="#Community（社区）" class="headerlink" title="Community（社区）"></a>Community（社区）</h3><p>已经有一个规模很大的Serverless社区，其中包括多个会议，许多城市的聚会以及各种在线群组。我预计这种情况会持续增长，可能与Docker和Spring等社区同样如此。</p><h2 id="Conclusion（结论）"><a href="#Conclusion（结论）" class="headerlink" title="Conclusion（结论）"></a>Conclusion（结论）</h2><p>尽管名称令人困惑，但Serverless是一种架构风格，我们依赖于运行我们自己的服务器端系统作为我们应用程序的一部分，其程度比平时要小。我们通过两种技术实现这一目标：BaaS，我们将第三方远程应用程序服务直接集成到我们应用程序的前端，以及FaaS，它将服务器端代码从长时间运行的组件移动到短暂的函数实例。</p><p>Serverless不是对于每个问题都是正确的方法，所以要警惕那些说它将取代所有现有架构的人。如果您现在投入Serverless系统，请特别注意，尤其是在FaaS领域。虽然有强大伸缩功能并且节省了发部分的部署effort，但是调试和监控任然存在挑战。</p><p>然而，这些财富不应该太快地被抛弃，因为Serverless架构有很多积极的方面，包括降低运维和开发成本、更容易的运维管理和减少环境影响。但我认为最重要的好处是减少了创建新应用程序组件的反馈循环。我非常喜欢“精益求精”方法，这主要是因为我认为面对终端用户，我们应该尽快掌握技术以获得早期反馈很有价值，而Serverless的上市时间缩短正好符合这一理念。</p><p>Serverless服务，以及我们对如何使用它们的理解，（2018年5月）其仍处于“略显尴尬的青少年时期”。未来几年，该领域将取得许多进展，看看Serverless如何融入我们的架构工具包将是非常有趣的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文整理自Mike Roberts的文章，原文链接：&lt;a href=&quot;https://martinfowler.com/articles/serverless.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:/
      
    
    </summary>
    
      <category term="serverless" scheme="https://kylin1994.github.io/categories/serverless/"/>
    
    
      <category term="serverless" scheme="https://kylin1994.github.io/tags/serverless/"/>
    
      <category term="cloud native" scheme="https://kylin1994.github.io/tags/cloud-native/"/>
    
      <category term="faas" scheme="https://kylin1994.github.io/tags/faas/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构测试策略</title>
    <link href="https://kylin1994.github.io/2019/04/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5/"/>
    <id>https://kylin1994.github.io/2019/04/19/微服务架构测试策略/</id>
    <published>2019-04-19T10:02:29.961Z</published>
    <updated>2019-06-03T13:56:02.711Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理翻译自Toby Clemson的《Testing Strategies in a Microservice Architecture》文章，英文原文出处：<a href="https://martinfowler.com/articles/microservice-testing/" target="_blank" rel="noopener">https://martinfowler.com/articles/microservice-testing/</a></p></blockquote><p>在过去几年中，基于服务的架构已经转向更小、更集中的“微型”服务。这种方法有许多好处，例如能够独立部署、扩展和维护每个组件，并在多个团队之间并行化开发。但是，一旦引入了这些额外的网络分区，就需要重新考虑应用于巨石应用程序的测试策略。</p><p>在这里，我们将讨论一些方法——如何管理多个独立部署组件的额外测试的复杂性，以及如何让多个团队各自担任不同服务的监护人，以便如何进行测试和保持应用程序的正确。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>什么是微服务？</li><li>剖析：微服务内部结构</li><li>架构：服务编排<h3 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h3></li><li>单元：mockist vs. classic</li><li>集成：数据存储（datastore）和外部服（external service）</li><li>组件：in-process or out-of-process</li><li>契约：保证夸边界的一致性</li><li>端到端：技巧和窍门<h3 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h3></li><li>选项：微服务测试的好处</li><li>测试金字塔：需要多少测试？</li><li>总结</li></ul><h2 id="微服务架构使用一组相互协作的服务来构架软件"><a href="#微服务架构使用一组相互协作的服务来构架软件" class="headerlink" title="微服务架构使用一组相互协作的服务来构架软件"></a>微服务架构使用一组相互协作的服务来构架软件</h2><p>微服务架构是在架构层面应用单一责任原则的自然结果。与传统的单体架构相比，这带来了许多好处，例如独立部署性、语言、平台和不同组件的技术独立性，不同的可扩展性轴和增强的架构灵活性。</p><p><strong>微服务在规模方面，没有严格的规定</strong>。通常，微服务是数百行的数量级，但根据它们所包含的职责，可以是数十或数千行。一个好的，但非确切（non-specific）的经验法则是——<em>as small as possible but as big as necessary</em>，以便表示他们拥有的领域概念（Domain Concept）。 <a href="http://bovon.org/2013/07/09/how-big-should-a-micro-service-be/" target="_blank" rel="noopener">“How big should a micro-service be?”</a>中表述了更多细节。</p><p><strong>微服务通常使用基于HTTP协议的REST风格API进行集成</strong>。通过这种方式，业务域概念被建模为资源，一个服务管理一个或多个这样的资源。在最成熟的RESTful系统中，使用超媒体（hypermedia）控件链接资源，使得每个资源的位置对于服务的消费者是可见的。有关详细信息，请参阅<a href="https://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank" rel="noopener">Richardson Maturity Model</a>。</p><p>有时使用其他可用的集成机制，例如轻量级消息传递协议，发布/订阅模型或其他传输协议，例如Protobuf或Thrift。</p><p>每个微服务可以提供（或不提供）某种形式的用户界面。</p><h2 id="微服务通常可以分成类似的模块"><a href="#微服务通常可以分成类似的模块" class="headerlink" title="微服务通常可以分成类似的模块"></a>微服务通常可以分成类似的模块</h2><p> 通常微服务的内部结构由如下图所示的结构组成。</p><p>所采用的任何测试策略都应<strong>旨在为每层和服务层之间提供覆盖</strong>，同时保持轻量级。</p><p><img width="200" src="http://ww1.sinaimg.cn/large/006tNc79ly1g3oazwtuojj30uw0m277h.jpg"></p><ul><li>资源（Resources）：资源充当服务暴露的应用程序协议和表示领域的对象的消息之间的映射器。通常，它们很薄，负责检查请求的健全性，并根据业务处理的结果提供协议特定的响应。<span style="color:red">（个人理解：可以将其理解为Controller，对外暴露endpoint，将相应通讯协议的请求映射到相应的领域模型的服务。同时可以进行请求参数校验和权限校验等操作）</span></li><li>领域（Domain）：几乎所有服务逻辑都驻留在表示业务领域的领域模型（Domain）中。在这些对象中，服务（Service）跨多个领域活动进行协调，而Repository则作用于领域实体的集合，并且通常是可以持久化的。</li><li>外部（External）：如果一个服务具有另一个服务作为协作者，则需要一些逻辑来与外部服务通信。网关（Gateways）封装了使用远程服务传递的消息，从领域对象编组请求和响应。它可能会使用了解底层协议的客户端来处理请求和响应。</li><li>持久层（Persistence）：微服务还需要能够在请求之间持久化领域对象。通常，这是使用对象关系映射（ORM）或更轻量级的数据映射器（Data mapper）实现的，具体取决于持久化的复杂性。通常，Repository使用一组专门的对象对领域模型进行持久化。</li></ul><h2 id="微服务之间通过网络通信并且使用外部数据库"><a href="#微服务之间通过网络通信并且使用外部数据库" class="headerlink" title="微服务之间通过网络通信并且使用外部数据库"></a>微服务之间通过网络通信并且使用外部数据库</h2><p><img width="200" src="http://ww2.sinaimg.cn/large/006tNc79ly1g3oaz8l7hrj30rs0pmjvk.jpg"></p><p>微服务通过在每个相关模块之间传递消息来处理请求以形成响应。特定请求可能需要与Service/Gateway/Repository进行交互，因此模块之间是松耦合的。</p><p>自动化测试应尽可能以最细的粒度为每次通信提供覆盖。因此，每个测试都提供了一个专注的且快速的反馈周期。</p><hr><p><img height="200" src="http://ww4.sinaimg.cn/large/006tNc79ly1g3oazc7t22j30sa0q0ae2.jpg"></p><p>资源接收请求，并且一旦经过验证，就会调用Domain以开始处理请求。</p><p><img height="200" src="http://ww1.sinaimg.cn/large/006tNc79ly1g3oazd4ohpj30s80q4n1c.jpg"></p><p>如果必须协调许多模块以完成业务事务，则资源委托给服务。<br>否则，它直接与相关模块通信。</p><p><img height="200" src="http://ww3.sinaimg.cn/large/006tNc79ly1g3oaz7ytg3j30s60pmn18.jpg"></p><p>与外部服务的连接需要特别注意，因为它们跨越网络边界。系统应该能够适应远程组件的中断。网关包含处理此类错误情况的逻辑。<br>一般的，与外部服务的通信比进程内通讯更加粗粒度，为了降低API的复杂性和延迟。</p><p><img height="200" src="http://ww1.sinaimg.cn/large/006tNc79ly1g3oaz59ecqj30rs0pc42n.jpg"></p><p>同样，与外部数据存储的通信也有不同的设计考虑因素。服务通常更多得和数据存储交互而不是外部服务，数据存储位于网络边界外，从而导致延迟和中断风险。</p><p><img height="200" src="http://ww3.sinaimg.cn/large/006tNc79ly1g3oaztn247j30ro0p80wu.jpg"></p><p>网络分区的存在会影响所使用的测试风格。这些模块的测试可能会有更长的执行时间，并且可能由于团队无法控制的原因而失败。 </p><h2 id="多个微服务一起构成一个系统，提供有价值的业务功能"><a href="#多个微服务一起构成一个系统，提供有价值的业务功能" class="headerlink" title="多个微服务一起构成一个系统，提供有价值的业务功能"></a>多个微服务一起构成一个系统，提供有价值的业务功能</h2><p><img height="200" src="http://ww3.sinaimg.cn/large/006tNc79ly1g3oaze7f00j30oi0og419.jpg"></p><p>通常，团队将充当一个或多个微服务的监护人。这些服务交换消息以处理更大的业务请求。在交互格式方面，JSON目前最受欢迎，XML是最常见的替代方案。</p><p>在某些情况下，异步发布 - 订阅通信机制比同步点对点机制更适合用例。作为在微服务之间实现pub-sub的轻量级方法，Atom syndication格式正变得越来越流行。</p><p>由于业务请求跨越由网络分区分隔的多个组件，因此考虑系统中可能的故障模式非常重要。尽管这些组件可能会宕机，但是可以使用诸如超时（Timeout），断路器（circuit breaker）和舱壁（bulkheads）等技术帮助维持整个系统的正常运行。</p><p><img height="200" src="http://ww2.sinaimg.cn/large/006tNc79ly1g3oaz9f2naj30w00o2n0w.jpg"></p><p>在较大的系统中，通常有多个团队负责不同的有界上下文（bounded contexts）。</p><p>外部服务的测试问题可能与团队控制下的服务不同，因为对外部团队服务的接口和可用性不能保障。</p><h2 id="单元测试（UNIT-TESTING）"><a href="#单元测试（UNIT-TESTING）" class="headerlink" title="单元测试（UNIT TESTING）"></a>单元测试（UNIT TESTING）</h2><blockquote><p><strong><em>A unit test exercises the smallest piece of testable software in the application to determine whether it behaves as expected.</em></strong></p><p><strong><em>单元测试在应用程序中运行最小的可测试软件（单元），以确定其是否按预期运行。</em></strong></p></blockquote><p>被测单元的大小没有严格定义，但是单元测试通常是在类级别或一小组相关类下编写的。被测单元越小，使用单元测试就越容易表达行为，因为单元的分支复杂性较低。</p><p>通常，编写单元测试的难度可以突出显示何时应将模块分解为独立的更连贯的部分并单独测试。因此，<strong>作为一种有用的测试策略，单元测试也是一种功能强大的设计工具</strong>，尤其是与测试驱动开发（TDD）相结合时。</p><p>通过单元测试，您可以看到基于被测单元是否与其协作者隔离的重要区别。</p><p><a href="https://leanpub.com/wewut" target="_blank" rel="noopener">Sociable unit testing</a>的重点是通过观察模块状态的变化来测试模块的行为。这将被测单元视为完全通过其接口测试的黑盒子。</p><p><a href="https://leanpub.com/wewut" target="_blank" rel="noopener">Solitary unit testing</a>着眼于对象及其依赖关系之间的交互和协作，这些关系由<a href="https://martinfowler.com/bliki/TestDouble.html" target="_blank" rel="noopener">test doubles</a>替换。</p><p>这些单元测试风格并不冲突，并且经常在相同的代码库中使用以解决不同的测试问题。</p><h3 id="两个风格的单元测试都在微服务中扮演者重要角色"><a href="#两个风格的单元测试都在微服务中扮演者重要角色" class="headerlink" title="两个风格的单元测试都在微服务中扮演者重要角色"></a>两个风格的单元测试都在微服务中扮演者重要角色</h3><p><img height="200" src="http://ww4.sinaimg.cn/large/006tNc79ly1g3oaz2cot2j30uo0p0q6q.jpg"></p><p>服务通常是被管道和协作代码（plumbing and coordination code）环绕的丰富领域。</p><blockquote><p>Plumbing code: <a href="https://www.oreilly.com/library/view/reactive-programming-with/9781787124233/b8e36bf6-bc79-49b9-a841-d3d7a488cbd1.xhtml" target="_blank" rel="noopener">https://www.oreilly.com/library/view/reactive-programming-with/9781787124233/b8e36bf6-bc79-49b9-a841-d3d7a488cbd1.xhtml</a></p></blockquote><hr><p><img height="200" src="http://ww1.sinaimg.cn/large/006tNc79ly1g3oazbnmazj30jk0okgop.jpg"></p><p>领域逻辑（Domain Logic）通常表现为复杂的计算和状态转换的集合。由于这些类型的逻辑基于状态，因此尝试隔离单元几乎没有价值。这意味着，应该尽可能地将真实的领域对象用于被测单元的所有协作者。<span style="color:red">（个人理解：领域对象封装了领域具有的属性和功能，如果业务功能复杂，领域对象可以被多个服务协调调用以完成复杂业务，也有可能直接被Repository利用，完成简单的CRUD操作。所以将领域对象单独隔离出来测试没有意义，应将其与业务结合，测试对应逻辑单元。）</span></p><p><img height="200" src="http://ww4.sinaimg.cn/large/006tNc79ly1g3oazxawbaj30jo0oqq61.jpg"></p><p>使用plumbing code，很难将被测单元与外部模块隔离开来并对状态变化进行测试。因此，使用Test Doubles（Test Doubles指stub,mock等含义）更有效。</p><p>此级别的单元测试的目的是验证用于生成请求的任意逻辑或映射来自外部依赖的响应，而不是以集成方式验证通信。因此，为协作者使用Test Doubles提供了一种以可靠和可重复的方式控制请求/响应的方法。<span style="color:red">（个人理解：这里的单元测试是使用Test double来模拟外部服务和数据库服务，验证当前服务发送请求和接收响应的部分（gateway和repository），而不是测试通信，测试通信的应该使用集成测试）。</span></p><p>此级别的单元测试提供比集成测试更快的反馈，并且可以通过在特殊情况下将Test Doubles响应作为外部依赖来强制错误条件。<span style="color:red">（个人理解：这里说反馈更快是因为外部服务和数据库的请求和响应都是使用test double模拟出来的，而不是真正的网络连接，所以更快。并且，使用test double可以覆盖各种情况）</span>。</p><p><img height="200" src="http://ww4.sinaimg.cn/large/006tNc79ly1g3oaz74iooj30js0omad8.jpg"></p><p>协作逻辑（Coordination logic）更关心模块之间传递的消息，而不是那些模块中的任何复杂逻辑。使用Test Doubles允许验证传递的消息的细节并且响应桩，所以测试中可以在模块之间指定通信流。<span style="color:red">（个人理解：这里的逻辑协作指内部service之间的协作以及resource和service之间的协作，这里不关心service内部的复杂逻辑，而关心协作者之间的交互，使用test double可以准确模拟出消息传递的细节。）</span></p><p>如果说一段协作逻辑需要太多数量的Test Double，这通常是一个好的指标，暗示一些逻辑需要被抽取出来单独测试。</p><hr><p>随着服务规模的减小，管道和协调逻辑（plumbing and coordination logic）与复杂领域逻辑（domain logic）的比率也会增加。类似地，一些服务将包含完全的管道和协调逻辑，例如适配器到不同的技术或作为其他服务的聚合器。<span style="color:red">（个人理解：当领域逻辑很简单时，比如创建一个用户，用户服务直接调用Repository提供的API，就完成了存储操作，这里几乎没有任何逻辑，只有一些管道代码（数据库连接和事务等）和第三方API的调用）</span></p><p>在这种情况下，综合性的单元测试可能无法获得回报。其他级别的测试（如<a href="https://martinfowler.com/articles/microservice-testing/#testing-component-introduction" target="_blank" rel="noopener">component testing</a>）可以提供更多价值。<span style="color:red">（个人理解：当领域逻辑很简单时，单元测试能覆盖的场景就比较少了，此时各种组件之间的协作和第三方服务占了大部分比例，所以使用component testing和integration testing更合适。）</span></p><p>单元测试和测试的目的一般是限制被测单元的行为。不幸的副作用是，有时，测试也会限制实现（tests also constrain the implementation）。这通常表现为过度依赖基于mock的方法。</p><p>重要的是不断质疑单元测试提供的价值与维护成本或限制你的实现的数量。通过这样做，可以使测试套件保持小型化，集中化和高价值。</p><h3 id="单独的单元测试不能保证系统的行为"><a href="#单独的单元测试不能保证系统的行为" class="headerlink" title="单独的单元测试不能保证系统的行为"></a>单独的单元测试不能保证系统的行为</h3><p><img height="200" src="http://ww2.sinaimg.cn/large/006tNc79ly1g3oazz7xzkj30qy0pe42t.jpg"></p><p>到目前为止，我们已经隔离了系统的每个核心模块。但是，当这些模块一起工作以形成完整的服务或它们与远程依赖交互时，这些模块不会被覆盖。<span style="color:red">（个人理解：单元测试还是主要聚焦于模块的内部，当模块之间一起提供完成服务的时候，单元测试智能保障每个模块内部没有问题，但是模块之间的协作交互还是需要更加粗粒度的测试）。</span><br>要验证每个模块是否与其协作者正确交互，需要进行更粗粒度的测试。      </p><h2 id="集成测试（INTEGRATION-TESTING）"><a href="#集成测试（INTEGRATION-TESTING）" class="headerlink" title="集成测试（INTEGRATION TESTING）"></a>集成测试（INTEGRATION TESTING）</h2><blockquote><p><em>An integration test verifies the communication paths and interactions between components to detect interface defects.</em></p><p>集成测试验证组件之间的通信路径和交互，以检测接口缺陷。</p><p><a href="http://www.techopedia.com/definition/7751/integration-testing" target="_blank" rel="noopener">http://www.techopedia.com/definition/7751/integration-testing</a></p><p><a href="http://en.wikipedia.org/wiki/Software_testing#Testing_levels" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Software_testing#Testing_levels</a></p><p><a href="http://programmers.stackexchange.com/questions/48237/what-is-an-integration-test-exactly" target="_blank" rel="noopener">http://programmers.stackexchange.com/questions/48237/what-is-an-integration-test-exactly</a></p></blockquote><p>集成测试将模块收集在一起并作为子系统进行测试，以验证它们是否按预期协作以实现更大的行为。</p><p><img height="75" src="http://ww1.sinaimg.cn/large/006tNc79ly1g3oaz0akioj306s02yjre.jpg"></p><p>集成测试将模块收集在一起并作为子系统进行测试，以验证它们是否按预期协作以实现更大的行为。他们通过子系统运行通信路径，以检查每个模块关于如何与其对等方交互的任何不正确的假设。</p><p>这与单元测试形成对比，在单元测试中，即使使用真正的协作者，目标也是仅仅测试被测单元的行为，而不是整个子系统。</p><p><img height="75px" src="http://ww2.sinaimg.cn/large/006tNc79ly1g3oaz48o06j306u03474b.jpg"></p><p>虽然可以以任何粒度编写集成组件或模块的测试，但在微服务架构中，它们通常用于验证集成代码层与它们集成的外部组件之间的交互。</p><h3 id="和外部数据存储或者外部组件集成"><a href="#和外部数据存储或者外部组件集成" class="headerlink" title="和外部数据存储或者外部组件集成"></a>和外部数据存储或者外部组件集成</h3><p><img width="200" src="http://ww4.sinaimg.cn/large/006tNc79ly1g3oazxzdi6j30rq0piq7n.jpg"></p><p>在编写与外部组件交互的模块的自动化测试时，目标是验证模块是否可以充分通信而不是验证外部组件的测试。因此，此类测试应旨在通过集成各个模块来覆盖成功和错误的路径。</p><hr><h4 id="Gateway-Integration-Tests"><a href="#Gateway-Integration-Tests" class="headerlink" title="Gateway Integration Tests"></a>Gateway Integration Tests</h4><p><img width="200" src="http://ww4.sinaimg.cn/large/006tNc79ly1g3oayz4io3j30rw0pm431.jpg"></p><p>网关集成测试（Gateway Integration Tests）可以排除任何尽可能细粒度的协议级的错误，比如确实HTTP headers，不正确的SSL处理或者请求体和响应体匹配错误。</p><p>还应测试任何特殊情况的错误处理，以确保所使用的服务和协议客户端在特殊情况下按预期响应。</p><p>有时很难触发异常行为，例如超时或外部组件响应缓慢。在这种情况下，使用外部组件的桩（Stub）版本来触发相应的预配置的异常。</p><p>在测试外部组件时，状态管理可能很困难，因为测试将依赖于某些可用的数据。缓解此问题的一种方法是达成一组固定的、具有代表性的但无害的数据，这些数据保证在每个环境中都可用。</p><h4 id="Persistence-Integration-Tests"><a href="#Persistence-Integration-Tests" class="headerlink" title="Persistence Integration Tests"></a>Persistence Integration Tests</h4><p><img width="200" src="http://ww1.sinaimg.cn/large/006tNc79ly1g3oaz4polxj30ru0pidkc.jpg"></p><p>持久化集成测试（Persistence Integration Tests）可确保代码中假定的模式与数据存储中可用的模式匹配。<span style="color:red">???</span></p><p>在使用ORM的情况下，这些测试还可以确保工具中配置的任何映射都与返回的结果集兼容。</p><p>在重构或扩展集成模块中包含的逻辑时，此风格的测试可提供快速反馈。然而，它们也有很多失败原因，如果集成模块中的逻辑退化或外部组件变得不可用或违反契约。</p><p>为了缓解这个问题，只需编写一些集成测试，以便在需要时提供快速反馈，并通过单元测试和契约测试提供额外的覆盖，以全面验证集成边界（integration boundary）的每一侧。在CI的构建流水线中分离集成测试也是有意义的，这样外部中断不会阻碍开发。<span style="color:red">（个人理解：在开发过程中，将集成测试从CI的构建流水线中剥离是有意义的，因为外部的变化可能导致集成测试失败，而阻碍开发，所以可以将其从构建流水线剥离。）</span></p><h3 id="没有更粗粒度的测试，我们就不能保证满足业务需求"><a href="#没有更粗粒度的测试，我们就不能保证满足业务需求" class="headerlink" title="没有更粗粒度的测试，我们就不能保证满足业务需求"></a>没有更粗粒度的测试，我们就不能保证满足业务需求</h3><p>通过单元测试和集成测试，我们可以确信构成微服务的各个模块中包含的逻辑的正确性。</p><p>但是，如果没有更粗粒度的测试套件，我们无法确定微服务作为一个整体协同工作以满足业务需求。</p><p>虽然这可以通过完全集成的端到端测试来实现，但是通过测试与其外部依赖性隔离的微服务，可以获得更准确的测试反馈和更小的测试运行时间。</p><h2 id="Component-Testing"><a href="#Component-Testing" class="headerlink" title="Component Testing"></a>Component Testing</h2><blockquote><p><em>A component test limits the scope of the exercised software to a portion of the system under test, manipulating the system through internal code interfaces and using test doubles to isolate the code under test from other components.</em></p><p>组件测试将运行的软件的范围限制在被测系统的一部分，通过内部代码接口对系统进行操作，并使用test doubles将被测代码与其他组件隔离。</p></blockquote><p><img height="75" src="http://ww3.sinaimg.cn/large/006tNc79ly1g3oaz0qqhuj307802y3ym.jpg"></p><p>组件是较大系统中任何封装良好，连贯且可独立替换的部分。</p><p>单独测试这些组件提供了许多益处。通过将范围限制为单个组件，可以彻底验收测试由该组件封装的行为，同时保持与<a href="https://martinfowler.com/bliki/BroadStackTest.html" target="_blank" rel="noopener">broad stack </a>测试等效并且执行更快的测试。使用Test doubles将组件与其对等组件隔离可以避免它们可能具有的任何复杂行为。它还有助于为组件提供受控的测试环境，以可重复的方式触发任何适用的错误情况。</p><p><img height="75" src="http://ww3.sinaimg.cn/large/006tNc79ly1g3oazyhe0nj3072036wek.jpg"></p><p>在微服务架构中，组件本身就是服务。通过以这种粒度编写测试，API的契约是从消费者的角度通过测试来驱动的。通过使用test doubles替换外部协作者并使用内部API端点来探测或配置服务，可以实现服务的隔离。</p><p>这种测试的实现方式有多种：</p><ol><li>测试是在进程内部执行还是通过网络执行？</li><li>test double需要存在于服务内部，还是外部，通过网络访问？</li><li>应该用真实的数据存储还是通过内存的方式代替？</li></ol><h3 id="在线组件测试允许全面测试，同时尽量减少移动部件"><a href="#在线组件测试允许全面测试，同时尽量减少移动部件" class="headerlink" title="在线组件测试允许全面测试，同时尽量减少移动部件"></a>在线组件测试允许全面测试，同时尽量减少移动部件</h3><p><img width="300" src="http://ww1.sinaimg.cn/large/006tNc79ly1g3oazuys6vj316g0q8q98.jpg"></p><p>通过使用in-memory的test double和数据存储可以实例化in-memory的完整微服务，可以编写网络无关的组件测试。</p><p>这可以缩短测试执行时间并最大限度地减少移动部件的数量，从而降低构建复杂性。</p><p>但是，这也意味着为了测试目的，必须更改被测试的项目（Artifact），以允许它以“测试”模式启动。依赖注入框架可以通过基于启动时提供的配置以不同方式连接应用程序来帮助实现此目的。<span style="color:red">(个人理解：像是Spring中的profile，可以根据不同profile导入不同的配置，比如：dev/prod/test)</span></p><p><img width="300" src="http://ww2.sinaimg.cn/large/006tNc79ly1g3oaz1xsvaj31eq0qgqcl.jpg"></p><p>测试通过内部接口与微服务进行通信，允许分发请求并接收响应。虽然存在许多预先构建的库，例如用于基于JVM微服务的<a href="https://github.com/aharin/inproctester" target="_blank" rel="noopener">inproctester</a>和用于基于.NET微服务的<a href="https://github.com/jennifersmith/plasma" target="_blank" rel="noopener">plasma</a>，但通常使用自定义<a href="http://en.wikipedia.org/wiki/Shim_(computing)" target="_blank" rel="noopener">shim</a>来实现这一点。</p><p>通过这种方式，进程内组件测试可以尽可能接近地针对服务执行真实HTTP请求，而不会产生真实网络交互的额外开销。</p><p><img width="300" src="http://ww4.sinaimg.cn/large/006tNc79ly1g3oayy9a5dj31f40qadpj.jpg"></p><p>为了将微服务与外部服务隔离，可以将网关配置为使用Test Double而不是真正的协议级客户端。使用<a href="https://martinfowler.com/articles/microservice-testing/#testing-component-internal-resources" target="_blank" rel="noopener">internal resources</a>，可以对这些Test Double进行编程，以便在匹配某些请求时返回预定义的响应。</p><p>这些Test Double也可用于模拟组件中的不愉快路径，例如当外部协作者处于脱机状态或响应缓慢或响应错误时。这允许以受控且可重复的方式测试错误情况。</p><p><img width="300" src="http://ww3.sinaimg.cn/large/006tNc79ly1g3oazwcitlj31f00q412p.jpg"></p><p>使用 <a href="https://martinfowler.com/bliki/InMemoryTestDatabase.html" target="_blank" rel="noopener">in-memory implementation</a>替换外部数据存储可以显着提高测试性能。虽然这不包括测试边界的实际数据存储区，但任何持久化<a href="https://martinfowler.com/articles/microservice-testing/#testing-integration-introduction" target="_blank" rel="noopener">integration tests</a>都将提供足够的覆盖范围。</p><p>在某些情况下，使用的持久化机制非常简单，可以使用轻量级的自定义实现。或者，某些数据存储（如<a href="http://cassandra.apache.org/)和[elasticsearch](http://www.elasticsearch.org/" target="_blank" rel="noopener">cassandra</a>）提供嵌入式实现。还有一些工具可以在内存中模拟外部数据存储，例如<a href="http://www.h2database.com/html/main.html" target="_blank" rel="noopener">H2 database engine</a>。</p><p>虽然可以在编写进程内（in-process）验收测试（acceptance tests）时直接配置Double Test和设置数据，通过特权内部资源路由所有请求，允许将服务更多得进行黑盒测试。</p><h3 id="内部资源不仅仅用于测试"><a href="#内部资源不仅仅用于测试" class="headerlink" title="内部资源不仅仅用于测试"></a>内部资源不仅仅用于测试</h3><p><img width="300" src="http://ww1.sinaimg.cn/large/006tNc79ly1g3oaz2tpvfj311k0a876j.jpg"></p><p>虽然看起来很奇怪，<strong>但是除了测试之外，在监控，维护和调试之外的许多情况下，将内部控件暴露为资源也是有用的</strong>。 RESTful API的统一性（uniformity）意味着已经存在许多用于与这些资源交互的工具，这有助于降低整体操作复杂性。</p><p>通常公开的内部资源类型包括日志（log），功能标志（feature flags），数据库命令（database command）和系统指标（system metrics）。许多微服务还包括健康检查（health check）资源，这些资源提供有关服务健康状况及其依赖关系的信息，关键事务的时间安排和配置参数的详细信息。简单的ping资源也可用于辅助负载平衡。</p><p>由于这些资源在其资源控制或暴露的信息方面具有更高的特权，因此它们通常需要身份验证或网络级别的锁定。通过命名空间使用URL命名约定形成内部控件的API部分，或者通过在不同的网络端口上公开这些资源，可以在防火墙级别限制访问。</p><h3 id="进程外组件测试执行完全部署的工件，把打桩的复杂性放到测试工具中"><a href="#进程外组件测试执行完全部署的工件，把打桩的复杂性放到测试工具中" class="headerlink" title="进程外组件测试执行完全部署的工件，把打桩的复杂性放到测试工具中"></a>进程外组件测试执行完全部署的工件，把打桩的复杂性放到测试工具中</h3><p><img width="300" src="http://ww2.sinaimg.cn/large/006tNc79ly1g3oaz6fahhj31ei0tunan.jpg"></p><p>针对作为单独进程部署的微服务执行组件测试允许执行更多层和集成点。由于所有交互都使用真实的网络调用，因此部署项目可以保持不变，而不需要任何特定于测试的逻辑。</p><p>通过这种方法，复杂性被推入测试工具中，该测试工具负责启动和停止外部桩并协调网络端口和配置。</p><p>由于网络交互和使用真实数据存储，测试执行时间可能会增加。但是，如果微服务具有复杂的集成，持久化或启动逻辑，那么进程外（out-of-process）方法可能更合适。</p><p><img width="300" src="http://ww3.sinaimg.cn/large/006tNc79ly1g3oazbanxqj31eq0pyqb9.jpg"></p><p>由于微服务正在监听不同进程中的端口，因此除了验证行为外，进程外组件测试还可验证微服务是否具有正确的网络配置和是否能够处理网络请求。</p><p><img width="300" src="http://ww3.sinaimg.cn/large/006tNc79ly1g3oazaj9f2j31em0pkwmr.jpg"></p><p>类似地，客户端和持久化模块，同时在单独的进程中与外部依赖性集成。</p><p><img width="300" src="http://ww4.sinaimg.cn/large/006tNc79ly1g3oaz3n6aqj31em0pmgvr.jpg"></p><p>外部服务stub有多种不同的类型：一些通过API动态编程，一些提前准备的数据，一些使用记录重放机制（record-replay mechanism）捕获对真实外部服务的请求和响应。</p><p>比如<a href="https://github.com/dreamhead/moco)，[stubby4j](https://github.com/azagniotov/stubby4j" target="_blank" rel="noopener">moco</a>和<a href="https://github.com/bbyars/mountebank" target="_blank" rel="noopener">mountebank</a>，它们支持基于动态和静态的stub，以及支持记录重放机制的stub——<a href="https://github.com/vcr/vcr" target="_blank" rel="noopener">vcr</a>。</p><p>如果外部服务有许多协作者，则可能需要构建特定于该服务的自定义stub，以便服务消费者不必自己管理stubs。</p><h3 id="测试策略的组合→高测试覆盖率"><a href="#测试策略的组合→高测试覆盖率" class="headerlink" title="测试策略的组合→高测试覆盖率"></a>测试策略的组合→高测试覆盖率</h3><p><img width="300" src="http://ww3.sinaimg.cn/large/006tNc79ly1g3oayx8chcj310o0pqwlk.jpg"></p><p>通过结合单元、集成和组件测试，我们能够实现微服务模块的高覆盖率，并且可以确保微服务正确地实现所需的业务逻辑。</p><p>然而，除了最简单的用例之外，除非许多微服务协同工作以实现更大的业务流程，否则业务价值就无法实现。在此测试方案中，仍然没有测试可确保外部依赖性满足他们期望的契约，或者我们的微服务集合正确协作以提供端到端业务流。</p><p>外部依赖关系的契约测试和整个系统的更粗粒度的端到端测试有助于提供此功能。</p><h2 id="契约测试（Contract-Testing）"><a href="#契约测试（Contract-Testing）" class="headerlink" title="契约测试（Contract Testing）"></a>契约测试（Contract Testing）</h2><blockquote><p><em>An integration contract test is a test at the boundary of an external service verifying that it meets the contract expected by a consuming service.</em></p><p>集成契约测试是在外部服务边界进行的测试，用于验证其是否满足消费服务所期望的契约。</p><p><a href="https://martinfowler.com/bliki/ContractTest.html" target="_blank" rel="noopener">https://martinfowler.com/bliki/ContractTest.html</a></p><p><a href="https://martinfowler.com/articles/consumerDrivenContracts.html" target="_blank" rel="noopener">https://martinfowler.com/articles/consumerDrivenContracts.html</a></p></blockquote><p>每当某个消费者耦合到组件的接口以利用其行为时，就会在它们之间形成契约。该契约包括期望输入和输出数据结构，副作用和性能以及并发等特性。</p><p>组件的每个消费者根据其需求形成不同的契约。如果组件随时间而变化，则重要的是每个消费者的契约继续得到满足。</p><p>集成契约测试提供了一种机制来明确验证组件是否符合契约的。</p><p>当涉及的组件是微服务时，接口是每个服务公开的公共API。每个消费服务（consuming service）的维护者编写一个独立的测试套件，仅验证正在使用的生产服务（producing service）的那些方面。</p><p>这些测试不是组件测试。它们不会深度测试服务的行为，但服务调用的输入和输出包含必需的属性，并且响应延迟和吞吐量在可接受的限制范围内。</p><p>理想情况下，每个消费团队编写的契约测试套件都在生产服务的构建流水线中打包和运行。通过这种方式，生产服务的维护者知道他们的变化对他们的消费者的影响。</p><h3 id="所有消费者合同测试的总和定义整体服务契约"><a href="#所有消费者合同测试的总和定义整体服务契约" class="headerlink" title="所有消费者合同测试的总和定义整体服务契约"></a>所有消费者合同测试的总和定义整体服务契约</h3><p><img width="150" src="http://ww4.sinaimg.cn/large/006tNc79ly1g3oaywuu5fj30oa0p677b.jpg"></p><p>虽然契约测试为外部服务的消费者提供了信心，但对于这些服务的维护者来说，它们更有价值。通过从服务的所有消费者接收契约测试套件，可以在消费者不受影响的情况下对该服务进行安全更改。</p><p><img width="150" src="http://ww2.sinaimg.cn/large/006tNc79ly1g3oazrl5nuj30og0p40vp.jpg"></p><p>考虑使用三个字段（<code>id</code>，<code>name</code>，<code>age</code>）公开资源的服务。该服务已被三个不同的消费者采用，每个消费者都耦合到资源的不同部分。</p><p><img width="150" src="http://ww1.sinaimg.cn/large/006tNc79ly1g3oaz7kdwwj30p40p677b.jpg"></p><p>消费者A仅与<code>id</code>和<code>name</code>字段耦合。因此，相应的契约测试套件判断资源响应包含的那些字段。它没有对<code>age</code>字段做出任何断言。</p><p><img width="150" src="http://ww3.sinaimg.cn/large/006tNc79ly1g3oayxkev2j30ok0pa77b.jpg"></p><p>消费者B耦合到<code>id</code>和<code>age</code>字段，因此契约测试断言它们存在但不对<code>name</code>字段进行断言。</p><p><img width="150" src="http://ww2.sinaimg.cn/large/006tNc79ly1g3oayzxo8ij30oq0p277c.jpg"></p><p>消费者C需要所有三个字段，并且有一个契约测试套件，断言它们都存在。</p><hr><p>如果一个消费者使用了这个API，但是需要另外两个字段（<code>last name</code>, <code>first name</code>），维护人员可能会弃用<code>name</code>字段，然后加入一个复合对象包含（<code>last name</code>, <code>first name</code>）。</p><p>为了了解删除旧的字段需要做些什么，可以尝试将其从响应中删除，然后执行契约测试，看哪些契约测试失败了。比如契约A和C依赖于<code>name</code>字段，所以A和C需要知道<code>name</code>字段被弃用了。只有当A和C升级为新的字段（<code>last name</code>, <code>first name</code>）时，旧的字段才能被删除。</p><p>为了提高效率，生产者和消费者在序列化和反序列化消息时应遵循<a href="https://en.wikipedia.org/wiki/Robustness_principle" target="_blank" rel="noopener">Postel’s Law</a>，忽略任何对它们不重要的字段。</p><p>这种方法是<a href="https://martinfowler.com/bliki/ParallelChange.html" target="_blank" rel="noopener">Parallel Change</a>的一个例子，其中API可以在一段时间内改变而不破坏任何消费者的契约。</p><p>在定义新服务时，契约测试套件也很有价值。消费者可以通过构建一套表达他们所需服务的测试来推动API设计。</p><p>这些<a href="https://martinfowler.com/articles/consumerDrivenContracts.html" target="_blank" rel="noopener">consumer driven contracts</a>和团队之间针对于如何构建服务形成了一个讨论点，这些服务被自动化测试来表明这些API已经准备就绪。</p><p>有许多工具可以帮助编写契约测试，例如<a href="https://github.com/realestate-com-au/pact" target="_blank" rel="noopener">Pact</a>，<a href="https://github.com/thoughtworks/pacto" target="_blank" rel="noopener">Pacto</a>和<a href="https://github.com/gga/janus" target="_blank" rel="noopener">Janus</a>。</p><h2 id="端到端的测试（End-to-end-Testing）"><a href="#端到端的测试（End-to-end-Testing）" class="headerlink" title="端到端的测试（End-to-end Testing）"></a>端到端的测试（End-to-end Testing）</h2><blockquote><p><em>An end-to-end test verifies that a system meets external requirements and achieves its goals, testing the entire system, from end to end.</em></p><p>端到端测试验证系统是否满足外部需求并实现其目标，从头到尾测试整个系统。</p><p><a href="http://c2.com/cgi/wiki?FunctionalTest" target="_blank" rel="noopener">http://c2.com/cgi/wiki?FunctionalTest</a></p><p><a href="https://martinfowler.com/bliki/BroadStackTest.html" target="_blank" rel="noopener">https://martinfowler.com/bliki/BroadStackTest.html</a></p></blockquote><p>与其他类型的测试相比，端到端测试的目的是验证整个系统是否满足业务目标，而不管使用什么样的组件体系结构。</p><p>为了实现这一点，系统被视为一个黑盒，测试尽可能多地使用完整部署的系统，通过GUI和服务API等公共接口进行操作。</p><p>由于端到端测试更面向业务（<a href="https://martinfowler.com/bliki/BusinessFacingTest.html" target="_blank" rel="noopener">business facing</a>），因此它们通常使用业务可读的<a href="https://martinfowler.com/bliki/DomainSpecificLanguage.html" target="_blank" rel="noopener">DSLs</a>，以领域的语言表达测试用例。</p><p>微服务架构包括了更多行为相同的可移动部件，端到端的测试弥补了服务之间的测试覆盖。这不但使我们对服务之间的消息传递更有信心，但是同时也需要保障额外的网络基础设施，比如防火墙，代理以及负载均衡是否正确。</p><h3 id="端到端测试的测试边界比其他类型的测试要大得多"><a href="#端到端测试的测试边界比其他类型的测试要大得多" class="headerlink" title="端到端测试的测试边界比其他类型的测试要大得多"></a>端到端测试的测试边界比其他类型的测试要大得多</h3><p><img width="150" src="http://ww3.sinaimg.cn/large/006tNc79ly1g3oazcqopmj30pg0oqwhl.jpg"></p><p>由于目标是测试完全集成的系统的行为，因此端到端测试以尽可能粗的粒度进行交互。</p><p>如果系统需要用户操作，则该交互可以通过由一个或多个微服务公开的GUI来实现。在这种情况下，<a href="http://docs.seleniumhq.org/projects/webdriver/" target="_blank" rel="noopener">Selenium WebDriver</a>等工具可以帮助驱动GUI以触发系统中的特定用例。</p><p>对于没有GUI的系统，端到端测试使用HTTP客户端通过其公共API直接操作微服务。</p><p>以这种方式，通过观察由测试边界形成的边界处的状态变化或事件来确定系统的正确性。</p><p><img width="150" src="http://ww3.sinaimg.cn/large/006tNc79ly1g3oaz9w09nj30w00osjvc.jpg"></p><p>虽然有些系统足够小，单个团队拥有所有复合组件的所有权，但在许多情况下，系统会逐渐依赖于一个或多个外部管理的微服务。</p><p>通常，这些外部服务包含在端到端测试边界内。但在极少数情况下，您可以选择排除它们。</p><p>如果外部服务由第三方管理，则可能无法以可重复且无副作用的方式编写端到端测试。同样，某些服务可能会遇到可靠性问题，导致端到端测试因团队无法控制而失败。</p><p>在这些情况下，模拟外部服务可能是有益的，会失去一些端到端的信心，但会在测试套件中获得稳定性。</p><h3 id="编写和维护端到端测试可能非常困难"><a href="#编写和维护端到端测试可能非常困难" class="headerlink" title="编写和维护端到端测试可能非常困难"></a>编写和维护端到端测试可能非常困难</h3><p>由于端到端测试比目前讨论的其他策略更多的移动部件，他们有更多理由失败。 端到端测试还可能必须考虑系统中的异步情况，无论是在GUI中还是由于服务之间的异步后端进程。 这些因素可能导致flakiness，测试运行时间过长以及测试套件的额外维护成本。</p><p>以下指南有助于管理端到端测试的额外复杂性：</p><ol><li>尽可能少地编写端到端测试</li></ol><p>鉴于通过较低级别的测试可以实现高级别的信任，端到端测试的作用是确保所有内容联系在一起，并且微服务之间没有高级别的分歧。</p><p>因此，在这个级别全面测试业务需求是浪费的，特别是考虑到时间和维护的端到端测试的成本。</p><p>一种适用于保持端到端测试套件小的策略是应用<strong>时间预算</strong>（<strong>time budget</strong>），团队乐于等待测试套件运行的时间。随着套件的增长，如果运行时间开始超过时间预算，则删除最不重要的测试以保持在指定的时间内。时间预算应为分钟而非小时。</p><ol><li>专注于角色模型和用户旅程（Focus on personas and user journeys）</li></ol><p>为确保端到端套件中的所有测试都很有价值，请将其建模为系统用户角色以及用户通过系统进行的旅程。这为用户最重视的系统部分提供了信心，并将其他任何内容的覆盖范围留给了其他类型的测试。</p><p>存在诸如<a href="http://getgauge.io/" target="_blank" rel="noopener">Gauge</a>和<a href="http://concordion.org/" target="_blank" rel="noopener">Concordion</a>之类的工具以帮助通过业务可读DSL表达旅程。</p><ol><li>Choose your ends wisely</li></ol><p>If a particular external service or GUI is a major cause of flakiness in the test suite, it can help to redefine the test boundary to exclude the component. In this case, total end-to-end coverage is traded in favour of reliability in the suite. This is acceptable as long as other forms of testing verify the flaky component using different means.</p><ol><li>Rely on infrastructure-as-code for repeatability</li></ol><p>雪花环境（<a href="https://martinfowler.com/bliki/SnowflakeServer.html" target="_blank" rel="noopener">Snowflake environments</a>）也可能成为非确定性的来源，特别是如果它们不仅仅用于端到端测试。</p><p>如果您已经采用infrastructure-as-code，这可以极大地帮助管理微服务架构的额外部署复杂性，则可以以可重现的方式动态构建环境。</p><p>通过为每个端到端测试套件执行构建一个新环境，可以提高可靠性，同时还可以作为部署逻辑的测试。</p><ol><li>使测试与数据无关（Make tests data-independent）</li></ol><p>端到端测试的常见困难来源是数据管理。依赖于预先存在的数据，随着数据在环境中的变化和累积，可能会出现故障。我将这些成为false-failures，因为失败（failure）并不表示软件出现故障（fault）。</p><hr><p>由于以这种方式编写测试所固有的困难，一些团队选择完全避免端到端测试，而是直接针对生产环境进行全面的生产监控和测试。</p><p><strong>Synthetic transactions</strong>——伪造用户对生产系统进行实际交易 - 可以补充典型的监控技术，以提供对生产健康的更多洞察。此外，当关键业务指标超出可接受的标准时发出警报可以帮助快速识别生产问题。</p><h2 id="微服务架构为测试的位置和方式提供了更多选择。"><a href="#微服务架构为测试的位置和方式提供了更多选择。" class="headerlink" title="微服务架构为测试的位置和方式提供了更多选择。"></a>微服务架构为测试的位置和方式提供了更多选择。</h2><p>通过将系统分解为小型定义良好的服务，可以暴露先前隐藏的其他边界。这些边界在可以使用的测试类型和级别方面提供了机会和灵活性。</p><p>在某些情况下，微服务可能会封装具有复杂需求的主要业务流程。此过程的关键性可能需要对服务进行非常全面的测试，例如前面讨论的全部测试策略。在其他情况下，微服务可能是实验性的，从商业角度来看不太重要，或者寿命可能很短。所需的测试水平可能较低，因此只有几种策略才有意义。</p><p>虽然这种决策过程仍然可以在单体架构中进行，但添加清晰、明确定义的边界可以更容易地查看系统的组件并单独处理它们。</p><h2 id="测试金字塔有助于我们在不同的测试类型之间保持平衡"><a href="#测试金字塔有助于我们在不同的测试类型之间保持平衡" class="headerlink" title="测试金字塔有助于我们在不同的测试类型之间保持平衡"></a>测试金字塔有助于我们在不同的测试类型之间保持平衡</h2><p><img width="200" src="http://ww4.sinaimg.cn/large/006tNc79ly1g3oazdg8h2j30lc0eot9v.jpg"></p><p>通常，测试越粗糙，执行越脆弱，耗时，难以编写和维护。这种额外的开销源于这样的事实：这种测试自然涉及比更细粒度聚焦的更多移动部件。</p><p>测试金字塔的概念是一种简单的方法来考虑应该在每个粒度上编写的测试的相对数量。向上穿过金字塔的各个层次，测试的范围会增加，应该编写的测试的数量会减少。</p><p>在金字塔的顶部是探索性测试，以未被视为脚本测试一部分的方式手动探索系统。探索性测试允许团队了解系统，教育和改进他们的自动化测试。</p><p>通过遵循测试金字塔的指导原则，我们可以避免通过维护和执行成本高昂的大型测试套件降低测试的价值。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img height="350" src="http://ww3.sinaimg.cn/large/006tNc79ly1g3oazsk9u4j31eg0rigw7.jpg"></p><ul><li>单元测试：单元测试在应用程序中运行最小的可测试软件（单元），以确定其是否按预期运行。</li><li>集成测试：验证组件之间的通信路径和交互，以检测接口缺陷。</li><li>组件测试：将运行的软件的范围限制在被测系统的一部分，通过内部代码接口对系统进行操作，并使用test doubles将被测代码与其他组件隔离。</li><li>契约测试：验证外部服务在边界处的交互，判断它符合消费服务预期的契约。</li><li>端到端测试：验证系统是否满足外部要求并实现其目标，从头到尾测试整个系统。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文整理翻译自Toby Clemson的《Testing Strategies in a Microservice Architecture》文章，英文原文出处：&lt;a href=&quot;https://martinfowler.com/articles/
      
    
    </summary>
    
      <category term="microservice" scheme="https://kylin1994.github.io/categories/microservice/"/>
    
    
      <category term="microservice" scheme="https://kylin1994.github.io/tags/microservice/"/>
    
      <category term="test" scheme="https://kylin1994.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>翻译：Kubernetes: Lifecycle of a Pod</title>
    <link href="https://kylin1994.github.io/2018/08/29/%E7%BF%BB%E8%AF%91%EF%BC%9AKubernetes-Lifecycle-of-a-Pod/"/>
    <id>https://kylin1994.github.io/2018/08/29/翻译：Kubernetes-Lifecycle-of-a-Pod/</id>
    <published>2018-08-29T13:28:15.000Z</published>
    <updated>2019-06-05T05:55:35.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-Lifecycle-of-a-Pod"><a href="#Kubernetes-Lifecycle-of-a-Pod" class="headerlink" title="Kubernetes: Lifecycle of a Pod"></a>Kubernetes: Lifecycle of a Pod</h1><blockquote><p>本文翻译自：Kubernetes: Lifecycle of a Pod</p><p>原文出处：<a href="https://dzone.com/articles/kubernetes-lifecycle-of-a-pod" target="_blank" rel="noopener">https://dzone.com/articles/kubernetes-lifecycle-of-a-pod</a></p><p>参考：<a href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#hook-details" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#hook-details</a></p></blockquote><p>查看Kubernetes pod的生命周期可以帮助了解可以在流行的容器软件中调度的最小工作单元发生了什么。</p><p>在Kubernetes中，Pod是能被调度的最小工作单元。一个Pod封装了一个应用的容器，存贮资源，唯一的网络IP和管理容器运行的其他选项。理想情况下，Pod并不会被集群直接部署，而是用更高层次的抽象层。应用通常通过更高层的资源对象部署，比如：Deployments, Replication Sets, Daemon Sets, Stateful Sets或者Jobs。和Pod进行交互主要用来解决问题，因此深入Pod是很重要的。</p><h2 id="Pod的状态"><a href="#Pod的状态" class="headerlink" title="Pod的状态"></a>Pod的状态</h2><p>整个Pod的声明周期中，可以达到以下状态：</p><p>Pending：Pod被Kubernetes系统接收（accepted），但是没有其容器还没有被完全创建。</p><p>Running：Pod被调度到某一个Node上，<strong>所有的</strong>容器都被创建并且<strong>至少有一个</strong>容器是Running状态。</p><p>Succeeded：Pod中所有的容器都以状态0退出并且不会重启。</p><p>Failed：Pod中所有的容器都已经退出，但是至少有一个容器退出状态不为0。</p><p>CrashLoopBackoff：容器启动失败并且会被不断重试。</p><h2 id="容器的诞生"><a href="#容器的诞生" class="headerlink" title="容器的诞生"></a>容器的诞生</h2><p>现在我们来看看导致一个容器创建的所有事件。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/006tNbRwgy1fuqwbhu81lj30xg0mczmn.jpg" alt="1_WDJmiyarVfcsDp6X1-lLFQ"></p><ul><li>kubectl或者其他API客户端提交Pod spec到API server。</li><li>API server会将Pod对象写到etcd数据存储中。一旦写操作成功，一个ack将会被发送回API server和客户端。</li><li>现在API server反映了etcd的状态变化。</li><li>所有的Kubernetes组件通过watch API保持对API server相关变化的检测。</li><li>当前情况下，kube-scheduler（通过watcher）发现一个新的Pod通过API server被创建，但是还没有绑定到任何一个node。</li><li>Kube-scheduler会给当前新创建的Pod分配一个node，并跟新API server。</li><li>“Pod被分配到某个节点”这个变化将会被传递给etcd数据存储。API server也会在其Pod project上体现出节点分配。</li><li>每个节点上的Kubelet也会运行watcher，对API server持续监控。在目标node上，kubelet知道一个新的Pod已经分配。</li><li>Kubelet在node上通过调用Docker启动Pod，并且将跟新的容器状态发送回API server。</li><li>API server将Pod状态持久化到etcd中。h</li><li>一旦etcd发送成功写操作的ack到API server，API server 会回复Kubelet一个ack，表示事件已经被接收。</li></ul><h2 id="Pod生命周期中的活动"><a href="#Pod生命周期中的活动" class="headerlink" title="Pod生命周期中的活动"></a>Pod生命周期中的活动</h2><h3 id="初始容器"><a href="#初始容器" class="headerlink" title="初始容器"></a>初始容器</h3><p>初始容器是<strong>运行在主应用程序启动之前的</strong>容器。他们有两个重要的特征：</p><ul><li>总是运行至完成状态</li><li>每一个初始容器都必须在下一个启动之前完成</li></ul><p>初始容器能在主容器启动之前做一些必要的初始化操作。</p><p>比如：拷贝配置文件和修改配置。初始容器使用不同的Linux命名空间，所以他们有不同的文件系统视图，所以他们可以被允许访问可能不适合在主应用程序内共享的秘密。</p><h3 id="Lifecycle-Hooks"><a href="#Lifecycle-Hooks" class="headerlink" title="Lifecycle Hooks"></a>Lifecycle Hooks</h3><p>kubelet 可以运行被<a href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#hook-details" target="_blank" rel="noopener">Container Lifecycle Hooks</a>触发的代码。这允许用户在容器生命周期指定事件期间运行指定的代码。</p><p>存在两个被暴露出来的hook：</p><ul><li>PostStart：这种hook在容器后立即运行，但是没有办法保证在容器的ENTRYPOINT之后运行。</li><li>PreStop：这种hook在容器终止前被执行，是阻塞的，意味着必须在删除容器的调用之前完成hook的执行。</li></ul><p>上面提到的两种hook都不能带参数。</p><p>容器可以通过实现的和注册该hook的handler来访问hook。有两种类型的hook handler可以被容器应用：</p><ul><li>Exec：在Container的cgroups和名称空间内执行特定命令，例如<code>pre-stop.sh</code>，命令执行的资源消耗算在容器内。</li><li>HTTP：对容器上指定的endpoint执行HTTP请求。</li></ul><h3 id="容器探针"><a href="#容器探针" class="headerlink" title="容器探针"></a>容器探针</h3><p>除了Lifecycle hooks之外，在Pod生命周期中发生的另一个重要事情就是容器探针的执行。</p><p>容器探针是由容器上的kubelet执行的诊断。 kubelet可以在运行容器上运行两种探针：</p><ul><li>livenessProbe：指示容器是否正在运行。如果活动探测失败，则kubelet会杀死容器，并且容器会受到其重新启动策略的影响。</li><li>readnessProbe：指示容器是否已准备好为请求提供服务。如果此探测失败，则endpoint controller将从与Pod匹配的所有服务的端点列表中删除容器IP。</li></ul><p>有三种方式实现一个探针：</p><ul><li>ExecAction：在容器内部执行命令。如果命令返回0，则为诊断成功。</li><li>TCPSocketAction：对容器IP和指定端口执行TCP套接字检查。如果端口打开，则诊断被认为是成功的。</li><li>HTTPGetAction：使用指定的端口和路径对容器IP执行HTTP GET操作。如果响应的状态代码在200到400之间，则认为诊断成功。</li></ul><h2 id="容器的终止"><a href="#容器的终止" class="headerlink" title="容器的终止"></a>容器的终止</h2><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/006tNbRwgy1fuqwbilzmkj30sc0l9aca.jpg" alt="Termination"></p><ol><li>用户执行一个命令删除一个Pod</li><li>API服务器中的Pod对象将随着Pod被认为“死亡”（默认为30秒）的时间以及宽限期而更新。</li><li>下面的行为将会并行执行：<ul><li>在客户端命令中列出时，状态为“Terminating”。</li><li>当Kubelet看到因为设置了第二点中的时间而将Pod标记为终止时，它开始pod关闭过程。</li><li>端点控制器监视即将删除的pod，因此从该pod提供服务的所有端点中删除该pod。</li></ul></li><li>如果Pod已经定义了preStop hook，并且在Pod内被调用。如果preStop hook在Grace time超时后，任然为运行状态，然后用小的（2秒）扩展宽限期调用步骤2。</li><li>Kubelet向Docker发送TERM信号。</li><li>当Grace period超时，任何运行在Pod上的进程都会被SIGKILL杀死。</li><li>Kubelet将通过设置宽限期0（立即删除）完成删除API服务器上的Pod。 Pod从API中消失，不再从客户端可见。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章的想法来自Kubernetes创始人Joe Beda的精彩文章，他解释了Kubernetes架构的主要组成部分和watch概念，这对于理解APIServer如何工作和etcd功能以及Pod的诞生至关重要。</p><p>我们可以看到有多种方式来控制在POD的生命周期内发生的事件。初始容器可以帮助移除与容器引导相关的许多复杂性，从而帮助保持主容器内的逻辑简单。类似地，启动preStart lifecycle hook可以帮助运行容器启动后需要运行的任何代码（例如向监视系统或服务网格注册）。liveness probe和readness probe有助于在开始危害任何客户之前移除坏的Pod。优雅的shutdown可以作为一个pre-stop lifecycle hook运行，允许更优雅的退出。了解上述控制机制有助于更好地设计Pod和支持使用案例。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Kubernetes-Lifecycle-of-a-Pod&quot;&gt;&lt;a href=&quot;#Kubernetes-Lifecycle-of-a-Pod&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes: Lifecycle of a Pod&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="kubernetes" scheme="https://kylin1994.github.io/categories/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="https://kylin1994.github.io/tags/kubernetes/"/>
    
      <category term="pod" scheme="https://kylin1994.github.io/tags/pod/"/>
    
      <category term="lifecycle" scheme="https://kylin1994.github.io/tags/lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>使用JWT访问Kubernetes API-server REST API</title>
    <link href="https://kylin1994.github.io/2018/08/29/%E4%BD%BF%E7%94%A8JWT%E8%AE%BF%E9%97%AEKubernetes-API-server-REST-API/"/>
    <id>https://kylin1994.github.io/2018/08/29/使用JWT访问Kubernetes-API-server-REST-API/</id>
    <published>2018-08-29T06:04:45.000Z</published>
    <updated>2019-06-02T00:03:22.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用JWT访问Kubernetes-API-server-REST-API"><a href="#使用JWT访问Kubernetes-API-server-REST-API" class="headerlink" title="使用JWT访问Kubernetes API-server REST API"></a>使用JWT访问Kubernetes API-server REST API</h1><h1 id="生成Token"><a href="#生成Token" class="headerlink" title="生成Token"></a>生成Token</h1><p>首先在kubernetes集群的master节点上获取API-Server 的地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $(kubectl config view | grep server | cut -f 2- -d ":" | tr -d " ")</span><br></pre></td></tr></table></figure><p>在集群的master结点上，运行以下指令，获取具有所有权限的token值：</p><p>创建admin-token.yaml，并输入以下内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">rbac.authorization.kubernetes.io/autoupdate:</span> <span class="string">"true"</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">  apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="attr">  - kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">    namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="string">kubernetes.io/cluster-service:</span> <span class="string">"true"</span></span><br><span class="line">    <span class="string">addonmanager.kubernetes.io/mode:</span> <span class="string">Reconcile</span></span><br></pre></td></tr></table></figure><p>执行命令：<code>kubectl create -f admin-token.yaml</code></p><p>执行命令：<code>kubectl get secret -n kube-system|grep admin</code></p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/006tNbRwgy1fuqiyf4jn4j30xg01kdgb.jpg" alt="1535511448134"></p><p>执行命令：<code>kubectl describe secret admin-token-sdv88 -n kube-system</code></p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/006tNbRwgy1fuqiym4h2fj31840ekqad.jpg" alt="查看生成的Token"></p><p>可以使用上面生成的JWT来访问API-Server。</p><p>通过Postman访问</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/006tNbRwgy1fuqiygaj29j31de12qai1.jpg" alt="使用Postman访问"></p><p>使用RestTemplate访问，配置RestTemplate需要跳过Client对API-Server的认证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testK8sApi</span><span class="params">()</span> <span class="keyword">throws</span> KeyStoreException, NoSuchAlgorithmException, KeyManagementException </span>&#123;</span><br><span class="line">        HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        headers.set(<span class="string">"Authorization"</span>, <span class="string">"Bearer "</span> + <span class="string">"eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi10b2tlbi1zZHY4OCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJhZG1pbiIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjlhMzM5NzI1LWE0M2YtMTFlOC1iZGJmLTAwNTA1NmE0MDg0MCIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlLXN5c3RlbTphZG1pbiJ9.FxoNIIrlVvn0EV5HqTwQh--QO-gL-MTEz6BXvY9hsXEUSe-HuWgwb4cokPGAxEavPLafrbEK8YiL66fT3C-xH0T43my4HN_njJEWMwmBBiFU-G5B5QwMbP7WTSXTtrpkeyQM0G8wysWFhsUsper5Ke-xX8I0eY3CBOxeMchsO7QAd-py13h_ufXVKoPZvz5wAjF_5sLMRiJfpG5FKjOTe9OgCLNCr7yCrHMvcr-TvMVcfja3Eyv3lOJIjes2jpCOwXH8xRJ-dRS0CpPfiXgYDDqgwK3SjTQ7fTOIQgZNBsmRNYmcCPWKQvuQMOlVGwf1ozlaOZmyGggvirSWKJUOlA"</span>);</span><br><span class="line"></span><br><span class="line">        TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -&gt; <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        SSLContext sslContext = org.apache.http.ssl.SSLContexts.custom()</span><br><span class="line">                .loadTrustMaterial(<span class="keyword">null</span>, acceptingTrustStrategy)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        SSLConnectionSocketFactory csf = <span class="keyword">new</span> SSLConnectionSocketFactory(sslContext);</span><br><span class="line">        CloseableHttpClient httpClient = HttpClients.custom()</span><br><span class="line">                .setSSLSocketFactory(csf)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        HttpComponentsClientHttpRequestFactory requestFactory =</span><br><span class="line">                <span class="keyword">new</span> HttpComponentsClientHttpRequestFactory();</span><br><span class="line">        requestFactory.setHttpClient(httpClient);</span><br><span class="line"></span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate(requestFactory);</span><br><span class="line">        HttpEntity&lt;String&gt; entity = <span class="keyword">new</span> HttpEntity&lt;String&gt;(headers);</span><br><span class="line"></span><br><span class="line">        ResponseEntity&lt;String&gt; responseEntity = restTemplate.exchange(<span class="string">"https://10.141.212.142:6443"</span>, HttpMethod.GET, entity, String.class);</span><br><span class="line"></span><br><span class="line">        JsonParser parser = <span class="keyword">new</span> JsonParser();</span><br><span class="line">        JsonObject json = parser.parse(responseEntity.getBody()).getAsJsonObject();</span><br><span class="line"></span><br><span class="line">        Gson gson = <span class="keyword">new</span> GsonBuilder().setPrettyPrinting().create();</span><br><span class="line">        String prettyJson = gson.toJson(json);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prettyJson;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用JWT访问Kubernetes-API-server-REST-API&quot;&gt;&lt;a href=&quot;#使用JWT访问Kubernetes-API-server-REST-API&quot; class=&quot;headerlink&quot; title=&quot;使用JWT访问Kubernetes 
      
    
    </summary>
    
      <category term="kubernetes" scheme="https://kylin1994.github.io/categories/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="https://kylin1994.github.io/tags/kubernetes/"/>
    
      <category term="JWT" scheme="https://kylin1994.github.io/tags/JWT/"/>
    
      <category term="API-Server" scheme="https://kylin1994.github.io/tags/API-Server/"/>
    
      <category term="Authentication" scheme="https://kylin1994.github.io/tags/Authentication/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7搭建kubernetes集群</title>
    <link href="https://kylin1994.github.io/2018/08/16/CentOS-7%E6%90%AD%E5%BB%BAkubernetes%E9%9B%86%E7%BE%A4/"/>
    <id>https://kylin1994.github.io/2018/08/16/CentOS-7搭建kubernetes集群/</id>
    <published>2018-08-16T03:06:55.000Z</published>
    <updated>2019-06-02T00:02:18.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOS-7-搭建Kubernetes集群"><a href="#CentOS-7-搭建Kubernetes集群" class="headerlink" title="CentOS 7 搭建Kubernetes集群"></a>CentOS 7 搭建Kubernetes集群</h1><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p><code>yum install -y docker</code></p><p><code>systemctl enable docker &amp;&amp; systemctl start docker</code></p><h2 id="设置master-node和work-node的时间"><a href="#设置master-node和work-node的时间" class="headerlink" title="设置master node和work node的时间"></a>设置master node和work node的时间</h2><p>为了最后join成功，需要集群每个node之间时间保持一致，在每一台服务器上执行以下命令，指定时区。最后可以通过<code>date</code>命令查看设置是否生效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum install -y chrony</span><br><span class="line">systemctl start chronyd</span><br><span class="line">systemctl enable chronyd</span><br><span class="line">timedatectl set-timezone Asia/Shanghai</span><br><span class="line">timedatectl set-ntp yes</span><br><span class="line"></span><br><span class="line">date</span><br></pre></td></tr></table></figure><h2 id="安装kubeadm"><a href="#安装kubeadm" class="headerlink" title="安装kubeadm"></a>安装kubeadm</h2><p>参考自：<a href="https://kubernetes.io/docs/setup/independent/install-kubeadm/" target="_blank" rel="noopener">kubeadm官方安装教程</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">exclude=kube*</span><br><span class="line">EOF</span><br><span class="line">setenforce 0</span><br><span class="line">yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure><h2 id="初始化Master节点"><a href="#初始化Master节点" class="headerlink" title="初始化Master节点"></a>初始化Master节点</h2><p>安装好kubeadm之后，在master node上执行<code>kubeadm init</code>命令：</p><p><code>kubeadm init --pod-network-cidr=10.244.0.0/16</code></p><p>可能出现<code>kubeadm init</code>报以下错：</p><p><code>running with swap on is not supported. Please disable swap</code></p><p>执行命令disable swap：<code>sudo swapoff -a</code></p><p><strong>Note</strong></p><ol><li>每次重新init之前需要执行命令：<code>kubeadm reset</code>，清空之前的残留。</li><li>若出现<code>&quot;systemd&quot; is different from docker cgroup driver: &quot;cgroupfs&quot;。</code>错误，原因是docker和kubelet的cgroup不一致导致的（改docker或者kubelet的cgroup）。<a href="https://kubernetes.io/docs/setup/independent/install-kubeadm/" target="_blank" rel="noopener">解决方案(install docker部分)</a></li><li>master节点重启后必须执行：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">sudo swapoff -a</span><br></pre></td></tr></table></figure><p><code>kubeadm init</code>命令执行成功之后，会出现以下提示消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">You can now join any number of machines by running the following on each node</span><br><span class="line">as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join --token &lt;token&gt; &lt;master-ip&gt;:&lt;master-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</span><br></pre></td></tr></table></figure><p>上述命令用于后面work节点的join操作。</p><p>如果不是Root用户，可以执行以下命令让你的<code>kubectl</code>生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>如果你是Root用户，直接执行以下命令，使<code>kubectl</code>生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure><p>为了不让终端断开之后每次都执行一次，可以在/etc/profile文件末尾加上<code>export KUBECONFIG=&quot;/etc/kubernetes/admin.conf&quot;</code>，然后<code>source /etc/profile</code>。</p><h2 id="安装Pod-网络插件"><a href="#安装Pod-网络插件" class="headerlink" title="安装Pod 网络插件"></a>安装Pod 网络插件</h2><p>必须安装Pod网络插件才能使Pod之间能正常通信，这里我们使用Flannel插件。</p><p>为了让Flannel正常工作，必须注意：</p><ol><li>设置<code>kubeadm init</code>的运行参数为<code>--pod-network-cidr=10.244.0.0/16</code>（前面已经设置）。</li><li>执行<code>sysctl net.bridge.bridge-nf-call-iptables=1</code></li></ol><p>安装Flannel：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.10.0/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><p>一旦Pod network安装成功，可以使用<code>kubectl get pods —all-namespaces</code>来查看CoreDNS pod状态是否为running，如果是，则表示可以join其他work nodes。如果不是running状态，参考<a href="https://kubernetes.io/docs/setup/independent/troubleshooting-kubeadm/" target="_blank" rel="noopener">troubleshooting</a>。</p><h2 id="Join-work-node"><a href="#Join-work-node" class="headerlink" title="Join work node"></a>Join work node</h2><p>为了更加直观的反应节点名称，可以修改每个node的/etc/hosts文件，比如Master node的ip为10.141.211.163，设置host name为CENTOS-MASTER：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.141.211.163 CENTOS-MASTER</span><br><span class="line">10.141.211.164 CENTOS-MINION-1</span><br><span class="line">10.141.211.177 CENTOS-MINION-2</span><br></pre></td></tr></table></figure><p>然后reboot所有的节点，master节点重启后必须执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">sudo swapoff -a</span><br></pre></td></tr></table></figure><p>使用<code>kubeadm join</code>work node加入集群：</p><ol><li>使用ssh连接远端服务器</li><li>切换root用户(sudo su -)</li><li>执行<code>kubeadm join</code>命令，实例：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join --token &lt;token&gt; &lt;master-ip&gt;:&lt;master-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</span><br></pre></td></tr></table></figure><p>第3步中的命令可以在<code>kubeadm init</code>后，在控制台输出中找到。</p><p><strong>Note</strong></p><ol><li>如果没有token可以在master节点使用<code>kubeadm token list</code>获取。</li><li>token默认的有效期为24小时，如果过期，可以在master节点使用<code>kubeadm token create</code>生成新的token。</li><li>如果没有<code>—discovery-token-ca-cert-hash</code>可以使用<code>openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | \   openssl dgst -sha256 -hex | sed &#39;s/^.* //&#39;</code>获取。</li></ol><p>至此，集群搭建就成功了，可以在Master节点查看<code>kubectl get nodes</code>。</p><h2 id="拆除集群"><a href="#拆除集群" class="headerlink" title="拆除集群"></a>拆除集群</h2><p>要撤消kubeadm所执行的操作，您应首先排空节点，并确保节点在关闭之前为空。在Master节点执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl drain &lt;node name&gt; --delete-local-data --force --ignore-daemonsets</span><br><span class="line">kubectl delete node &lt;node name&gt;</span><br></pre></td></tr></table></figure><p>在对应的work node上执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure><h2 id="集群维护"><a href="#集群维护" class="headerlink" title="集群维护"></a><a href="https://kubernetes.io/docs/tasks/administer-cluster/kubeadm" target="_blank" rel="noopener">集群维护</a></h2><h2 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a><a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/" target="_blank" rel="noopener">其他插件</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CentOS-7-搭建Kubernetes集群&quot;&gt;&lt;a href=&quot;#CentOS-7-搭建Kubernetes集群&quot; class=&quot;headerlink&quot; title=&quot;CentOS 7 搭建Kubernetes集群&quot;&gt;&lt;/a&gt;CentOS 7 搭建Kubern
      
    
    </summary>
    
      <category term="kubernetes" scheme="https://kylin1994.github.io/categories/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="https://kylin1994.github.io/tags/kubernetes/"/>
    
      <category term="cluster" scheme="https://kylin1994.github.io/tags/cluster/"/>
    
      <category term="flannel" scheme="https://kylin1994.github.io/tags/flannel/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes service配置详解</title>
    <link href="https://kylin1994.github.io/2018/08/13/kubernetes-service%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>https://kylin1994.github.io/2018/08/13/kubernetes-service配置详解/</id>
    <published>2018-08-13T02:35:06.000Z</published>
    <updated>2019-06-02T00:03:09.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kubernetes-service配置详解"><a href="#kubernetes-service配置详解" class="headerlink" title="kubernetes service配置详解"></a>kubernetes service配置详解</h1><p>以下配置信心归纳自《Kubernetes权威指南》第二版。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>             <span class="comment"># string     Required    版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>              <span class="comment"># string     Required    资源类型</span></span><br><span class="line"><span class="attr">metadata:</span>                  <span class="comment"># Object     Required    元数据</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">string</span>             <span class="comment"># string     Required    Service名称</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">string</span>        <span class="comment"># string     Required    命名空间，默认default</span></span><br><span class="line"><span class="attr">  labels:</span>                  <span class="comment"># list       Required    自定义标签属性列表</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">  annotations:</span>             <span class="comment"># list       Required    自定义注解属性列表</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">spec:</span>                      <span class="comment"># Object     Required    详细描述</span></span><br><span class="line"><span class="attr">  selector:</span> <span class="string">[]</span>             <span class="comment"># list       Required    Label Selector配置，将选择具有指定Label标签的Pod作为管理范围</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">string</span>             <span class="comment"># string     Required    Service的类型，指定Service的访问方式，默认为ClusterIP</span></span><br><span class="line">                           <span class="comment"># ClusterIP：虚拟的服务IP地址，改地址用于Kubernetes集群内部的Pod访问，在Node上kube-proxy通过设置iptables规则进行转发</span></span><br><span class="line">                           <span class="comment"># NodePort:  使用宿主机的端口，使能够访问个Node的外部客户端通过Node的IP地址和端口号就能访问服务</span></span><br><span class="line">                           <span class="comment"># LoadBalancer: 使用外接负载均衡完成到服务的负载分发，需要在spec.status.loadBalancer字段指定外部负载均衡器的IP地址，</span></span><br><span class="line">                           <span class="comment">#               并同时定义nodePort和clusterIP，用于公有云环境</span></span><br><span class="line"><span class="attr">  clusterIP:</span> <span class="string">string</span>        <span class="comment"># string     虚拟服务IP地址，当type=ClusterIP时，如果不指定，则系统自动分配，也可以手动指定；当type=LoaderBalancer需要指定</span></span><br><span class="line"><span class="attr">  sessionAffinity:</span> <span class="string">string</span>  <span class="comment"># string     是否支持Session，可选值为ClientIP，默认为空</span></span><br><span class="line">                           <span class="comment"># ClientIP:  表示将同一个客户端（根据IP地址决定）的访问请求都转发到同一个后端Pod</span></span><br><span class="line"><span class="attr">  ports:</span>                   <span class="comment"># list       需要暴露的端口列表</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span>         <span class="comment"># 端口名称</span></span><br><span class="line"><span class="attr">      protocol:</span> <span class="string">string</span>     <span class="comment"># 端口协议    支持tcp和udp，默认为tcp</span></span><br><span class="line"><span class="attr">      port:</span> <span class="string">int</span>            <span class="comment"># 服务监听的端口号</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="string">int</span>      <span class="comment"># 需要转发到后端Pod的端口号</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="string">int</span>        <span class="comment"># 当spec.type=NodePort时，指定映射到物理机的端口号</span></span><br><span class="line"><span class="attr">  status:</span>                  <span class="comment"># 当spec.type=LoadBalancer时，设置外部负载均衡器的地址，用于公有云环境</span></span><br><span class="line"><span class="attr">    loadBalancer:</span>          <span class="comment"># 外部负载均衡器</span></span><br><span class="line"><span class="attr">      ingress:</span>             <span class="comment"># 外部负载均衡器</span></span><br><span class="line"><span class="attr">        ip:</span> <span class="string">string</span>         <span class="comment"># 外部负载均衡器的IP地址</span></span><br><span class="line"><span class="attr">        hostname:</span> <span class="string">string</span>   <span class="comment"># 外部负载均衡器的主机名</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kubernetes-service配置详解&quot;&gt;&lt;a href=&quot;#kubernetes-service配置详解&quot; class=&quot;headerlink&quot; title=&quot;kubernetes service配置详解&quot;&gt;&lt;/a&gt;kubernetes service配置
      
    
    </summary>
    
      <category term="kubernetes" scheme="https://kylin1994.github.io/categories/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="https://kylin1994.github.io/tags/kubernetes/"/>
    
      <category term="service" scheme="https://kylin1994.github.io/tags/service/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes Pod的扩容和伸缩</title>
    <link href="https://kylin1994.github.io/2018/08/07/kubernetes-Pod%E7%9A%84%E6%89%A9%E5%AE%B9%E5%92%8C%E4%BC%B8%E7%BC%A9/"/>
    <id>https://kylin1994.github.io/2018/08/07/kubernetes-Pod的扩容和伸缩/</id>
    <published>2018-08-07T01:54:46.000Z</published>
    <updated>2019-06-02T00:03:09.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-Pod的扩容和伸缩"><a href="#Kubernetes-Pod的扩容和伸缩" class="headerlink" title="Kubernetes Pod的扩容和伸缩"></a>Kubernetes Pod的扩容和伸缩</h1><p>此笔记来自于《Kubernetes权威指南：从Docker到Kubernetes实践全接触（第二版）》2.4.9节，由于Kubernetes的版本的不断迭代跟新，书中有些教程由于版本原因，不在适用于高版本k8s，本笔记在原著教程基础上做了适当调整，已适用于目前版本的K8s。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/0069RVTdgy1fu0dfy83p2j30qy086q3u.jpg" alt="版本信息"></p><h2 id="通过kubectl-scale命令"><a href="#通过kubectl-scale命令" class="headerlink" title="通过kubectl scale命令"></a>通过<code>kubectl scale</code>命令</h2><p>首先创建expansion-test.yaml文件。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">expansion-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    test:</span> <span class="string">expansion</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      test:</span> <span class="string">expansion</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">expansion-test</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">tomcat</span></span><br><span class="line"><span class="attr">          imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br></pre></td></tr></table></figure></p><p>执行命令<code>kubectl create -f expansion-test.yaml</code></p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/0069RVTdgy1fu0dfzc4ljj30za05idhn.jpg" alt="执行命令及结果"></p><p>如上图所示，已经成共创建了一个名为expansion-test的ReplicationController，使用<code>kubectl get pod</code>命令查看创建的Pod，一共有两个，因为<code>spec.replicas=2</code>。</p><p>现在使用<code>kubectl scale rc expansion-test —replicas=4</code>命令，将expansion-test的副本数增加至4。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/0069RVTdgy1fu0dfyor6jj311u07etb6.jpg" alt="执行命令及结果"></p><p>然后查看Pod数量，已经增加至4。</p><h2 id="基于CPU使用率的Pod自动扩容和伸缩"><a href="#基于CPU使用率的Pod自动扩容和伸缩" class="headerlink" title="基于CPU使用率的Pod自动扩容和伸缩"></a>基于CPU使用率的Pod自动扩容和伸缩</h2><p>Kubernetes v1.1增加了Horizontal Pod Autoscaler(HPA)控制器，用于实现CUP利用率的Pod扩缩容功能。HPA控制器基于Master的kube-controller-manager服务启动参数<code>—horizontal-pod-autoscaler-sync-period</code>定义的时长（默认为30秒），周期性的检测目标Pod的CPU使用率，并在满足条件时对ReplicationController或Deployment中的Pod数量进行调整，以符合用户定义的平均Pod CPU使用率。Pod CPU使用率来源于heapster组件，所以需要预先安装好heapster。</p><p>创建HPA时可以用kubectl scale命令进行快速创建或者使用yaml配置文件进行创建。<strong>在创建HPA之前，需要存在一个RC或者Deployment对象，并且该RC或Deployment中的Pod必须定义resources.requests.cpu的资源请求值，如果不设置该值，则heapster将无法采集到该Pod的CPU使用情况，会导致HPA无法正常工作。</strong></p><h3 id="安装heapster组件："><a href="#安装heapster组件：" class="headerlink" title="安装heapster组件："></a>安装heapster组件：</h3><p><code>git clone git@github.com:kubernetes/heapster.git</code></p><p><code>kubectl create -f ./deploy/kube-config/influxdb/</code></p><p>创建上述的Deployment时，需要用到</p><ul><li>k8s.gcr.io/heapster-amd64:v1.5.4</li><li>k8s.gcr.io/heapster-grafana-amd64:v5.0.4</li><li>k8s.gcr.io/heapster-influxdb-amd64:v1.5.2</li></ul><p>三个镜像，因此执行上面第二条命令需要配置docker代理，当然读者也可以通过Alibaba、DaoCloud等提供的镜像仓库中获取。</p><h3 id="创建ReplicationController"><a href="#创建ReplicationController" class="headerlink" title="创建ReplicationController"></a>创建ReplicationController</h3><p>因为创建HPA之前，要先存在一个RC或者Deployment，并且必须在该RC或Deployment中的Pod必须定义<code>resources.requests.cpu</code>的资源请求值，所以这里以RC为例，其<code>requests.cpu=200m</code>，没有limits限制。</p><p>首先创建php-apache-rc.yaml配置文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">php-apche</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">  metadata:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">php-apache</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">php-apache</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">php-apache</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">gcr.io/google_containers/hpa-example</span></span><br><span class="line"><span class="attr">          resources:</span></span><br><span class="line"><span class="attr">            requests:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">200</span><span class="string">m</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">            - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>创建RC: <code>kubectl create -f php-apache-rc.yaml</code></p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/0069RVTdgy1fu0dg00nbcj30g602f0t8.jpg" alt="执行命令及结果"></p><p>上图status为imagePullBackOff，可以使用<code>kubectl logs</code>命令查看日志，原因是被qiang了。因为pull gcr.io/google_containers/hpa-example镜像需要配置docker代理。这里可以自己百度一下docker代理配置，很简单~ 配置好代理之后，删除当前Pod，由于rc中<code>replicas=1</code>，所以rc会自动重新创建一个新的Pod，当status为running时，Pod创建成功。</p><h3 id="创建Service"><a href="#创建Service" class="headerlink" title="创建Service"></a>创建Service</h3><p>创建一个php-apache的Service，供客户端访问。首先先创建如下php-apache-svc.yaml。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr"> name:</span> <span class="string">php-apache</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">php-apache</span></span><br></pre></td></tr></table></figure><p>执行<code>kubectl get svc</code>创建Service，然后查看创建情况，创建成功。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/0069RVTdgy1fu0dfx7rxgj30dv020gm0.jpg" alt="执行命令及结果"></p><h3 id="创建HPA控制器"><a href="#创建HPA控制器" class="headerlink" title="创建HPA控制器"></a>创建HPA控制器</h3><p>创建HPA时可以用kubectl scale命令进行快速创建或者使用yaml配置文件进行创建。</p><h4 id="使用kubectl-scale命令创建HPA"><a href="#使用kubectl-scale命令创建HPA" class="headerlink" title="使用kubectl scale命令创建HPA"></a>使用kubectl scale命令创建HPA</h4><p>可以使用以下命令来创建HPA，最大Pod数量为10，最小Pod数量为1，平均CPU利用率维持在50%。</p><p><code>kubectl autoscale rc php-apache —min=1 —max=10 —cpu-percent=50</code></p><h4 id="使用yaml配置文件创建HPA"><a href="#使用yaml配置文件创建HPA" class="headerlink" title="使用yaml配置文件创建HPA"></a>使用yaml配置文件创建HPA</h4><p>首先先创建如下图所示的hpa-php-apache.yaml文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">hpa-php-apache</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  scaleTargetRef:</span></span><br><span class="line"><span class="attr">    apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">    kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">php-apache</span></span><br><span class="line"><span class="attr">  minReplicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  maxReplicas:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">  targetCPUUtilizationPercentage:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure><p>创建HPA并查看结果。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/0069RVTdgy1fu0dfw6zyij30ja02g74y.jpg" alt="执行命令及结果"></p><p>如上图所示，使用<code>kubectl get hpa</code>命令查看创建情况，发现 target一栏中使用的CPU为\&lt;unknown>，说明HPA从heapster获取CPU数据失败，这是因为k8s 1.9 之前kube-controller-manager 参数<code>--horizontal-pod-autoscaler-use-rest-clients</code>为false，1.9之后true。当然，最简单的方式就是修改其值为false，具体详见<a href="https://github.com/kubernetes/kubernetes/issues/57673" target="_blank" rel="noopener">官方issue</a>。</p><p>更好的办法是安装metrix server组件，步骤如下：</p><p><code>git clone git@github.com:kubernetes-incubator/metrics-server.git</code></p><p>1.8以上：<code>kubectl create -f deploy/1.8+/</code></p><p>1.7或以下：<code>kubectl create -f deploy/1.7/</code></p><p>安装完之后，删除当前的HPA：<code>kubectl delete hpa hpa-php-apache</code>，重新创建：<code>kubectl create -f hpa-php-apache.yml</code>。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/0069RVTdgy1fu0dg10kzqj312802y75d.jpg" alt="HPA创建成功"></p><p>此时可以看到target那一栏\&lt;unknown>变为了0%说明当前的CPU使用率为0%。</p><h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><p>接下来对php-apache service进行压测，首先先创建busybox-pod.yaml文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">  spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">[</span> <span class="string">"sleep"</span><span class="string">,</span> <span class="string">"3600"</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p>然后执行<code>kubectl create -f busybox-pod.yaml</code>创建Pod。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/0069RVTdgy1fu0dfvuuh2j30fu02ugm3.jpg" alt="执行命令及结果"></p><p>然后登陆到上面创建的busybox中：<code>kubectl exec -it busybox /bin/sh</code></p><p>然后在容器中执行<code>while true; do wget -q -O- http://php-apache &gt; /dev/null; done</code>，不断向php-apache Service发送请求，过一段时间后观察HPA搜集到PodCPU使用率。</p><p><code>kubectl get hpa</code></p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/0069RVTdgy1fu0wmmjqahj30j9090acy.jpg" alt="查看HPA使用情况"></p><p>可以看出，CPU占用率不断升高，HPA通过不断增加Replicas来使CPU平均使用率保持在设定的50%。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Kubernetes-Pod的扩容和伸缩&quot;&gt;&lt;a href=&quot;#Kubernetes-Pod的扩容和伸缩&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes Pod的扩容和伸缩&quot;&gt;&lt;/a&gt;Kubernetes Pod的扩容和伸缩&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="kubernetes" scheme="https://kylin1994.github.io/categories/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="https://kylin1994.github.io/tags/kubernetes/"/>
    
      <category term="pod" scheme="https://kylin1994.github.io/tags/pod/"/>
    
      <category term="HPA" scheme="https://kylin1994.github.io/tags/HPA/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes pod 配置详解</title>
    <link href="https://kylin1994.github.io/2018/08/02/kubernetes-pod-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>https://kylin1994.github.io/2018/08/02/kubernetes-pod-配置详解/</id>
    <published>2018-08-02T02:37:18.000Z</published>
    <updated>2019-06-02T00:03:09.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kubernetes-pod-配置详解"><a href="#kubernetes-pod-配置详解" class="headerlink" title="kubernetes pod 配置详解"></a>kubernetes pod 配置详解</h1><p>以下配置归纳自《Kubernetes权威指南》第二版。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>               <span class="comment"># String,  Required,      版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>                    <span class="comment"># String,  Required,      Pod</span></span><br><span class="line"><span class="attr">metadata:</span>                    <span class="comment"># Object,  Required,      元数据</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">string</span>               <span class="comment"># String,  Required,      Pod的名称</span></span><br><span class="line"><span class="attr">  namespaces:</span> <span class="string">string</span>         <span class="comment"># String,  Required,      Pod所属命名空间，默认为default</span></span><br><span class="line"><span class="attr">  labels:</span>                    <span class="comment"># List,    Not Required,  自定义标签列表</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">  annotations:</span>               <span class="comment"># List,    Not Required,  自定义注解列表</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">spec:</span>                        <span class="comment"># Object,  Required,      Pod中容器的详细定义</span></span><br><span class="line"><span class="attr">  containers:</span>                <span class="comment"># List,    Required,      Pod中的容器列表</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">string</span>           <span class="comment"># String,  Required,容器名称</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">string</span>          <span class="comment"># String,  Required,容器的镜像名称</span></span><br><span class="line">      <span class="comment"># String, Not Required, 获取镜像的策略,默认为Always: 每次都重新获取,Never: 仅使用本地镜像,IfNotPresent: 本地没有就下载</span></span><br><span class="line"><span class="attr">      imagePullPolicy:</span> <span class="string">[Always</span> <span class="string">| Never | IfNotPresent]</span></span><br><span class="line"><span class="string"></span><span class="attr">      command:</span> <span class="string">[string]</span>      <span class="comment"># List,    Not Required,  容器的启动命令，如果缺省，就使用容器打包时的启动命令</span></span><br><span class="line"><span class="attr">      args:</span> <span class="string">[string]</span>         <span class="comment"># List,    Not Required,  容器的启动命令参数列表</span></span><br><span class="line"><span class="attr">      workingDir:</span> <span class="string">string</span>     <span class="comment"># String,  Not Required,  容器的工作目录</span></span><br><span class="line"><span class="attr">      volumeMounts:</span>          <span class="comment"># List,    Not Required,  挂载到容器内部的存储卷配置</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">string</span>       <span class="comment"># string,  Not Required,  引用Pod定义的共享存储卷的名称， 需要用volumes[]部分定义的共享存储卷名称</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">string</span>  <span class="comment"># string,  Not Required,  存储卷在容器内Mount的绝对路径，应少于512字符</span></span><br><span class="line"><span class="attr">          readOnly:</span> <span class="string">boolean</span>  <span class="comment"># Boolean, Not Required,  是否为字符模式， 默认为读写模式</span></span><br><span class="line"><span class="attr">      ports:</span>                 <span class="comment"># List,    Not Required,  容器需要暴露的端口列表</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">string</span>       <span class="comment"># String,  Not Required,  端口的名称</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="string">int</span> <span class="comment"># Int,     Not Required,  容器需要监听的端口号</span></span><br><span class="line"><span class="attr">          hostPort:</span> <span class="string">int</span>      <span class="comment"># Int,     Not Required,  不建议配置！！！容器所在主机需要监听的端口号， 默认与contianer相同。 设置hostPort时，同一台宿主主机上无法启动该容器的第二份副本。</span></span><br><span class="line"><span class="attr">          protocol:</span> <span class="string">string</span>   <span class="comment"># String,  Not Required,  端口协议，支持TCP和UDP，默认为TCP</span></span><br><span class="line"><span class="attr">      env:</span>                   <span class="comment"># List,    Not Required,  容器运行前需要设置的环境变量列表</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">string</span>       <span class="comment"># string,  Not Required,  环境变量的名称</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">string</span>      <span class="comment"># string,  Not Required,  环境变量的值</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">string</span>       <span class="comment"># string,  Not Required,  环境变量的名称</span></span><br><span class="line"><span class="attr">          valueFrom:</span>         <span class="comment"># Object,  Not Required,  环境变量来自哪里</span></span><br><span class="line"><span class="attr">            configMapKeyRef:</span> <span class="comment"># Object,  Not Required,  来自configMap</span></span><br><span class="line"><span class="attr">              name:</span> <span class="string">string</span>   <span class="comment"># string,  Not Required,  ConfigMap的名称 </span></span><br><span class="line"><span class="attr">              key:</span> <span class="string">string</span>    <span class="comment"># string,  Not Required,  configMap的键</span></span><br><span class="line"><span class="attr">      resources:</span>             <span class="comment"># Object,  Not Required,  资源限制和资源需求设置</span></span><br><span class="line"><span class="attr">        limits:</span>              <span class="comment"># Object,  Not Required,  资源限制的设置</span></span><br><span class="line"><span class="attr">          cpu:</span> <span class="string">string</span>        <span class="comment"># string,  Not Required,  CPU的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class="line"><span class="attr">          memory:</span> <span class="string">string</span>     <span class="comment"># string,  Not Required,  内存的限制，单位可以为MiB/GiB等，将用于docker run --memory参数</span></span><br><span class="line"><span class="attr">        requests:</span>            <span class="comment"># Object,  Not Required,  资源需求的设置</span></span><br><span class="line"><span class="attr">          cpu:</span> <span class="string">string</span>        <span class="comment"># string,  Not Required,  CPU需求，单位为core数，容器启动的初始可用数量</span></span><br><span class="line"><span class="attr">          memory:</span> <span class="string">string</span>     <span class="comment"># string,  Not Required,  内存需求，单位可以为MiB,Gib等，容器启动时的初始可用数量</span></span><br><span class="line"><span class="attr">      livenessProbe:</span>         <span class="comment"># Object,  Not Required,  对Pod内各个容器进行健康检查的设置，当探测无响应几次之后，系统会自动重启该容器。对一个容器仅需设置一种健康检查的方法。</span></span><br><span class="line"><span class="attr">        exec:</span>                <span class="comment"># Object,  Not Required,  设置健康检查方式为exec方式</span></span><br><span class="line"><span class="attr">          command:</span> <span class="string">[string]</span>  <span class="comment"># string,  Not Required,  健康检查需要执行的命令或者脚本</span></span><br><span class="line"><span class="attr">        httpGet:</span>             <span class="comment"># Object,  Not Required,  设置健康检查的方式为httpGet方式</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">string</span>       <span class="comment"># string,  Not Required,  </span></span><br><span class="line"><span class="attr">          port:</span> <span class="string">number</span>       <span class="comment"># number,  Not Required,</span></span><br><span class="line"><span class="attr">          host:</span> <span class="string">string</span>       <span class="comment"># string,  Not Required, </span></span><br><span class="line"><span class="attr">          scheme:</span> <span class="string">string</span>     <span class="comment"># string,  Not Required, </span></span><br><span class="line"><span class="attr">          httpHeaders:</span>       <span class="comment"># Object,  Not Required,</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">string</span>   <span class="comment"># string,  Not Required, </span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">string</span>  <span class="comment"># string,  Not Required, </span></span><br><span class="line"><span class="attr">        tcpSocket:</span>           <span class="comment"># Object,  Not Required,  设置健康检查方式为tcpSocket</span></span><br><span class="line"><span class="attr">        port:</span> <span class="string">number</span>         <span class="comment"># number,  Not Required,</span></span><br><span class="line"><span class="attr">        initialDelaySeconds:</span> <span class="number">0</span> <span class="comment"># number,  Not Required,  容器启动完成后进行首次健康检查的时间，单位为秒</span></span><br><span class="line"><span class="attr">        timeoutSeconds:</span> <span class="number">0</span>      <span class="comment"># number,  Not Required,  健康检查等待响应超时时间，单位为秒，默认为1秒，超时则重启</span></span><br><span class="line"><span class="attr">        periodSeconds:</span> <span class="number">0</span>       <span class="comment"># number,  Not Required,  对容器健康检查的定期探测时间设置，单位为秒，默认为10秒探测1次</span></span><br><span class="line"><span class="attr">        successThreshold:</span> <span class="number">0</span>    <span class="comment"># number,  Not Required,  </span></span><br><span class="line"><span class="attr">        failureThreshold:</span> <span class="number">0</span>    <span class="comment"># number,  Not Required,</span></span><br><span class="line"><span class="attr">  securityContext:</span>           <span class="comment"># 详见： https://www.kubernetes.org.cn/security-context-psp</span></span><br><span class="line"><span class="attr">    privileged:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">restartPolicy:</span> <span class="string">[Always</span> <span class="string">| Never | OnFailure]</span></span><br><span class="line"><span class="string"></span><span class="attr">nodeSelector:</span> <span class="string">object</span>         <span class="comment"># Object,  Not Required,  设置NodeSelector表示将该pod调度到包含这些label的Node上，以key: value形式指定</span></span><br><span class="line"><span class="attr">imagePullSecrets:</span>            <span class="comment"># Object,  Not Required,  pull镜像时使用的secret名称，以name: secretKey格式指定</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">hostNetwork:</span> <span class="literal">false</span>           <span class="comment"># Boolean, Not Required,  不建议配置！！！是否使用主机网络。默认为false，如果设置为true，不再使用docker网桥，该pod将无法再同一台宿主机上启动第二个副本</span></span><br><span class="line"><span class="attr">volumes:</span>                     <span class="comment"># List,    Not Required,  在该Pod定义的共享存储卷列表  </span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">string</span>             <span class="comment"># string,  Not Required,  共享存储卷的名称。容器定义部分的container[].volumeMount[].name将引用此名称</span></span><br><span class="line"><span class="attr">    emptyDir:</span> <span class="string">&#123;&#125;</span>             <span class="comment"># Object,  Not Required,  类型为emptyDir的存储卷，表示与Pod生命周期相同的一个临时目录，其值为一个空对象</span></span><br><span class="line"><span class="attr">    hostPath:</span>                <span class="comment"># Object,  Not Required,  类型为hostPath的存储卷，表示与挂载Pod所在宿主机的目录</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">string</span>           <span class="comment"># string,  Not Required,  Pod所在主机的目录，将被用于容器中mount的目录</span></span><br><span class="line"><span class="attr">    secret:</span>                  <span class="comment"># Object,  Not Required,  类型为secret的存储卷，表示挂载集群预定义的secret对象到容器内部</span></span><br><span class="line"><span class="attr">      secretName:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">      items:</span></span><br><span class="line"><span class="attr">        - key:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">    configMap:</span>               <span class="comment"># Object,  Not Required,  类型为secret的存储卷， 表示挂载集群预定义的configMap对象到容器内部</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">      items:</span></span><br><span class="line"><span class="attr">        - key:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">string</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kubernetes-pod-配置详解&quot;&gt;&lt;a href=&quot;#kubernetes-pod-配置详解&quot; class=&quot;headerlink&quot; title=&quot;kubernetes pod 配置详解&quot;&gt;&lt;/a&gt;kubernetes pod 配置详解&lt;/h1&gt;&lt;p&gt;以下
      
    
    </summary>
    
      <category term="kubernetes" scheme="https://kylin1994.github.io/categories/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="https://kylin1994.github.io/tags/kubernetes/"/>
    
      <category term="pod" scheme="https://kylin1994.github.io/tags/pod/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习笔记（6）- Dockerfile</title>
    <link href="https://kylin1994.github.io/2018/03/29/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89-Dockerfile/"/>
    <id>https://kylin1994.github.io/2018/03/29/Docker学习笔记（6）-Dockerfile/</id>
    <published>2018-03-29T15:52:42.000Z</published>
    <updated>2019-06-02T00:03:01.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Dockerfile创建镜像"><a href="#使用Dockerfile创建镜像" class="headerlink" title="使用Dockerfile创建镜像"></a>使用Dockerfile创建镜像</h1><p>Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile来快速创建自定义的镜像。</p><p>本章首先介绍Dockerfile典型的基本结构和它支持的众多指定，并具体讲解通过这些指令来编写定制镜像的Dockerfile，以及如何生成镜像。最后介绍使用Dockerfile的一些最佳时间经验。</p><h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>Dockerfile有一行行命令语句组成，并且支持以#开头的注释行。</p><p>一般而言，Dockerfile分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。</p><h1 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明"></a>指令说明</h1><p>指令的一般格式为INSTRUCTION arguments，指令包括FROM/MAINTAINER/RUN等，参见下图：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1462" alt="img"></p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1464" alt="img"></p><p>下面本别介绍</p><h2 id="1-FROM"><a href="#1-FROM" class="headerlink" title="1.FROM"></a>1.FROM</h2><p>指定所创建镜像的基础镜像，如果本地不存在，则默认回去Docker Hub下载指定镜像。</p><p>格式为：<code>FROM&lt;image&gt;</code>，或<code>FROM&lt;image&gt;:&lt;tag&gt;</code>，或<code>FROM&lt;image&gt;@&lt;digest&gt;</code>。</p><p>任何Dockerfile中的第一条指令必须为FROM指令。并且，如果在同一个Dockerfile中创建多个镜像，可以使用多个FROM指令（每个镜像一次）。</p><h2 id="2-MAINTAINER"><a href="#2-MAINTAINER" class="headerlink" title="2.MAINTAINER"></a>2.MAINTAINER</h2><p>指定维护者信息，格式为<code>MAINTAINER&lt;name&gt;</code>。例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER image_creator@docker.com</span><br></pre></td></tr></table></figure><p>该信息会写入生成镜像的Author属性域中。</p><h2 id="3-RUN"><a href="#3-RUN" class="headerlink" title="3.RUN"></a>3.RUN</h2><p>运行指定命令。</p><p>格式为:<code>RUN&lt;command&gt;</code>或<code>RUN [&quot;exeutable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code>。</p><p>注意，后一个指令会被解析为json数组，因此必须用双引号。</p><p>前者默认将在shell终端中运行命令，即<code>/bin/sh -c</code>；后者则使用exec执行，不会启用shell环境。</p><p>指定其他终端类型可以通过第二种方式实现，例如<code>RUN[&quot;bin/bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]</code>。</p><p>每条RUN指令将在当前镜像的基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用\来换行，例如：</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update \</span><br><span class="line"></span><br><span class="line">    &amp;&amp; apt-get install -y libsnappy-dev zlib1g-dev libbz2-dev \</span><br><span class="line"></span><br><span class="line">    &amp;&amp; rm -rf /var/cache/apt</span><br></pre></td></tr></table></figure><hr><h2 id="4-CMD"><a href="#4-CMD" class="headerlink" title="4.CMD"></a>4.CMD</h2><p>CMD指令用来指定启动容器时默认执行的命令。它支持三种格式：</p><ul><li><code>CMD[&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code>使用exec执行，是推荐使用的方式；</li><li><code>CMD command param1 param2在/bin/sh</code>中执行，提交给需要交互的应用；</li><li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code>提供给ENTRYPOINT的默认参数。</li></ul><p>每个Dockerfile只能有一条CMD命令。如果指定了多条，只有最后一条会被执行。</p><p>如果用户启动容器时手动指定了运行的命令（作为run的参数），则会覆盖掉CMD指定的命令。</p><h2 id="5-LABEL"><a href="#5-LABEL" class="headerlink" title="5.LABEL"></a>5.LABEL</h2><p>LABEL指令用来指定生成镜像的元数据标签信息。</p><p>格式为<code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;….</code>。例如</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LABEL version=&quot;1.0&quot;</span><br><span class="line"></span><br><span class="line">LABEL description=&quot;this text ilustrates \</span><br><span class="line"></span><br><span class="line">    that label-values can span multiple lines.&quot;</span><br></pre></td></tr></table></figure><hr><h2 id="6-EXPOSE"><a href="#6-EXPOSE" class="headerlink" title="6.EXPOSE"></a>6.EXPOSE</h2><p>声明镜像内服务所监听的端口。</p><p>格式为<code>EXPOSE &lt;port&gt;[&lt;port&gt;…]</code>。例如</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 22 80 8443</span><br></pre></td></tr></table></figure><hr><p>注意，该指令只是起到声明作用，并不会自动完成端口映射。</p><p>在启动容器时需要使用<code>-P</code>，Docker主机会自动分配一个宿主机的临时端口转发到指定的端口；使用<code>-p</code>可以具体指定那个宿主机的本地端口会映射过来。</p><h2 id="7-ENV"><a href="#7-ENV" class="headerlink" title="7.ENV"></a>7.ENV</h2><p>指定环境变量，在镜像生成过程中会被后续RUN指令使用，在镜像启动的容器中也会存在。</p><p>格式为<code>ENV &lt;key&gt;&lt;value&gt;</code>或<code>&lt;key&gt;=&lt;value&gt;…</code>。例如：</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ENV PG_MAJOR 9.3</span><br><span class="line"></span><br><span class="line">ENV PG_VERSION 9.3.4</span><br><span class="line"></span><br><span class="line">RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgres &amp;&amp; ...</span><br><span class="line"></span><br><span class="line">ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</span><br></pre></td></tr></table></figure><hr><p>指令指定的环境变量在运行时可以被覆盖掉，如<code>docker run --env &lt;key&gt;=&lt;value&gt; built_image</code>。</p><h2 id="8-ADD"><a href="#8-ADD" class="headerlink" title="8.ADD"></a>8.ADD</h2><p>该命令将复制指定的<code>&lt;src&gt;</code>路径下的内容到容器中的<code>&lt;dest&gt;</code>路径下。</p><p>格式为<code>ADD&lt;src&gt;&lt;dest&gt;</code>。</p><p>其中<code>&lt;src&gt;</code>可以是Dockerfile所在目录的一个相对路径（文件或目录），也可以是一个URL，还可以是一个tar文件（如果为tar文件，会自动解压到<code>&lt;dest&gt;</code>路径下）。<code>&lt;dest&gt;</code>可以是镜像内的绝对路径，或者相对于工作目录（WORKDIR）的相对路径。</p><p>路径支持正则格式，例如：</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD *.c /code/</span><br></pre></td></tr></table></figure><hr><h2 id="9-COPY"><a href="#9-COPY" class="headerlink" title="9.COPY"></a>9.COPY</h2><p>格式为<code>COPY &lt;src&gt; &lt;dest&gt;</code></p><p>复制本地主机的<code>&lt;src&gt;</code>（为Dockerfile所在目录的相对路径、文件或目录）下的内容到镜像中的<code>&lt;dest&gt;</code>下。目标路径不存在时，会自动创建。</p><p>路径同样支持正则格式。</p><p>当使用本地目录为源目录时，推荐使用COPY。</p><h2 id="10-ENTRYPOINT"><a href="#10-ENTRYPOINT" class="headerlink" title="10.ENTRYPOINT"></a>10.ENTRYPOINT</h2><p>指定镜像的默认入口命令，该入口命令会在启动容器时作为根命令执行，所有传入值作为该命令的参数。</p><p>支持两种格式：</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]（exec调用执行）</span><br><span class="line"></span><br><span class="line">ENTRYPOINT command param1 param2 (shell中执行）</span><br></pre></td></tr></table></figure><hr><h2 id="11-VOLUME"><a href="#11-VOLUME" class="headerlink" title="11.VOLUME"></a>11.VOLUME</h2><p>创建一个数据卷挂载点。</p><p>格式为<code>VOLUME[&quot;/data&quot;]</code>。</p><p>可以从本地主机或其他容器挂载数据卷，一般用来存放数据库和需要保存的数据。</p><h2 id="12-USER"><a href="#12-USER" class="headerlink" title="12.USER"></a>12.USER</h2><p>指定运行容器的用户名或UID，后续的RUN等指令也会使用指定的用户身份。</p><p>格式为<code>UESR daemon</code>。</p><p>当服务不需要管理员权限时，可以通过该命令指定运行用户，并且可以在之前创建所需要的用户。例如：</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</span><br></pre></td></tr></table></figure><hr><p>要临时获取管理员权限可以使用gosu或sudo。</p><h2 id="13-WORKDIR"><a href="#13-WORKDIR" class="headerlink" title="13.WORKDIR"></a>13.WORKDIR</h2><p>为后续的RUN、CMD和ENTRYPOINT指令配置工作目录。</p><p>格式为<code>WORKDIR/path/to/workdir</code>。</p><p>可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定路径。例如：</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line"></span><br><span class="line">WORKDIR b</span><br><span class="line"></span><br><span class="line">WORKDIR c</span><br><span class="line"></span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure><hr><p>则最终路径为/a/b/c。</p><h2 id="14-AGR"><a href="#14-AGR" class="headerlink" title="14.AGR"></a>14.AGR</h2><p>指定一些镜像内使用的参数（例如版本号信息等），这些参数在实行docker build命令时才以</p><p><code>--build-arg &lt;varname&gt;=&lt;value&gt;</code>格式传入。</p><p>格式为<code>ARG &lt;name&gt;[=&lt;default value&gt;]</code>。</p><p>则可以用<code>docker build --build-arg &lt;name&gt;=&lt;value&gt;</code>来指定参数的值。</p><h2 id="15-ONBUILD"><a href="#15-ONBUILD" class="headerlink" title="15.ONBUILD"></a>15.ONBUILD</h2><p>配置当所创建的镜像作为其他镜像的进出镜像时，所执行的创建操作指令。</p><p>格式为<code>ONBUILD [INSTRUCTION]</code>。</p><p>例如，Dockerfile使用如下的内容创建了镜像image-A：</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line"></span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line"></span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line"></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><hr><p>如果基于image-A创建镜像时，新的Dockerfile中使用FROM image-a指定基础镜像，会自动执行ONBUILD指令的内容，等价于在后面添加两条指令：</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM image-a</span><br><span class="line"></span><br><span class="line">\#Automatically run the following</span><br><span class="line"></span><br><span class="line">ADD . /app/src</span><br><span class="line"></span><br><span class="line">RUN /usr/local/bin/python-build --dir /app/src</span><br></pre></td></tr></table></figure><hr><p>使用ONBUILD指令的镜像，推荐在标签中注明，例如ruby:1.9-onbuild</p><h2 id="16-STOPSIGNAL"><a href="#16-STOPSIGNAL" class="headerlink" title="16.STOPSIGNAL"></a>16.STOPSIGNAL</h2><p>指定所创建镜像启动的容器接收退出的信号值。例如：</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure><hr><h2 id="17-HEALTHCHECK"><a href="#17-HEALTHCHECK" class="headerlink" title="17.HEALTHCHECK"></a>17.HEALTHCHECK</h2><p>配置所有启动容器如何进行健康检查（如何判断健康与否），自Docker 1.12开始支持。</p><p>格式有两种：</p><ul><li><code>HEALTHCHECK [OPTION] CMD command</code>:很具所执行命令返回值是否为0判断；</li><li><code>HEALTHCHECK NONE</code>:禁止基础镜像中的健康检查。</li></ul><p>OPTION支持：</p><p><code>--interval=DURATION</code>（默认为：30s）：过多久检查一次</p><p><code>--timeout=DURATION</code>（默认为：30s）：每次检查等待结果的超市；</p><p><code>--retries=N</code>（默认为：30s）：如果失败了，重试几次才最终确定失败。</p><h2 id="18-SHELL"><a href="#18-SHELL" class="headerlink" title="18.SHELL"></a>18.SHELL</h2><p>指定其他命令使用shell时的默认shell类型。</p><p>默认值为<code>[&quot;/bin/bash&quot;,&quot;-c&quot;]</code></p><p>创建镜像</p><p>编写完成Dockerfile之后，可以通过docker build命令来创建镜像。</p><p>基本的格式为<code>docker build [选项]</code>内容路径，该命令读取指定路径下（包括子目录）的Dockerfile，并将该路径下的所有内容发送给Docker服务端，由服务端来创建镜像。因此除非生成镜像需要，否则一般建议放置Dockerfile的目录为空目录。有两点经验：</p><ul><li>如果使用非当前路径下的Dockerfile，可以通过-f选项来指定其路径。</li><li>要指定生成镜像的标签信息，可以使用-f选项。</li></ul><p>例如，指定Dockerfile所在路径为/tmp/docker_builder/，并且希望生成镜像标签为build_repo/first_image，可以使用下面的命令：</p><hr><p><code>$ docker build -t build_repo/fisrt_image /tmp/docker_builder/</code></p><hr><p>使用.dockerignore文件</p><p>可以通过.dockerignore文件（每一行添加一个匹配模式）来让Docker忽略匹配模式路径下的目录和文件。例如：</p><hr><p>#comment</p><p> <em>/temp</em></p><p> <em>/</em>/temp*</p><p> temp?</p><p> ~*</p><hr><p>一些经验</p><ol><li>精简镜像用途：尽量让每个镜像的用途都比较集中、单一，避免构造大而复杂、多功能的镜像；</li><li>选用合适的基础镜像：过大的基础镜像会造成臃肿的镜像，一般推荐为小巧的debian镜像；</li><li>提供足够清晰的命令注释和维护者信息：Dockerfile也是一种代码，需要考虑方便后续扩展和他人使用；</li><li>正确使用版本号：使用明确的版本号信息，如1.0，2.0，而非latest，将避免内容不一致可能引发的惨案；</li><li>减少镜像层数：如果希望所生成镜像的层数尽量少，则要尽量合并指令，例如多个RUN指令可以合并为一条；</li><li>及时删除临时文件和缓存文件：特别是在执行apt-get指令后，/var/cache/apt下面会缓存一些安装包；</li><li>提高生成速率：合理使用缓存，减少内容目录下的文件，或使用.dockerignore文件指定等。</li><li>调整合理的指令顺序：在开启缓存的情况下，内容不变的指令尽量放在前面，这样可以尽量复用；</li><li>减少外部源的干扰：如果确实要从外部引入数据，需要指定特定持久的地址，并带有版本信息，让他人可以重复而不出错。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用Dockerfile创建镜像&quot;&gt;&lt;a href=&quot;#使用Dockerfile创建镜像&quot; class=&quot;headerlink&quot; title=&quot;使用Dockerfile创建镜像&quot;&gt;&lt;/a&gt;使用Dockerfile创建镜像&lt;/h1&gt;&lt;p&gt;Dockerfile是一个文
      
    
    </summary>
    
      <category term="docker" scheme="https://kylin1994.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://kylin1994.github.io/tags/docker/"/>
    
      <category term="容器" scheme="https://kylin1994.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习笔记（5）- 端口映射与容器互联</title>
    <link href="https://kylin1994.github.io/2018/03/29/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89-%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94/"/>
    <id>https://kylin1994.github.io/2018/03/29/Docker学习笔记（5）-端口映射与容器互联/</id>
    <published>2018-03-29T15:35:53.000Z</published>
    <updated>2019-06-02T00:03:00.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="端口映射与容器互联"><a href="#端口映射与容器互联" class="headerlink" title="端口映射与容器互联"></a>端口映射与容器互联</h1><p>除了通过网络访问外，Docker还提供了两个很方便的功能来满足服务访问的基本需求：一个是允许映射容器内应用的服务端口到本地宿主主机；另一个是互联机制实现多个容器间通过容器名来快速访问。</p><h1 id="端口映射实现访问容器"><a href="#端口映射实现访问容器" class="headerlink" title="端口映射实现访问容器"></a>端口映射实现访问容器</h1><h2 id="从外部访问容器应用"><a href="#从外部访问容器应用" class="headerlink" title="从外部访问容器应用"></a>从外部访问容器应用</h2><p>在启动容器的时候，如果不指定对应的参数，在容器外部是无法通过网络来访问容器内的网络和服务的。</p><p>当容器中运行一些网络应用，要让外部访问这些应用时，可以通过-P或-p参数来指定端口映射。</p><p>当使用-P标记时，Docker会随机映射一个49000~49900的端口到内部容器开放的网络端口。</p><h2 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h2><p>hostPort:containerPort：将本地的5000端口映射到容器的5000端口</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1347" alt="img"></p><p>此时会绑定本地所有接口上的所有地址，多次使用-p标记可以绑定多个端口。</p><h2 id="映射到指定地址的端口"><a href="#映射到指定地址的端口" class="headerlink" title="映射到指定地址的端口"></a>映射到指定地址的端口</h2><p>ip::containerPort：映射到指定地址的任意的端口：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1356" alt="img"></p><p>使用 ip::containerPort 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p><h2 id="映射到指定地址的端口-1"><a href="#映射到指定地址的端口-1" class="headerlink" title="映射到指定地址的端口"></a>映射到指定地址的端口</h2><p>当使用-p 标记时 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 ：</p><p>ip:hostPort:containerPort ：指定映射使用一个特定地址，比如localhost地址127.0.0.1:</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1352" alt="img"></p><h2 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h2><p>使用docker port命令来查看当前映射的端口配置，可以查看到绑定的地址。</p><p>$ docker port &lt;container_id | container_name&gt;</p><p>注意：容易有自己的内部网络和IP地址，使用docker inspect + 容器Id可以获取容器的具体信息。</p><h1 id="互联机制实现便捷访问"><a href="#互联机制实现便捷访问" class="headerlink" title="互联机制实现便捷访问"></a>互联机制实现便捷访问</h1><p>容器的互联（linking)是一种让多个容器中应用进行快速交互的方式。他会在源和接收容器之间创建连接关系，接收容器可以通过容器名快速访问到容器源，而不用指定具体的IP地址。</p><h2 id="自定义容器命名"><a href="#自定义容器命名" class="headerlink" title="自定义容器命名"></a>自定义容器命名</h2><p>连接系统依据容器的名称来执行。因此需要定义一个好记的容器的名字。</p><p>虽然当创建容器的时候，系统会默认分配一个名字，单自定义容器名字有两个好处：</p><ul><li>自定义命名比较好记，比如一个Web容器，我们可以起名为web，一目了然；</li><li>当要连接其他容器时，即便重启，也可以使用容器名而不用改变，比如web容器连接到db容器。</li></ul><p>使用–name标记可以为容器自定义命名：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1388" alt="img"></p><p>使用docker inspect命名查看</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1390" alt="img"></p><p>注意：</p><p>容器的名称是唯一的。如果已经命名了一个叫web的容器，当你要再次使用web这个名称的时候，需要先用docker rm来删除之前创建的同名容器。</p><p>在执行docker run的时候，如果添加–rm标记，则容器在终止后会立刻删除。注意，–rm和-d参数不能同时使用。</p><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p>使用–link参数可以让容器之间安全地进行交互。</p><p>下面先创建一个新的数据库容器</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1398" alt="img"></p><p>查看创建的容器信息</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1400" alt="img"></p><p>然后创建一个新的web容器，并将它连接到db容器</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1404" alt="img"></p><p>此时，db容器和web容器建立互联关系</p><p>–link参数的格式为–link name:alias，其中name是要连接的容器名称，alias是这个连接的别名。</p><p>使用docekr ps来查看容器的连接，如下图所示：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1411" alt="img"></p><p>Docker相当于在两个互联的容器之间创建了一个虚机通道，而且不用映射他们的端口到宿主主机上。在启动db容器的时候并没有使用-p和-P标记，从而避免了暴露数据库服务端口到外部网络上。</p><p>Docker通过两种方式为为容器公开连接信息：</p><ul><li>更新环境变量；</li><li>更新/etc/hosts文件。</li></ul><p>使用env命名来查看web容器环境变量：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1419" alt="img"></p><p>其中DB_开头大写的环境变量是供web容器连接db容器使用的，前缀采用大写的连接别名。</p><p>除了环境变量之外，Docker还添加host信息到父容器的/etc/hosts文件。下面是父容器web的hosts文件：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1427" alt="img"></p><p>这里有两个hosts信息，第一个是web容器，web容器用自己的id作为默认主机名，第二个是容器的ip和容器的别名以及id。</p><p>可以在web容器中安装Ping命令来测试与db容器的连通：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1434" alt="img"></p><p>用Ping来测试db容器，他会解析成172.17.0.5。用户可以连接多个子容器到父容器，比如可以连接多个web到同一个db容器上。</p><h1 id="本文小结"><a href="#本文小结" class="headerlink" title="本文小结"></a>本文小结</h1><p>毫无疑问，容器服务的访问是很关键的一个用途。本文通过具体案例讲解了Docker容器服务访问的两大基本操作，包括基础的容器端口映射机制和容器的互联机制。同时，Docker目前可以成熟的支持Linux系统自带的网络服务和功能，这既可以利用现有成熟的技术提供稳定支持，又可以实现快速的高性能转发。</p><p>在生产环境中，网络方面的需求更加复杂多变，包括跨主机甚至夸数据中心的通信，这时候往往就需要引入额外的机制，例如SDN或NFV（网络功能虚拟化）的相关技术。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;端口映射与容器互联&quot;&gt;&lt;a href=&quot;#端口映射与容器互联&quot; class=&quot;headerlink&quot; title=&quot;端口映射与容器互联&quot;&gt;&lt;/a&gt;端口映射与容器互联&lt;/h1&gt;&lt;p&gt;除了通过网络访问外，Docker还提供了两个很方便的功能来满足服务访问的基本需求：一
      
    
    </summary>
    
      <category term="docker" scheme="https://kylin1994.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://kylin1994.github.io/tags/docker/"/>
    
      <category term="容器" scheme="https://kylin1994.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习笔记（4）- Docker数据卷</title>
    <link href="https://kylin1994.github.io/2018/03/29/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89-Docker%E6%95%B0%E6%8D%AE%E5%8D%B7/"/>
    <id>https://kylin1994.github.io/2018/03/29/Docker学习笔记（4）-Docker数据卷/</id>
    <published>2018-03-29T15:30:25.000Z</published>
    <updated>2019-06-02T00:02:53.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker数据卷"><a href="#Docker数据卷" class="headerlink" title="Docker数据卷"></a>Docker数据卷</h1><p>生产环境中使用Docker的过程中，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及容器的数据管理操作。</p><p>容器中管理数据主要有两种方式：</p><ul><li>数据卷(Data Volume)：容器内数据直接映射到本地主机环境；</li><li>数据卷容器(Data Volume Containers)：使用特定容器维护数据卷。</li></ul><p>本文将首先介绍如何在容器内创健数据卷，并且把本地的目录或文件挂载到容器内的数据卷中。接下来会介绍如何使用数据卷容器在容器和主机、容器和容器之间共享数据，并实现数据的备份和恢复。</p><h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><p>数据卷是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于Linux中的mout操作。</p><p>数据卷可以提供很多有用的特性，如下所示：</p><ul><li>数据卷可以在容器之间共享和重用，容器间传递数据将变得高效方便；</li><li>对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作；</li><li>对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作；</li><li>对数据卷的更新不会影响到镜像，解耦了应用和数据；</li><li>卷会一直存在，只有没有容器使用，可以安全地卸载它。</li></ul><h2 id="在容器中创建一个数据卷"><a href="#在容器中创建一个数据卷" class="headerlink" title="在容器中创建一个数据卷"></a>在容器中创建一个数据卷</h2><p>在用docker run命令的时候，使用-v参数可以在容器内创建一个数据卷。多次重复使用-v标记可以创建多个数据卷。</p><p>使用图中的命令在镜像ubuntu:latest上创建一个在后台运行名为volume_test的容器，并且创建了一个名为/data_volume的数据卷。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1198" alt="img"></p><p>进入容器查看，已经有了data_volume目录</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1200" alt="img"></p><h2 id="挂载一个本地目录作为数据卷"><a href="#挂载一个本地目录作为数据卷" class="headerlink" title="挂载一个本地目录作为数据卷"></a>挂载一个本地目录作为数据卷</h2><p>下面的命令创建了一个容器，并且将容器中的数据卷/data_valume挂载到本地/Users/xiangqilin/docker/data_volume。</p><p>进入容器，在数据卷/data_volume中创建一个文件test，然后在本地/Users/xiangqilin/docker/data_volume查看，容器中数据卷的数据已经映射到了本地。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1210" alt="img"></p><p>挂载数据卷的默认权限为读写（rw）,可以将其改为只读（ro)。</p><p>只需要在加上ro参数，如下所示：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1220" alt="img"></p><h2 id="挂载一个本地文件作为数据卷（不推荐）"><a href="#挂载一个本地文件作为数据卷（不推荐）" class="headerlink" title="挂载一个本地文件作为数据卷（不推荐）"></a>挂载一个本地文件作为数据卷（不推荐）</h2><p>用下面的命令可以挂载一个文件到本地，记录容器中执行的bash命令。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1226" alt="img"></p><p>注意：</p><p>如果直接挂载一个文件倒容器，使用文件编辑工具，包括vi或者sed –in-place的时候，可能会造成文件inode的改变，从Docker 1.1.0起，这会导致报错信息。所以推荐的方式是直接挂载该文件所在的目录。</p><h1 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h1><p>如果用户需要在多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器也是一个容器，但是它的目的是专门用来提供数据卷供其他容器挂载的。</p><p>首先创建一个数据卷容器volume_container，并在其中创建一个/db_data</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1255" alt="img"></p><p>创建一个容器db1，挂载volume_container中的数据卷/db_data,使用ls可以看到根目录下已经有了db_data</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1257" alt="img"></p><p>创建一个容器db2，挂载volume_container中的数据卷/db_data，使用ls可以看到根目录下已经有了db_data</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1259" alt="img"></p><p>下面的代码将测试数据卷容器挂载的目录是否在各个容器之间是同步的：</p><p>第一步在数据卷容器的数据卷中创建一个test文件。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1268" alt="img"></p><p>第二步在db1容器中，查看其挂载的数据卷，是否有test文件。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1273" alt="img"></p><p>可以看到容器db1的挂载的数据卷中已经有了test文件，说明被挂在的数据卷容器中的数据卷和挂载数据卷是同步的。</p><p>进一步验证，我们将在容器db1挂载的数据卷中创建一个文件，然后验证db2中是否也存在：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1281" alt="img"></p><p>可以看出，在容器db1中的挂载数据卷中创建的test2文件，已经同步到了db2的挂载数据卷中，所以只要是挂载的同一数据卷容器的数据卷，那么他们之间都是同步的。</p><hr><p>可以多次使用<code>--volumes-from</code>参数来从多个容器挂载多个数据卷。还可以从其他已经挂载了容器卷的容器来挂载数据卷。</p><p>注意：</p><p>使用<code>--volume-from</code>参数所挂载数据卷的容器自身并不需要保持在运行状态。</p><p>如果删除了挂载的容器（volume_container、db1和db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着他的容器时显示使用docker rm -v命令来指定同时删除关联的容器。</p><h1 id="利用数据卷容器来迁移数据"><a href="#利用数据卷容器来迁移数据" class="headerlink" title="利用数据卷容器来迁移数据"></a>利用数据卷容器来迁移数据</h1><p>可以利用数据卷容器对其中的数据卷进行备份、恢复，以实现数据的迁移。下面介绍这两个操作。</p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>使用下面的数据来备份数据卷db_data</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1303" alt="img"></p><p>这个命令有点复杂，分析一下：首先创建一个ubuntu镜像的容器，然后挂载数据卷容器volume_container的数据卷db_data。然后把自身容器中/backup目录挂载到本地/Users/xiangqlin/docker/backup。容器启动后，执行tar -cvf /backup/backup.tar /db_data将挂载的数据卷/db_data压缩到/backup/backup.tar。因为/backup目录被挂载到了本地，所以在本地也备份了数据卷的数据。</p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1319" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker数据卷&quot;&gt;&lt;a href=&quot;#Docker数据卷&quot; class=&quot;headerlink&quot; title=&quot;Docker数据卷&quot;&gt;&lt;/a&gt;Docker数据卷&lt;/h1&gt;&lt;p&gt;生产环境中使用Docker的过程中，往往需要对数据进行持久化，或者需要在多个容器之间
      
    
    </summary>
    
      <category term="docker" scheme="https://kylin1994.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://kylin1994.github.io/tags/docker/"/>
    
      <category term="容器" scheme="https://kylin1994.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习笔记（3）- Docker仓库</title>
    <link href="https://kylin1994.github.io/2018/03/29/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89-Docker%E4%BB%93%E5%BA%93/"/>
    <id>https://kylin1994.github.io/2018/03/29/Docker学习笔记（3）-Docker仓库/</id>
    <published>2018-03-29T15:23:43.000Z</published>
    <updated>2019-06-02T00:02:46.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="访问Docker仓库"><a href="#访问Docker仓库" class="headerlink" title="访问Docker仓库"></a>访问Docker仓库</h1><p>仓库（Repository）是集中存放镜像的地方，分公共仓库和私有仓库。一个容器混淆的概念是注册服务器（Registry)。实际上注册服务器是存放仓库的具体服务器，一个服务器上可以有多个仓库，而每个仓库下面可以有多个镜像。从这方面来说，可以将仓库看做一个具体的项目和目录。例如对于仓库地址private-docker.com/ubuntu来说，private-docker.com是注册服务器地址，ubuntu是仓库名。</p><h1 id="Docker-Hub公共镜像市场"><a href="#Docker-Hub公共镜像市场" class="headerlink" title="Docker Hub公共镜像市场"></a>Docker Hub公共镜像市场</h1><p>目前Docker官方维护了一个公共镜像仓库<a href="http://hub.docker.com，其中包括超过15000个镜像。大部分镜像需求，都可以通过在Docker" target="_blank" rel="noopener">http://hub.docker.com，其中包括超过15000个镜像。大部分镜像需求，都可以通过在Docker</a> Hub中直接下载镜像来实现。</p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p><code>docker login</code>命令来输入用户名、密码登录。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1111" alt="img"></p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>用户无需登录即可通过docker search命令来查找官方仓库中的镜像，并利用<code>docker pull</code>命令来下载到本地。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1119" alt="img"></p><p>根据是否为官方提供，可将这些镜像资源分为两类。一种是类似centos这样的基础镜像，成为基础或根镜像。这些镜像是由Docker公司创建、验证、支持、提供。这样的镜像往往使用单个单词名字。</p><p>还有一种类型，比如ansible/centos7-ansible镜像，它是由用户ansible创建并维护的，带有用户名为前缀，表明是用户下的某仓库。可以通过用户名称前缀user_name/镜像名称来指定使用某个用户提供的镜像。</p><p>另外在查找的时候，通过-s N参数可以指定显示评价为N星以上的镜像。</p><p>下载centos镜像到本地，如下所示：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1131" alt="img"></p><p>用户也可以通过<code>docker push</code>命令来将本地镜像推送到Docker Hub。</p><p>提示：Ansible是知名自动化部署配置管理工具。</p><h2 id="自动创建"><a href="#自动创建" class="headerlink" title="自动创建"></a>自动创建</h2><p>自动创建（Automated Builds）功能对于需要经常升级镜像内程序来说，十分方便。有时候，用户创建了镜像，安装了某个软件，如果软件版本发布新版本则需要手动跟新。</p><p>而自动创建允许用户通过Docker Hub指定跟踪一个目标网站（目前支持GitHub或BitBucket)上的项目，一旦项目发生新的提交，则自动执行创建。</p><p>要配置自动创建，包括如下的步骤：</p><ol><li>创建并登陆Docker Hub，以及目标网站；并在目标网站中链接账户到Docker Hub；</li><li>在Docker Hub中配置一个“自动创建”；</li><li>选取一个目标网站中的项目（需要含Dockerfile）和分支；</li><li>指定Dockerfile位置，并且提交创建</li></ol><h1 id="搭建本地仓库"><a href="#搭建本地仓库" class="headerlink" title="搭建本地仓库"></a>搭建本地仓库</h1><h2 id="使用registry镜像创建私有仓库"><a href="#使用registry镜像创建私有仓库" class="headerlink" title="使用registry镜像创建私有仓库"></a>使用registry镜像创建私有仓库</h2><p>安装docker后，可以通过官方提供的registry镜像来简单搭建一套本地私有仓库环境：</p><p><code>$docker run -d -p 5000:5000 regitry</code></p><p>这将自动下载并启动一个registry容器，创建本地的私有仓库服务。</p><p>默认情况下，会将仓库创建在容器的/tmp/registry目录下。可以通过<code>-v</code>参数来将镜像文件夹存放在本地的指定路径，例如下面的例子将镜像放到/Users/xiangqilin/registry</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1169" alt="img"></p><p>注意registry:2是ash shell，如果执行<code>$docker exec -it nifty_mahavira /bin/bash</code>会报错</p><p>向搭建好的本地仓库push成功之后，<code>-v</code>参数指定的映射目录也会存储上传的镜像</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1177" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;访问Docker仓库&quot;&gt;&lt;a href=&quot;#访问Docker仓库&quot; class=&quot;headerlink&quot; title=&quot;访问Docker仓库&quot;&gt;&lt;/a&gt;访问Docker仓库&lt;/h1&gt;&lt;p&gt;仓库（Repository）是集中存放镜像的地方，分公共仓库和私有仓库。一个
      
    
    </summary>
    
      <category term="docker" scheme="https://kylin1994.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://kylin1994.github.io/tags/docker/"/>
    
      <category term="容器" scheme="https://kylin1994.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习笔记（2）- Docker容器</title>
    <link href="https://kylin1994.github.io/2018/03/29/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89-Docker%E5%AE%B9%E5%99%A8/"/>
    <id>https://kylin1994.github.io/2018/03/29/Docker学习笔记（2）-Docker容器/</id>
    <published>2018-03-29T15:15:08.000Z</published>
    <updated>2019-06-02T00:02:29.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h1><p>容器是Docker一个核心概念。简单来说，容器是镜像的一个运行示例。所不同的是，镜像是静态的只读文件，而容器带有运行时需要的可写层文件。如果认为虚拟机是模拟运行的一整套操作系统（包括内核、应用运行态环境和其他系统环境）和跑在上面的应用，那么Docker容器就是独立运行的一个（或一组）应用，以及他们必要的运行环境。</p><h1 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h1><h2 id="新建容器"><a href="#新建容器" class="headerlink" title="新建容器"></a>新建容器</h2><p>可以使用<code>docer create</code>命令新建一个容器，例如：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/848" alt="img"></p><p>使用<code>docker create</code>命令新建的容器处于停止状态，可以使用docker start命令来启动它。</p><p><code>create</code>命令和<code>run</code>命令支持的选项都十分复杂，主要包括如下几大类：</p><ul><li>与容器运行模式相关</li><li>与容器和环境配置相关</li><li>与容器资源限制和安全保护相关</li></ul><p>表1 create命令与容器运行模式相关的选项</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/858" alt="img"></p><p>表2 create命令与容器环境和配置相关的选项</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/862" alt="img"></p><p>表3 create命令与容器资源限制和安全保护相关的选项</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/868" alt="img"></p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/867" alt="img"></p><p>其他还比较重要的选项：</p><ul><li><code>-l, --label=[]</code>：以键值对方式指定容器的标签信息</li><li><code>--label-file=[]</code>：从文件中读取标签信息</li></ul><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>使用<code>docker start</code>命令来启动一个已经创建的容器，例如启动刚才创建的容器</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/876" alt="img"></p><p>可以看出 <code>$docker start aae</code>命令启动了刚才状态为created的容器，参数aae是该容器id的前三个字符，说明只要可以唯一区别一个容器，id可以简写。</p><h2 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h2><p>除了创建容器后通过start命令来启动，可以直接新建并启动容器。所需要的命令主要为<code>docker run</code>，等价于docker create命令，在执行<code>docker start</code>命令。</p><p>用下面的命令启动一个容器，并在容器中打印“docker run test”</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/885" alt="img"></p><p>查看容器，可以发现，执行完命令之后，就退出了，状态变为exited</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/884" alt="img"></p><p>当利用docker run来创建并启动容器时，Docker在后台运行的标准操作标准包括：</p><ol><li>检查本地是否存在指定的镜像，不存在就从共有仓库下载</li><li>利用镜像创建一个容器，并启动该容器</li><li>分配一个文件系统给容器，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中</li><li>从网桥的地址池配置一个IP地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被自动终止</li></ol><p>下面的命令创建并运行了一个容器，还启动了一个bash终端，允许和用户交互</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/896" alt="img"></p><p>其中<code>-t</code>选项让Docker分配了一个伪终端（pseudo-tty）并绑定到容器的标准输入上，<code>-i</code>则让容器的标准输入保持打开。下面用<code>ps</code>命令来查看进程，只有bash和ps命令，没有其他进程。最后用exit命令退出或者ctrl+d</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/904" alt="img"></p><p>某些时候，执行<code>docker run</code>会出错，因为命令无法正常执行容器会直接退出，此时可以查看退出的错误代码。</p><p>默认情况下，常见错误代码包括：</p><ul><li>125：Docker daemon执行出错，例如指定不支持的Docker命令参数；</li><li>126：所指定的命令无法执行，例如权限出错。</li><li>127：容器内命令无法找到</li></ul><p>命令执行出错后，会默认返回错误码。</p><h2 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h2><p>守护进程：守护进程是一个在后台运行并且不受任何终端控制的进程。Unix操作系统有很多典型的守护进程(其数目根据需要或20—50不等)，它们在后台运行，执行不同的管理任务。 —-百度</p><p>更多的时候，需要让Docker容器在后台以守护态（Daemonized）形式运行。此时，可以通过添加<code>-d</code>参数来实现。</p><p>例如下面的命令会在后台容器运行：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/922" alt="img"></p><p>此时，要获取容器的输出信息，可以如下使用<code>docker logs</code>命令：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/926" alt="img"></p><h1 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h1><p>可以使用<code>docker stop</code>来终止一个运行中的容器。该命令格式为</p><p><code>$docker stop [-t | --time[=10]][CONTAINER…]</code></p><p>首先向容器发送SIGTERM信号，等待一段超时时间（默认10秒）后，再发送SIGKILL信号来终止容器</p><p>注意：</p><p><code>docker kill</code>命令会直接发送SIGKILL信号来强行终止容器。</p><p>此外，当Docker容器中指定的应用终结时，容器也会自动终止。例如对于上一节中只启动了一个终端的容器，用户通过exit命令或Ctrl+D来退出终端时，所创建的容器立刻终止，处于exited状态。</p><p>可以通过start命令来使终止态的容器重新启动</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/951" alt="img"></p><p>可以使用restart命令先终止容器，再重新启动。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/948" alt="img"></p><h1 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h1><p>在使用<code>-d</code>参数时，容器启动后会进入后台，用户无法看到容器中的信息，也无法进行操作。</p><p>这个时候如果需要进入容器进行操作，有多种方法，包括官方的<code>attach</code>或<code>exec</code>命令，以及第三方的nsenter工具等。</p><h2 id="attach命令"><a href="#attach命令" class="headerlink" title="attach命令"></a>attach命令</h2><p><code>attacn</code>是<code>docker</code>自带的命令，命令格式为：</p><p><code>docker attach [--detach-keys[=[]]][--no-stdin] [--sig-proxy[=true]] CONTAINER</code></p><p>支持三个主要选项：</p><ul><li><code>--detach-keys=[=[]]</code>：指定退出attach模式的快捷键序列，默认为CTRL-P,CTRL-Q;</li><li><code>--no-sdtin=true|false</code>：是否关闭标准输出，默认是保持打开的；</li><li><code>--sig-proxy=true|false</code>：是否代理收到的系统信号给应用进程，默认为true。</li></ul><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/976" alt="img"></p><p>但是有时候使用<code>attach</code>命令并不方便。当多个窗口同时用<code>attach</code>命令连到同一个容器时，多有窗口都会同步显示。当某个窗口因为命令阻塞时，其他窗口也无法执行操作了。</p><h2 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a>exec命令</h2><p>Docker从1.3.0.版本起提供了一个更加方便的<code>exec</code>命令，可以在容器内直接执行任意命令。</p><p><code>docker exec [-d|--detach][--detach-key[=[]]] [-i|--interactive][—privileged] [-t|--tty][-u|--user[=USER]] CONTAINER COMMAND [ARG…]</code></p><p>比较重要的参数：</p><ul><li><code>-i, --interactive=true|false</code>：打开标准输入接受用户输入命令，默认为false；</li><li><code>--privileged=true|false</code>：是否给执行命令以高权限，默认为false；</li><li><code>-t, --tty=true|false</code>：分配伪终端，默认为false。</li><li><code>-u, --user=&quot;&quot;</code>：执行命令的用户或id</li></ul><p>例如进入刚才的容器，并启动一个bash：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1000" alt="img"></p><p>从上面可以看出，只能在一个运行的容器才能使用<code>exec</code>命令；</p><p>先启动容器，在执行<code>exec</code>命令：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1005" alt="img"></p><p>可以看到，一个bash终端打开了，在不影响容器内其他应用的前提下，用户可以很容易与容器进行交互。</p><p>注意：通过指定-it参数来保持标准输入打开，并且分配一个伪终端。通过exec命令对容器执行操作是最为推荐的方式。</p><h2 id="nsenter工具"><a href="#nsenter工具" class="headerlink" title="nsenter工具"></a>nsenter工具</h2><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1014" alt="img"></p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1016" alt="img"></p><h1 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h1><p>可以使用<code>docker rm</code>命令来删除处于终止或退出状态的容器，命令格式为</p><p><code>docker rm [-f|--force][-l|--link] [-v|--volumes] CONTAINER[CONTAINER…]</code></p><p>主要支持的选项包括：</p><ul><li><code>-f, --force=false</code>：是否强制终止并删除一个运行中的容器；</li><li><code>-l, --link=false</code>：删除容器的链接，但保留容器；</li><li><code>-v, --volumes=false</code>：删除容器挂载的数据卷。</li></ul><p>例如，查看处于终止状态的容器，并删除：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1031" alt="img"></p><p>默认情况下，<code>docker rm</code>命令只能删除处于终止或退出状态的容器，并不能删除还处于运行状态的容器。</p><p>如果直接删除一个运行中的容器，可以添加<code>-f</code>参数。Docker会先发送SIGKILL信号给容器，终止其中的应用，之后强行删除，如下所示：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1038" alt="img"></p><h1 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h1><p>某些时候，需要将容器从一个系统迁移到另外一个系统，此时可以使用Docker的导入和导出的功能。这也是Docker自身提供的一个重要的特性。</p><h2 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h2><p>导出容器是指导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态，可以使用</p><p><code>$docker export</code>命令，该命令的格式为：</p><p><code>$docker export [-o|--output[=&quot;&quot;]]</code>CONTAINER。其中，可以通过-o选项来指定导出的tar文件名，也可以通过重定向来实现。</p><p>下面分别使用<code>-o</code>参数和重定向的方式导出容器：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/1050" alt="img"></p><p>时候可以将导出的tar文件输出到其他的机器上，然后再通过导入命令导入到系统中，从而实现容器的迁移。</p><h2 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h2><p>导出的文件又可以使用<code>docker import</code>命令导入变成镜像，该命令格式为：</p><p><code>docker import [-c|--change[=]]][-m|--message[=MESSAGE]] file|URL|-[REPOSITORY[:TAG]]</code></p><p>可以通过<code>-c, --change=[]</code>选项在导入的同时执行对容器进行修改的Dockerfile指令。</p><hr><p>也可以使用<code>docker load</code>命令来导入镜像存储文件到本地镜像库，也可以使用<code>docker import</code>命令来导入一个容器快照到本地镜像库。</p><p>这两者的区别在于容器快照文件将丢失所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也更大。此外，从容器快照导入时可以重新定义标签等元数据。</p><hr><p><code>exported-imported</code>和<code>saved-loaded</code>的区别</p><p>导出后再导入(exported-imported)的镜像会丢失所有的历史，而保存后再加载（saveed-loaded）的镜像没有丢失历史和层(layer)。这意味着使用导出后再导入的方式，你将无法回滚到之前的层(layer)，同时，使用保存后再加载的方式持久化整个镜像，就可以做到层回滚（可以执行docker tag <layer id=""> <image name="">来回滚之前的层）。–百度</image></layer></p><p>小结</p><p>容器是直接提供应用服务的组件，也是docker实现快速启停和高效服务性能的基础。</p><h1 id="命令小结"><a href="#命令小结" class="headerlink" title="命令小结"></a>命令小结</h1><p>create</p><p>start</p><p>restart</p><p>run </p><p>stop</p><p>attach</p><p>exec</p><p>rm</p><p>export</p><p>-————-</p><p>导入和导入镜像一样：</p><p>import–export</p><p>save—-load</p><p>再生产环境中，因为容器自身的轻量级特性，推荐使用容器时在一组容器前引入HA(High Availability，高可靠性）机制。例如使用HAProxy工具来代理容器访问，这样在容器出现故障时，可以快速切换到功能正常的容器。此外，建议通过指定合适的容器重启策略，来自动重启退出的容器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker容器&quot;&gt;&lt;a href=&quot;#docker容器&quot; class=&quot;headerlink&quot; title=&quot;docker容器&quot;&gt;&lt;/a&gt;docker容器&lt;/h1&gt;&lt;p&gt;容器是Docker一个核心概念。简单来说，容器是镜像的一个运行示例。所不同的是，镜像是静态的
      
    
    </summary>
    
      <category term="docker" scheme="https://kylin1994.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://kylin1994.github.io/tags/docker/"/>
    
      <category term="容器" scheme="https://kylin1994.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习笔记（1）- Docker镜像</title>
    <link href="https://kylin1994.github.io/2018/03/29/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89-Docker%E9%95%9C%E5%83%8F/"/>
    <id>https://kylin1994.github.io/2018/03/29/Docker学习笔记（1）-Docker镜像/</id>
    <published>2018-03-29T14:52:04.000Z</published>
    <updated>2019-06-02T00:02:43.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h1><p><code>$docker pull NAME[:TAG]</code></p><p>如果不加TAG则表示下载最新的镜像，一个镜像由“名称”+“标签决定”</p><p>使用不同镜像仓库服务器情况下，可能会出现镜像重名：</p><p>严格的将，镜像的仓库名称中还应该添加仓库地址（即registry，注册服务器）作为前缀，如果使用Docker Hub服务，该前缀可以忽略。</p><p>即：<code>$docker pull ubuntu:14.04</code>相当于<code>$docker pull registry.hub.docker.com/ubuntu:14.04</code></p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/591" alt="img"></p><h2 id="pull子命令："><a href="#pull子命令：" class="headerlink" title="pull子命令："></a>pull子命令：</h2><ul><li><code>-a, --all-tags=true|false</code>：是否获取仓库中的所有镜像，默认为否。</li></ul><p>使用镜像：例如利用该镜像创建一个容器，在其中运行bash应用，执行ping localhost:</p><p><code>$docker run -it unbuntu[:TAG] bash</code></p><p><code>root@f46310567509:/# ping localhost</code></p><hr><p>如果提示command not found，则</p><p><code>$apt-get update</code></p><p><code>$apt-get install iputils-ping</code></p><p>详细见：<a href="http://blog.csdn.net/silentwolfyh/article/details/52336007" target="_blank" rel="noopener">http://blog.csdn.net/silentwolfyh/article/details/52336007</a></p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/593" alt="运行容器，执行ping"></p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/595" alt="安装ping"></p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/597" alt="执行ping"></p><hr><h1 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h1><p><code>docker images [OPTIONS][REPOSITORY[:TAG]]</code></p><p>OPTIONS说明：</p><ul><li><code>-a</code> :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li><li><code>—digests</code> :显示镜像的摘要信息；</li><li><code>-f</code> :显示满足条件的镜像；</li><li><code>—format</code> :指定返回值的模板文件；</li><li><code>--no-trunc</code> :显示完整的镜像信息；</li><li><code>-q</code> :只显示镜像ID。</li></ul><p>使用<code>docker images</code>命令列出镜像</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/599" alt="img"></p><ul><li>镜像的仓库：ubuntu的系列镜像由ubuntu仓库保存</li><li>标签</li><li>镜像ID，镜像的唯一标识</li><li>创建的时间，说明镜像最后跟新时间</li><li>镜像大小</li></ul><hr><h1 id="镜像标签"><a href="#镜像标签" class="headerlink" title="镜像标签"></a>镜像标签</h1><p>使用tag命令添加镜像标签，可以发现多了一个myubuntu:latest标签，其id和ubuntu:latest是一样的，其实他们都指向同一个镜像，只是别名不同，标签相当于起到了链接的作用。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/608" alt="img"></p><hr><h1 id="查看镜像详细信息"><a href="#查看镜像详细信息" class="headerlink" title="查看镜像详细信息"></a>查看镜像详细信息</h1><p>使用<code>docker inspect</code>命令查看详细信息，包括制作者、适应架构、各层的数字摘要等：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/618" alt="img"></p><p>输出一个json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">　　&#123;</span><br><span class="line">　　　　<span class="attr">"Id"</span>:<span class="string">"sha256:8b72bba4485f1004e8378bc6bc42775f8d4fb851c750c6c0329d3770b3a09086"</span>,</span><br><span class="line">　　　　<span class="attr">"RepoTags"</span>:[</span><br><span class="line">　　　　　　<span class="string">"myubuntu:latest"</span>,</span><br><span class="line">　　　　　　<span class="string">"ubuntu:latest"</span></span><br><span class="line">　　　　],</span><br><span class="line">　　　　<span class="attr">"RepoDigests"</span>:[</span><br><span class="line">　　　　　　<span class="string">"ubuntu@sha256:2b9285d3e340ae9d4297f83fed6a9563493945935fc787e98cc32a69f5687641"</span></span><br><span class="line">　　　　],</span><br><span class="line">　　　　<span class="attr">"Parent"</span>:<span class="string">""</span>,</span><br><span class="line">　　　　<span class="attr">"Comment"</span>:<span class="string">""</span>,</span><br><span class="line">　　　　<span class="attr">"Created"</span>:<span class="string">"2017-09-13T03:58:50.383839319Z"</span>,</span><br><span class="line">　　　　<span class="attr">"Container"</span>:<span class="string">"ee87d884293ece0d9fa040a43ffb75097264185f94437a0d1fc2ddfd3c82ca4b"</span>,</span><br><span class="line">　　　　<span class="attr">"ContainerConfig"</span>:&#123;</span><br><span class="line">　　　　　　<span class="attr">"Hostname"</span>:<span class="string">"ee87d884293e"</span>,</span><br><span class="line">　　　　　　<span class="attr">"Domainname"</span>:<span class="string">""</span>,</span><br><span class="line">　　　　　　<span class="attr">"User"</span>:<span class="string">""</span>,</span><br><span class="line">　　　　　　<span class="attr">"AttachStdin"</span>:<span class="literal">false</span>,</span><br><span class="line">　　　　　　<span class="attr">"AttachStdout"</span>:<span class="literal">false</span>,</span><br><span class="line">　　　　　　<span class="attr">"AttachStderr"</span>:<span class="literal">false</span>,</span><br><span class="line">　　　　　　<span class="attr">"Tty"</span>:<span class="literal">false</span>,</span><br><span class="line">　　　　　　<span class="attr">"OpenStdin"</span>:<span class="literal">false</span>,</span><br><span class="line">　　　　　　<span class="attr">"StdinOnce"</span>:<span class="literal">false</span>,</span><br><span class="line">　　　　　　<span class="attr">"Env"</span>:[</span><br><span class="line">　　　　　　　　<span class="string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span></span><br><span class="line">　　　　　　],</span><br><span class="line">　　　　　　<span class="attr">"Cmd"</span>:[</span><br><span class="line">　　　　　　　　<span class="string">"/bin/sh"</span>,</span><br><span class="line">　　　　　　　　<span class="string">"-c"</span>,</span><br><span class="line">　　　　　　　　<span class="string">"#(nop) "</span>,</span><br><span class="line">　　　　　　　　<span class="string">"CMD ["</span>/bin/bash<span class="string">"]"</span></span><br><span class="line">　　　　　　],</span><br><span class="line">　　　　　　<span class="attr">"ArgsEscaped"</span>:<span class="literal">true</span>,</span><br><span class="line">　　　　　　<span class="attr">"Image"</span>:<span class="string">"sha256:5bf9c8f025cb9bdfec431fbf2a39e1d25117a94ce2b10db01db9630addfc5e37"</span>,</span><br><span class="line">　　　　　　<span class="attr">"Volumes"</span>:<span class="literal">null</span>,</span><br><span class="line">　　　　　　<span class="attr">"WorkingDir"</span>:<span class="string">""</span>,</span><br><span class="line">　　　　　　<span class="attr">"Entrypoint"</span>:<span class="literal">null</span>,</span><br><span class="line">　　　　　　<span class="attr">"OnBuild"</span>:<span class="literal">null</span>,</span><br><span class="line">　　　　　　<span class="attr">"Labels"</span>:&#123;</span><br><span class="line"></span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;,</span><br><span class="line">　　　　<span class="attr">"DockerVersion"</span>:<span class="string">"17.06.2-ce"</span>,</span><br><span class="line">　　　　<span class="attr">"Author"</span>:<span class="string">""</span>,</span><br><span class="line">　　　　<span class="attr">"Config"</span>:&#123;</span><br><span class="line">　　　　　　<span class="attr">"Hostname"</span>:<span class="string">""</span>,</span><br><span class="line">　　　　　　<span class="attr">"Domainname"</span>:<span class="string">""</span>,</span><br><span class="line">　　　　　　<span class="attr">"User"</span>:<span class="string">""</span>,</span><br><span class="line">　　　　　　<span class="attr">"AttachStdin"</span>:<span class="literal">false</span>,</span><br><span class="line">　　　　　　<span class="attr">"AttachStdout"</span>:<span class="literal">false</span>,</span><br><span class="line">　　　　　　<span class="attr">"AttachStderr"</span>:<span class="literal">false</span>,</span><br><span class="line">　　　　　　<span class="attr">"Tty"</span>:<span class="literal">false</span>,</span><br><span class="line">　　　　　　<span class="attr">"OpenStdin"</span>:<span class="literal">false</span>,</span><br><span class="line">　　　　　　<span class="attr">"StdinOnce"</span>:<span class="literal">false</span>,</span><br><span class="line">　　　　　　<span class="attr">"Env"</span>:[</span><br><span class="line">　　　　　　　　<span class="string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span></span><br><span class="line">　　　　　　],</span><br><span class="line">　　　　　　<span class="attr">"Cmd"</span>:[</span><br><span class="line">　　　　　　　　<span class="string">"/bin/bash"</span></span><br><span class="line">　　　　　　],</span><br><span class="line">　　　　　　<span class="attr">"ArgsEscaped"</span>:<span class="literal">true</span>,</span><br><span class="line">　　　　　　<span class="attr">"Image"</span>:<span class="string">"sha256:5bf9c8f025cb9bdfec431fbf2a39e1d25117a94ce2b10db01db9630addfc5e37"</span>,</span><br><span class="line">　　　　　　<span class="attr">"Volumes"</span>:<span class="literal">null</span>,</span><br><span class="line">　　　　　　<span class="attr">"WorkingDir"</span>:<span class="string">""</span>,</span><br><span class="line">　　　　　　<span class="attr">"Entrypoint"</span>:<span class="literal">null</span>,</span><br><span class="line">　　　　　　<span class="attr">"OnBuild"</span>:<span class="literal">null</span>,</span><br><span class="line">　　　　　　<span class="attr">"Labels"</span>:<span class="literal">null</span></span><br><span class="line">　　　　&#125;,</span><br><span class="line">　　　　<span class="attr">"Architecture"</span>:<span class="string">"amd64"</span>,</span><br><span class="line">　　　　<span class="attr">"Os"</span>:<span class="string">"linux"</span>,</span><br><span class="line">　　　　<span class="attr">"Size"</span>:<span class="number">120102168</span>,</span><br><span class="line">　　　　<span class="attr">"VirtualSize"</span>:<span class="number">120102168</span>,</span><br><span class="line">　　　　<span class="attr">"GraphDriver"</span>:&#123;</span><br><span class="line">　　　　　　<span class="attr">"Data"</span>:&#123;</span><br><span class="line">　　　　　　　　<span class="attr">"LowerDir"</span>:<span class="string">"/var/lib/docker/overlay2/579119ec0ba94ba9c2b510b75228f366c14fc1a29302f29a7c915946f9038c54/diff:/var/lib/docker/overlay2/2286560d99b26f3e25b0cb65f100915b2bf3848ff483b2b46f036a782fe92e87/diff:/var/lib/docker/overlay2/90c4f96886f317dfc958dededefa77f9a648011b7002e42c458b61022e950ab9/diff:/var/lib/docker/overlay2/fba0d170b11c979215b1fe227f86b3499427f1908f3f70dbddde2f94d433ee77/diff"</span>,</span><br><span class="line">　　　　　　　　<span class="attr">"MergedDir"</span>:<span class="string">"/var/lib/docker/overlay2/95395204f6fdd03d04da60ee7d1c1e7ff4bf7e96eb789eca0cdeedf58125aecb/merged"</span>,</span><br><span class="line">　　　　　　　　<span class="attr">"UpperDir"</span>:<span class="string">"/var/lib/docker/overlay2/95395204f6fdd03d04da60ee7d1c1e7ff4bf7e96eb789eca0cdeedf58125aecb/diff"</span>,</span><br><span class="line">　　　　　　　　<span class="attr">"WorkDir"</span>:<span class="string">"/var/lib/docker/overlay2/95395204f6fdd03d04da60ee7d1c1e7ff4bf7e96eb789eca0cdeedf58125aecb/work"</span></span><br><span class="line">　　　　　　&#125;,</span><br><span class="line">　　　　　　<span class="attr">"Name"</span>:<span class="string">"overlay2"</span></span><br><span class="line">　　　　&#125;,</span><br><span class="line">　　　　<span class="attr">"RootFS"</span>:&#123;</span><br><span class="line">　　　　　　<span class="attr">"Type"</span>:<span class="string">"layers"</span>,</span><br><span class="line">　　　　　　<span class="attr">"Layers"</span>:[</span><br><span class="line">　　　　　　　　<span class="string">"sha256:8aa4fcad5eeb286fe9696898d988dc85503c6392d1a2bd9023911fb0d6d27081"</span>,</span><br><span class="line">　　　　　　　　<span class="string">"sha256:ebf3d6975c708f538b14a5267afd2c4c64e8243d195aa11d878e566a7e64c727"</span>,</span><br><span class="line">　　　　　　　　<span class="string">"sha256:a76db6d8fac422acd5fb6c28166c906c202639e4e833cf88c7d4965b806c5437"</span>,</span><br><span class="line">　　　　　　　　<span class="string">"sha256:cd1d6655b4e44bb95df75bd2ecde4ad6799dd23337a9dedadf6e0b7f0efdc27e"</span>,</span><br><span class="line">　　　　　　　　<span class="string">"sha256:3996d0debc49f9a96c25d4ab7a5c9e824229c09976551b80ab0da70fa993a10d"</span></span><br><span class="line">　　　　　　]</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以使用<code>-f</code>参数来指定获取某一项参数：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/623" alt="img"></p><p>参考<a href="http://www.cnblogs.com/boshen-hzb/p/6376674.html" target="_blank" rel="noopener">http://www.cnblogs.com/boshen-hzb/p/6376674.html</a></p><hr><h1 id="镜像历史"><a href="#镜像历史" class="headerlink" title="镜像历史"></a>镜像历史</h1><p>使用<code>history</code>命令查看镜像历史。</p><p>镜像文件由多个层组成，可以用history命令，显示各层的创建信息。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/629" alt="img"></p><hr><h1 id="搜寻镜像"><a href="#搜寻镜像" class="headerlink" title="搜寻镜像"></a>搜寻镜像</h1><p>使用<code>docker search</code>命令可以搜索远端仓库中共享的镜像，默认搜索官方仓库总的镜像。用法为docker search TERM，支持的主要参数包括：</p><ul><li><code>--automated=true|false</code>:仅显示自动创建的镜像，默认为否</li><li><code>--no-trunc=true|false</code>:输出信息不截断显示，默认为否</li><li><code>-s, --stars=X</code>：指定仅显示评价为指定星级以上的镜像，默认为0，即输出所有镜像。</li></ul><p>例如，搜索所有自动创建的3星级以上的带 nginx关键字的镜像:</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/644" alt="img"></p><hr><h1 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h1><p>使用<code>docker rmi</code>命令可以删除镜像，命令格式为<code>docker rmi IMAGE [IMAGE]</code>，其中IMAGE可以为标签或ID。</p><p>例如，要删除掉myubuntu:latest镜像，可以使用如下命令</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/653" alt="img"></p><p>可以看出，如果一个镜像有多个标签，只会删除多个标签中指定的标签而已，镜像不会受影响。</p><p>如果某个镜像只有一个标签时，则要注意，删除标签就会删除镜像。</p><p>现在只有一个标签，然后尝试删除镜像：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/664" alt="img"></p><p>删除失败，因为有容器还在镜像上面运行</p><p>可以使用<code>docker ps -a</code>命令查看本机上的所有容器：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/672" alt="img"></p><p>可以看出有容器在镜像上运行，所以不能直接删除，当然可以使用命令</p><p><code>$docker rmi -f ubuntu:latest</code>来强制删除，但是不建议这样做，建议先删除容器，然后删除镜像：</p><p>我们先使用<code>-f</code>参数来删除httpd镜像：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/680" alt="img"></p><p>但是发现镜像依然存在</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/682" alt="img"></p><p>再次使用<code>$docker ps -a</code>命令来查看容器，发现仍然有容器运行</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/688" alt="img"></p><p>所以并不推荐使用<code>-f</code>参数来强制删除，下面是正确的步骤，先删除运行在镜像上面的容器，然后再删除镜像。</p><p>现在先使用<code>$docker rm CONTAINER_ID</code>删除容器，有一个错误，</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/691" alt="img"></p><p>可以看出id为a420…的容器还在运行，所以不能删除，使用<code>$docker ps -a</code>查看删除情况，</p><p>状态为未运行的容器已经删除，然而运行状态的并没有删除</p><p>所以现在需要先使用<code>$docker stop CONTAINER_ID</code>停止运行的容器</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/695" alt="img"></p><p>可以看出id为a420…的容器状态已经改变，现在可以删除了</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/697" alt="img"></p><p>可以看出，容器已经被删除了，现在就可以去删除httpd镜像了：</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/706" alt="img"></p><p>使用<code>$docker rmi IMAGE_ID</code>删除镜像，然后使用$docker images查看删除情况，可以看出httpd镜像已经全部删除完了。</p><p>一次性删除所有容器</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/712" alt="img"></p><hr><h1 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h1><p>创建镜像的方法主要有三种：</p><ol><li>基于已有镜像的容器创建</li><li>基于本地模板导入</li><li>基于Dockerfile创建</li></ol><p>这里主要介绍前两种方法，第三种方法后续学习笔记介绍。</p><h2 id="基于已有镜像的容器创建"><a href="#基于已有镜像的容器创建" class="headerlink" title="基于已有镜像的容器创建"></a>基于已有镜像的容器创建</h2><p>主要使用<code>docker commit</code>命令。命令格式为</p><p> <code>docker commit [OPTIONS]   CONTAINER   [REPOSITORY [:TAG]]</code></p><p>​                           所基于的容器        创建的镜像的标签</p><p>主要的选项包括：</p><ul><li><code>-a, author=&quot;&quot;</code>：作者信息</li><li><code>-c, --change=[]</code>：提交的时候执行Dockerfile命令，包括<code>CMD|ENTRYPOINT|ENV|EXPOSE|LABEL|USER|VOLUME|WORKDIR</code>等</li><li><code>-m, --message=&quot;&quot;</code>：提交消息</li><li><code>-p, --pause=true</code>：提交时暂停容器运行</li></ul><p>下面演示怎么根据已有镜像的容器创建一个新的镜像。</p><p>首先启动一个镜像，然后进行进行一些操作，例如创建一个test文件，然后退出：</p><p><code>$docker run -it ubuntu:latest /bin/bash</code></p><p><code>root@3548583db1bb:/# touch test</code></p><p><code>root@3548583db1bb:/# exit</code></p><p>记住容器的ID为3548583db1bb。</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/744" alt="img"></p><p>然后使用<code>docker images</code>命令查看刚才创建的镜像，也可以使用<code>docker ps -a</code>来查看容器。</p><p>接下来使用·docker commit·命令根据容器3548583db1bb来创建一个新的镜像。</p><ul><li>提交信为：Added a new file</li><li>作者信息为：Docker Newbee</li><li>源容器：3548583db1bb</li><li>被创建的容器的标签：test:0.1</li></ul><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/748" alt="img"></p><p>使用docker image命令查看刚才创建的test:0.1镜像</p><h2 id="基于本地模板导入"><a href="#基于本地模板导入" class="headerlink" title="基于本地模板导入"></a>基于本地模板导入</h2><p>用户可以直接从一个操作系统模板文件导入一个镜像文件，主要使用docker import命令。命令格式为</p><p><code>docker import [OPTIONS] file |URL| -[REPOSITORY[:TAG]]</code></p><p>OPTIONS说明：</p><ul><li>-c：应用docker指令创建镜像文件</li><li>-m：提交信息</li></ul><p>要直接导入一个镜像，可以使用OpenVZ提供的模板来创建，或者用其他已导出的镜像模板来创建。OPENVZ模板的下载地址为<a href="http://openvz.org/Dowload/templates/precreated" target="_blank" rel="noopener">http://openvz.org/Dowload/templates/precreated</a></p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/808" alt="img"></p><hr><h1 id="存出和载入镜像"><a href="#存出和载入镜像" class="headerlink" title="存出和载入镜像"></a>存出和载入镜像</h1><p>用户可以使用docker save和docker load命令来存出和载入镜像。docker load一般只用于导入由docker save导出的镜像，导入后的镜像跟原镜像一模一样，拥有相同的镜像id和分层内容。docker import不能用于导入标准的Docker镜像，而是用于导入包含根文件系统的归档，并将之变成Docker镜像。</p><h2 id="存出镜像"><a href="#存出镜像" class="headerlink" title="存出镜像"></a>存出镜像</h2><p><code>docker save</code>：将指定镜像保存成tar归档文件。</p><p>语法：<code>docker save [OPTIONS] IMAGE [IMAGE…]</code></p><p>OPTIONS说明：</p><ul><li><code>-o</code>：输出到文件</li></ul><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/785" alt="img"></p><p>得到了my_ubuntu.tar归档</p><h2 id="载入镜像"><a href="#载入镜像" class="headerlink" title="载入镜像"></a>载入镜像</h2><p>可以使用<code>docker load</code>将导出的tar文件再导入到本地文件镜像库，例如从文件my_ubuntu.tar</p><p>docker load：从一个在stdin上的tar归档文件中装载镜像</p><p>OPTIONS说明：</p><ul><li><code>-i, --input=&quot;&quot;</code>  从一个tar归档文件中读入，而不是从stdin中</li></ul><p><code>$docker load --input my_ubuntu.tar</code></p><p>或</p><p><code>$docker load &lt; my_ubuntu.tar</code></p><hr><h1 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h1><p>可以使用<code>docker push</code>命令上传镜像到仓库，默认上传到Docker Hub官方仓库（需要登录）。</p><p>命令格式为：</p><p><code>docker push NAME[:TAG] | REGISTRY_HOST[:REGISTRY_PORT] /]NAME [:TAG]</code></p><p>先给需要push的镜像打上标签，因为的我用户名叫kylinxiang，所以改为kylinxiang/push_test:1.0</p><p>默认是Push到Docker Hub，所以可以看到最后push到的仓库为docker.io/kylinxiang</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/818" alt="img"></p><p>之后就可以在Docker Hub上面就可以查看Push的镜像</p><p><img src="https://blogpicgo.oss-cn-beijing.aliyuncs.com/829" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;获取镜像&quot;&gt;&lt;a href=&quot;#获取镜像&quot; class=&quot;headerlink&quot; title=&quot;获取镜像&quot;&gt;&lt;/a&gt;获取镜像&lt;/h1&gt;&lt;p&gt;&lt;code&gt;$docker pull NAME[:TAG]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果不加TAG则表示下载最新的镜像，
      
    
    </summary>
    
      <category term="docker" scheme="https://kylin1994.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://kylin1994.github.io/tags/docker/"/>
    
      <category term="容器" scheme="https://kylin1994.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>聊聊JPA Criteria查询中的坑</title>
    <link href="https://kylin1994.github.io/2018/03/16/%E8%81%8A%E8%81%8AJPA-Criteria%E6%9F%A5%E8%AF%A2%E4%B8%AD%E7%9A%84%E5%9D%91/"/>
    <id>https://kylin1994.github.io/2018/03/16/聊聊JPA-Criteria查询中的坑/</id>
    <published>2018-03-16T15:24:46.000Z</published>
    <updated>2019-06-02T00:03:26.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="聊聊JPA-Criteria查询中的坑"><a href="#聊聊JPA-Criteria查询中的坑" class="headerlink" title="聊聊JPA Criteria查询中的坑"></a>聊聊JPA Criteria查询中的坑</h1><p>JPA Criteria查询被称作动态安全类型查询，比JPQL这种方式更加健壮。关于JPA Criteria查询在IBM社区有一篇很好的文章，这里我就不去Copy（尊重默默为社区奉献的同行兄弟），请移步<a href="https://www.ibm.com/developerworks/cn/java/j-typesafejpa/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-typesafejpa/</a></p><h1 id="Bug复现"><a href="#Bug复现" class="headerlink" title="Bug复现"></a>Bug复现</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>创建一个<code>Student</code>类，然后创建其StaticMetaModel <code>Student_</code>类；然后使用Critirial查询年龄大于20的<code>Student</code>。场景很简单，但是。。。结果很意外，让我们来看看相关配置和代码。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.kylin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jpa-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>jpa-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8</span><br><span class="line">        <span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="yml配置文件"><a href="#yml配置文件" class="headerlink" title="yml配置文件"></a>yml配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8800</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://localhost:3306/jpaadvance</span></span><br><span class="line"><span class="attr">  jpa:</span></span><br><span class="line"><span class="attr">    database-platform:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">    hibernate:</span></span><br><span class="line"><span class="attr">      ddl-auto:</span> <span class="string">update</span></span><br><span class="line"><span class="attr">    show-sql:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    properties:</span></span><br><span class="line"><span class="attr">      hibernate:</span></span><br><span class="line"><span class="attr">        dialect:</span> <span class="string">org.hibernate.dialect.MySQL5Dialect</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="Student类代码"><a href="#Student类代码" class="headerlink" title="Student类代码"></a>Student类代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kylin.jpademo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.annotations.GenericGenerator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7681363673194194734L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(generator = <span class="string">"system-uuid"</span>)</span><br><span class="line">    <span class="meta">@GenericGenerator</span>(name = <span class="string">"system-uuid"</span>, strategy = <span class="string">"uuid"</span>)</span><br><span class="line">    <span class="meta">@Column</span>(updatable = <span class="keyword">false</span>, nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//geter and seter</span></span><br></pre></td></tr></table></figure><h3 id="Student-类代码"><a href="#Student-类代码" class="headerlink" title="Student_类代码"></a>Student_类代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kylin.jpademo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.kylin.jpademo.domain.metamodel.Student;<span class="comment">//重点看这里</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.metamodel.SingularAttribute;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.metamodel.StaticMetamodel;</span><br><span class="line"></span><br><span class="line"><span class="meta">@StaticMetamodel</span>(Student.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student_</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingularAttribute&lt;Student, String&gt; id;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingularAttribute&lt;Student, String&gt; name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingularAttribute&lt;Student, Integer&gt; age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Repository接口"><a href="#Repository接口" class="headerlink" title="Repository接口"></a>Repository接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kylin.jpademo.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.kylin.jpademo.domain.metamodel.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentRepository</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">findStudentByAgeLessThan</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Repository实现"><a href="#Repository实现" class="headerlink" title="Repository实现"></a>Repository实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kylin.jpademo.repository.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.kylin.jpademo.domain.metamodel.Student;</span><br><span class="line"><span class="keyword">import</span> com.kylin.jpademo.domain.Student_;</span><br><span class="line"><span class="keyword">import</span> com.kylin.jpademo.repository.StudentRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.TypedQuery;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.criteria.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">StudentRepository</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    EntityManager em;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">findStudentByAgeLessThan</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">        CriteriaBuilder cb = em.getCriteriaBuilder();</span><br><span class="line">        CriteriaQuery&lt;Student&gt; cq = cb.createQuery(Student.class);</span><br><span class="line"></span><br><span class="line">        Root&lt;Student&gt; s = cq.from(Student.class); <span class="comment">// from ...</span></span><br><span class="line">        Path&lt;Integer&gt; path = s.get(Student_.age);</span><br><span class="line">        Predicate condition = cb.gt(path, age);  <span class="comment">// condition: attribute &gt; age</span></span><br><span class="line">        cq.where(condition); <span class="comment">// where</span></span><br><span class="line"></span><br><span class="line">        TypedQuery&lt;Student&gt; tq = em.createQuery(cq);</span><br><span class="line">        <span class="keyword">return</span> tq.getResultList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行findStudentByAgeLessThan方法"><a href="#执行findStudentByAgeLessThan方法" class="headerlink" title="执行findStudentByAgeLessThan方法"></a>执行<code>findStudentByAgeLessThan</code>方法</h2><p><img src="https://upload-images.jianshu.io/upload_images/6287954-e24bd4c606f79d70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bug复现"><br>如上图所示，报了一个NullPointerException，定位到了<code>StudentRepositoryImpl</code>类的这一行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Path&lt;Integer&gt; path = s.get(Student_.age);</span><br></pre></td></tr></table></figure></p><h1 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h1><p>Debug重新运行之后，发现Student_.age变量为空，说明StaticMetaModel<code>Student_</code>类并没有映射到<code>Student</code>类。之后我google了很多方法去解决这个问题，都没有用。但是可以确定的是一定是StaticMetaModel出了问题，因为将上面出错那一行的代码改为<code>&quot;age&quot;</code>之后，即：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Path&lt;Integer&gt; path = s.get(“age”);</span><br></pre></td></tr></table></figure></p><p>Bug解决了，但这似乎违背了Criteria查询的宗旨，就是类型安全和避免运行时错误，这里的安全类型除了指明确查询中的类型安全之外，还有就是避免使用常量。如果”age”字符串手抖写成了“aeg”，在编译时肯定是没有问题的，只有在运行时才会暴露出来，到了那个时候为时已晚。所以为了尽可能的遵循Criteria的初衷，这种方式肯定不是很好的方案，之后笔者又尝试了很多种方案，都宣告失败。<strong>于是我删掉了<code>Student_</code>类重新写了一次，但是这次<code>Student</code>和<code>Student_</code>位于同一包中，</strong>神奇的事情发生了，这次运行正确，并且成功查找出了年龄大于20的Student。</p><h2 id="此时的工程结构"><a href="#此时的工程结构" class="headerlink" title="此时的工程结构"></a>此时的工程结构</h2><p><img src="https://upload-images.jianshu.io/upload_images/6287954-53777684e509802f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改后的工程结构"></p><p>结果如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"8a4ffa05622dcf1501622dd0aaa30003"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"bob"</span>,</span><br><span class="line">        <span class="attr">"age"</span>: <span class="number">90</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"8a4ffa05622dcf1501622dd0ca410004"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"an"</span>,</span><br><span class="line">        <span class="attr">"age"</span>: <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>Student</code>和<code>Student_</code>必须位于同一包中。</p><h1 id="更好的解决办法"><a href="#更好的解决办法" class="headerlink" title="更好的解决办法"></a>更好的解决办法</h1><p>解决之后，本人始终百思不得其解，google了很多文章也没有解决。在之后的各种尝试中，发现了自动生成StaticMetaModel<code>Student_</code>的方法，就是引入下面的依赖。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-jpamodelgen<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>此依赖可以自动创建metamodel。<br>现在我们删除我们自行创建的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```Java</span><br><span class="line">Path&lt;Integer&gt; path = s.get(Student_.age);</span><br></pre></td></tr></table></figure></p><p>此时程序会出现编译错误：<br><img src="https://upload-images.jianshu.io/upload_images/6287954-59b166c17934ee21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译出错"><br>因为刚才删除了<code>Student_</code>类，肯定会出现编译问题。<br>抛开编译问题，这里我们继续执行，如下图所示，执行成功了。<br><img src="https://upload-images.jianshu.io/upload_images/6287954-70c85e72ab27835b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行成功"><br>那么为什么呢？总结刚才的操作，你可能会猜测是不是刚才引入的依赖自动创建了<code>Student_</code>呢？答案是肯定的。为了证实这一点，我们去看编译运行的结果：<br><img src="https://upload-images.jianshu.io/upload_images/6287954-59dccfe24f64e2ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>自动生成的Student_代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kylin.jpademo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.metamodel.SingularAttribute;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.metamodel.StaticMetamodel;</span><br><span class="line"></span><br><span class="line"><span class="meta">@StaticMetamodel</span>(Student.class)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Student_</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingularAttribute&lt;Student, String&gt; name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingularAttribute&lt;Student, String&gt; id;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingularAttribute&lt;Student, Integer&gt; age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行查询，没有问题。<br>可以看出自动生成的<code>Student_</code>和<code>Student</code>在同一包下，这也印证了刚才的做法。</p><h1 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h1><p>在Criteria查询中，Model和StaticMetaModel必须位于同一包下。因为在大型项目中，会涉及到很多Model，若不想自己创建对应的StaticMetaModel，可以使用<code>hibernate-jpamodelgen</code>依赖，自动创建。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;聊聊JPA-Criteria查询中的坑&quot;&gt;&lt;a href=&quot;#聊聊JPA-Criteria查询中的坑&quot; class=&quot;headerlink&quot; title=&quot;聊聊JPA Criteria查询中的坑&quot;&gt;&lt;/a&gt;聊聊JPA Criteria查询中的坑&lt;/h1&gt;&lt;p&gt;JP
      
    
    </summary>
    
      <category term="JPA" scheme="https://kylin1994.github.io/categories/JPA/"/>
    
    
      <category term="JPA" scheme="https://kylin1994.github.io/tags/JPA/"/>
    
      <category term="Java" scheme="https://kylin1994.github.io/tags/Java/"/>
    
      <category term="Criteria" scheme="https://kylin1994.github.io/tags/Criteria/"/>
    
  </entry>
  
  <entry>
    <title>栈ADT及其应用</title>
    <link href="https://kylin1994.github.io/2018/03/14/%E6%A0%88ADT%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>https://kylin1994.github.io/2018/03/14/栈ADT及其应用/</id>
    <published>2018-03-14T09:12:53.000Z</published>
    <updated>2019-06-02T00:03:23.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈模型"><a href="#栈模型" class="headerlink" title="栈模型"></a>栈模型</h1><p>栈（Stack）是限制插入和删除只能在一个位子上进行的表，该位子是表的末端，叫做栈的顶（top）。对栈的基本操作有进栈（push）和出栈（pop），相当于表插入和删除最后一个元素。</p><h1 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h1><p>由于栈可以看作是一个表，因此任何实现表的方法都能实现栈。显然，在Java集合中，ArrayList和LinkedList都支持栈的操作，由于栈的操作都是栈顶元素，所以对于数组实现的ArrayList和链表实现的LinkedList来说都花费常数时间，因此他们并没有太大区别。但是对于代码实现来说，数组实现更加简洁，更易于理解，下面将给出栈的简单实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的默认大小为10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_VALUE_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//用一个数组来存储栈的元素</span></span><br><span class="line"><span class="keyword">private</span> E[] elementData;</span><br><span class="line"><span class="comment">//栈中元素的实际个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器，调用doClear方法初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">doClear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line"><span class="comment">//存放栈元素的数组满了，则需要对elementData扩容</span></span><br><span class="line"><span class="keyword">if</span> (elementData.length == size) &#123;</span><br><span class="line"><span class="comment">//扩容操作</span></span><br><span class="line">ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">elementData[size++] = element;</span><br><span class="line"><span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈操作，若栈为空时出栈，则抛出数组越界异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> elementData[--size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空栈的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">doClear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空栈的操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doClear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">ensureCapacity(DEFAULT_VALUE_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保证在进栈的，存储栈元素的elementData数组有足够的空间</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size &gt; minCapacity) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E[] old = elementData;</span><br><span class="line">elementData = (E[]) <span class="keyword">new</span> Object[minCapacity];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">elementData[i] = old[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回栈的实际元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码实现了栈的基本操作，push/pop/clear。</p><h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><h2 id="应用1-——-平衡符号"><a href="#应用1-——-平衡符号" class="headerlink" title="应用1 —— 平衡符号"></a>应用1 —— 平衡符号</h2><p>编译器检查程序的语法错误，但是常常由于缺少一个符号（如遗漏一个花括号）引起编译不能通过。在这种情况下，一个有用的工具就是检测是成对出现的东西。于是，一个右花括号、右方括号及右括号必然对其相应的左括号。比如[()]序列是合法的，[(])是不合法的。</p><p>通过栈，可以实现上述程序，思路如下：<br>声明一个空栈，然后挨个读取字符，如果字符是一个开放符号（左边的符号），则将其推入栈内。如果字符是一个封闭符号（右边的符号），然后弹出栈顶元素，栈为空时报错。如果弹出的开放符号不是当前封闭符号所对应的符号，则报错。依次遍历，直到遍历完所有开放符号。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申明一个栈，用来存放开放符号</span></span><br><span class="line">Stack&lt;Character&gt; lefts = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line"><span class="comment">// 申明一个数组，用来存放封闭符号</span></span><br><span class="line">ArrayList&lt;Character&gt; rights = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</span><br><span class="line"><span class="comment">// 用来存放从控制台读取的字符数组</span></span><br><span class="line"><span class="keyword">char</span>[] characters;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从控制台读取字符串，并转换成字符串</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readCharsFromConsole</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">if</span> (scanner.hasNext()) &#123;</span><br><span class="line"><span class="comment">// 给characters数组</span></span><br><span class="line">characters = scanner.next().toCharArray();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查开放符号和封闭符号是否匹配</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readCharsFromConsole();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开放符号进栈lefts，封闭符号添加到数组rights</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; characters.length; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> ch = characters[i];</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'('</span>) &#123;</span><br><span class="line">lefts.push(ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">')'</span>) &#123;</span><br><span class="line">rights.add(ch);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果开放符号的个数不等于封闭符号的个数则报错</span></span><br><span class="line"><span class="keyword">if</span> (lefts.size() != rights.size()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历封闭符号，如果栈lefts弹出的元素不是当前封闭元素所对应的，则返回false</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rights.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rights.get(i).charValue() == <span class="string">')'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (lefts.pop().charValue() != <span class="string">'('</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后返回true</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">StackApplication stackApplication = <span class="keyword">new</span> StackApplication();</span><br><span class="line">System.out.println(stackApplication.check());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>在控制台输入((()))，回车，结果如下图所示，返回true。</p><p><img src="http://upload-images.jianshu.io/upload_images/6287954-8a80439ddd376991.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果"><br>在控制台输入((())，回车，结果如下图所示，返回false。</p><p><img src="http://upload-images.jianshu.io/upload_images/6287954-de5506c5e8bbefe2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果"></p><h2 id="应用二-——-计算后缀表达式（逆波兰表达式"><a href="#应用二-——-计算后缀表达式（逆波兰表达式" class="headerlink" title="应用二 —— 计算后缀表达式（逆波兰表达式)"></a>应用二 —— 计算后缀表达式（逆波兰表达式)</h2><p>假设我们需要一个计算器来计算我们购物的花费，你的计算公式可能是这样的：<code>2 * 2 + 3 * 3</code>，如果你手上的计算器的普通计算器的话，答案为21。但是现在大多数时候我们希望使用科学计算器，它可以判定运算的优先级，科学计算器的结果为13。</p><p>我们简单地分析一下科学计算器计算上面例子的过程，首先判断优先级，乘法有限，所以依次计算2*2和#3*3并将其结果分别存储到两个临时变量A1和A2中，最后计算加法，将A1和A2求和。我们可以将这种操作写为：<code>2 2 * 3 3 * +</code>。这就是逆波兰表达式。</p><p>如何将<code>2 * 2 + 3 * 3</code>转化为<code>2 2 * 3 3 * +</code>，参见应用三。</p><p><strong>计算细节如下：</strong></p><p>首先假设有一个空栈stack，遍历后缀表达式，将数字压入栈中，直到遇到一个操作符，这个操作符的操作数为连续两次出栈的结果。</p><ul><li>第一步：stack=[2,2]，读到一个操作符为*，于是操作数连续两次出栈的结果2和2。所以计算结果为2*2=4，将结果压入栈中，stack=[4]。</li><li>第二步：继续读入数字，直到一个操作符。stack=[4,3,3]，操作符为*，操作数为连续两次出栈的结果3和3。所以计算结果为3*3=9，将结果压入栈中，stack=[4,9]。</li><li>第三部：继续读入，下一个元素为+操作数，所以执行加法操作，操作数为连续两次出栈的结果4和9，所以计算结果为4+9=13。压栈，stack=13。到此遍历完了整个后缀表达式，最后结果就为栈顶元素13。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackApplication2</span> </span>&#123;</span><br><span class="line"><span class="comment">// 字符数组，用来保存后缀表达式的每一个字符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] postfix;</span><br><span class="line"><span class="comment">// 操作数栈</span></span><br><span class="line">Stack&lt;Integer&gt; numberStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器，传入一个后缀表达式字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StackApplication2</span><span class="params">(String postfix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.postfix = postfix.toCharArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StackApplication2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断后缀表达式中字符是否为数字</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 科学计算器的实现方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scientificCaculator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 两个操作数</span></span><br><span class="line"><span class="keyword">int</span> num1;</span><br><span class="line"><span class="keyword">int</span> num2;</span><br><span class="line"><span class="comment">// 遍历后缀表达式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; postfix.length; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> temp = postfix[i];</span><br><span class="line"><span class="comment">// 如果是数字就压栈</span></span><br><span class="line"><span class="keyword">if</span> (isNumeric(temp)) &#123;</span><br><span class="line">numberStack.push(temp - <span class="string">'0'</span>);<span class="comment">// char转int</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果是操作符就从栈中弹出操作数并执行相关运算</span></span><br><span class="line">num1 = numberStack.pop();</span><br><span class="line">num2 = numberStack.pop();</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="string">'+'</span>) &#123;</span><br><span class="line">numberStack.push(num1 + num2);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">'-'</span>) &#123;</span><br><span class="line">numberStack.push(num1 - num2);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">'*'</span>) &#123;</span><br><span class="line">numberStack.push(num1 * num2);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">'/'</span>) &#123;</span><br><span class="line">numberStack.push(num1 / num2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回最后的栈顶元素，即结果</span></span><br><span class="line"><span class="keyword">return</span> numberStack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">StackApplication2 stackApplication2 = new StackApplication2(&quot;6523+8*+3+*&quot;);</span><br><span class="line">System.out.println(stackApplication2.scientificCaculator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://upload-images.jianshu.io/upload_images/6287954-196e0fb8c5218eac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试结果"><br>计算一个后缀表示花费的时间是O(N)，该算法是一个十分简单的算法。注意，当一个表达式以后缀表示给出时，我们就不用知道<strong>运算的优先级</strong>，这是一个明显的优点。</p><h2 id="应用三-中缀表达式转后缀表达式"><a href="#应用三-中缀表达式转后缀表达式" class="headerlink" title="应用三- 中缀表达式转后缀表达式"></a>应用三- 中缀表达式转后缀表达式</h2><p>栈不仅仅可以用来计算后缀表达式的值，还可以用来用来讲一个标准形式的表达式（中缀表达式）转换成后缀表达式。 我们假设只有运算+,*,(,)，并且表达式合法以及使用普通的优先级法则，即括号&gt;乘&gt;加。<br>假设中缀表示<code>1+2*3+(4*5+6)*7</code>,则转换后的后缀表达式为：<code>123*+45*6+7*+</code>。</p><h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>我们需要两个数据结构，一个用来存放操作符的栈operatorStack，一个用来存放后缀表达式的字符数组postfix。<strong>遍历中缀表达式，如果读到的是一个操作数，则立即添加到postfix数组中</strong>，如果是一个操作符则相对麻烦。为了说明方便，我们将operatorStack栈中的栈顶操作符称为top，当前遍历的操作符为temp。<br>操作符的处理规则如下：</p><ul><li>如果栈为空，则直接将temp压入operatorStack栈中。</li><li>如果栈不为空并且temp= * 或 + 或 (，然后将temp的优先级和top比较，如果temp的优先级大于top优先级，则将temp压栈；否则，依次将栈中优先级大于或等于temp的操作符弹出，添加到postfix，直到top优先级高于temp，然后将temp压栈，但是有一个情况例外，即top=（,temp的优先级低于(时，这种情况，top不会出栈，而是将temp直接压栈。</li><li>如果读到的），则依次弹出操作符，加入postfix的末尾，直到（。</li></ul><p>现在我们对刚才提到的例子<code>1+2*3+(4*5+6)*7</code>采用上面的算法依次计算：</p><ol><li>读取到操作数1，直接添加到postfix数组中。此时，operatorStack为空，postfix=[1]。</li><li>读取到操作符+，因为此时栈为空，所以直接压栈。此时，operatorStack={+}，postfix=[1]。</li><li>读取到操作数2，直接添加到postfix数组中。此时，operatorStack={+}，postfix=[1,2]。</li><li>读取到操作符*，此时temp = *，top = +，优先级temp &gt; top，所以temp压栈。此时，operatorStack={+,*}，postfix=[1,2]。</li><li>读取到操作数3，直接添加到postfix数组中。此时，operatorStack={+,*}，postfix=[1,2,3]。</li><li>读取到操作符+，此时temp = +,top = *，优先级top&gt;=temp，所以top出栈并添加到postfix数组。此时operatorStack={+}，postfix=[1,2,3,*]，top=+，top&gt;=temp，所以top出栈并添加到postfix数组。此时operatorStack={}，postfix=[1,2,3,*,+}。此时operatorStack为空，所以temp压栈。所以此时operatorStack={+}，postfix=[1,2,3,*,+}。</li><li>读取操作符（，此时temp = (，top = +，优先级temp &gt; top，所以temp直接压栈。此时，operatorStack={+,(}，postfix=[1,2,3,*,+]。</li><li>读取操作数4，直接添加到postfix数组中。此时operatorStack={+,(}，postfix=[1,2,3*,+，4]。</li><li>读取操作符*，此时temp = *，top = (，虽然优先级top &gt;= temp，但是对于（特殊处理，不出栈。所以temp直接压栈。此时operatorStack={+,(,*}，postfix=[1,2,3,*,+,4]。</li><li>读取操作数5，直接添加到postfix数组中。此时operatorStack={+,(,*}，postfix=[1,2,3,*,+,4,5]。</li><li>读取操作符+，此时temp = +，top = *，优先级top &gt;= temp，所以top出栈并且添加到postfix数组，此时operatorStack={+,(}，postfix=[1,2,3,*,+,4,5,*],top = （，优先级temp &lt; top，temp直接压栈。此时operatorStack={+,(,+}，postfix=[1,2,3,*,+,4,5,*]。</li><li>读取操作数6，直接添加到postfix数组中。此时operatorStack={+,(,+}，postfix=[1,2,3,*,+,4,5,*,6]。</li><li>读取操作符），依次弹出栈顶操作符，直到（。此时operatorStack={+}，postfix=[1,2,3,*,+,4,5,*,6,+]。</li><li>读取操作符*，此时temp = *，top = +，优先级temp &gt; top，所以temp压栈。此时operatorStack={+,*}，postfix=[1,2,3,*,+,4,5,*,6,+]。</li><li>读取操作数7，直接添加到postfix数组中。此时operatorStack={+,*}，postfix=[1,2,3,*,+,4,5,*,6,+,7]。</li><li>依次弹出栈中剩余操作符，最终operatorStack={}，postfix=[1,2,3,*,+,4,5,*,6,+,7,*,+]。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfixToPostfix</span> </span>&#123;</span><br><span class="line"><span class="comment">// 存放操作符的栈</span></span><br><span class="line"><span class="keyword">private</span> Stack&lt;Character&gt; operatorStack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line"><span class="comment">// 存放后缀表达式的字符数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] postfix;</span><br><span class="line"><span class="comment">// 存放中缀表达式的字符数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] infix;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义操作符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> multiply = <span class="string">'*'</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> divide = <span class="string">'/'</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> add = <span class="string">'+'</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> substract = <span class="string">'-'</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> leftParenthesis = <span class="string">'('</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> rightParenthesis = <span class="string">')'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InfixToPostfix</span><span class="params">(String infix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.infix = infix.toCharArray();</span><br><span class="line">postfix = <span class="keyword">new</span> <span class="keyword">char</span>[infix.length()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InfixToPostfix</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个字符是否为数字</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">infixToPostfix</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 插入后缀的表达式下标</span></span><br><span class="line"><span class="keyword">int</span> insertIndex = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 操作符栈的大小</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 返回结果，后缀表达式字符串</span></span><br><span class="line">String result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; infix.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (isNumeric(infix[i])) &#123;</span><br><span class="line">postfix[insertIndex++] = infix[i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> temp = infix[i];</span><br><span class="line">size = operatorStack.size();</span><br><span class="line"><span class="comment">// 如果栈为空，就直接压栈</span></span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">operatorStack.push(temp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 栈不为空时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出栈顶元素</span></span><br><span class="line"><span class="keyword">char</span> top = operatorStack.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp == rightParenthesis) &#123;</span><br><span class="line"><span class="keyword">while</span> (top != leftParenthesis) &#123;</span><br><span class="line">postfix[insertIndex++] = top;</span><br><span class="line">top = operatorStack.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前操作符的优先级大于栈顶操作符的优先级，则当前操作符进栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (operatorPriorityCompare(temp, top)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 因为上一行为了比较当前操作符和栈顶元素的操作符, </span></span><br><span class="line"><span class="comment"> * 上面弹出了栈顶元素,</span></span><br><span class="line"><span class="comment"> * 所以这里要先将弹出的操作符压栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">operatorStack.push(top);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果当前操作符的优先级低于或等于栈顶操作符的优先级， 则栈顶操作符出栈，然后一直比较，</span></span><br><span class="line"><span class="comment"> * 直到栈顶操作符优先级大于当前操作符或栈为空，然后当前操作符进栈。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!operatorPriorityCompare(temp, top)) &#123;</span><br><span class="line"><span class="keyword">if</span> (top == leftParenthesis) &#123;</span><br><span class="line">operatorStack.push(top);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">postfix[insertIndex++] = top;</span><br><span class="line">size = operatorStack.size();</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">top = operatorStack.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前操作符进栈</span></span><br><span class="line">operatorStack.push(temp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历完毕，一次弹出栈中剩余操作符</span></span><br><span class="line">size = operatorStack.size();</span><br><span class="line"><span class="keyword">if</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">postfix[insertIndex++] = operatorStack.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = String.valueOf(postfix).trim();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断操作符的优先级：括号&gt;乘除&gt;加减</span></span><br><span class="line"><span class="comment">// true: temp&gt;top false: top &gt;= temp</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">operatorPriorityCompare</span><span class="params">(<span class="keyword">char</span> current, <span class="keyword">char</span> top)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (((current == multiply || current == divide) &amp;&amp; (top == substract || top == add))</span><br><span class="line">|| (current == leftParenthesis</span><br><span class="line">&amp;&amp; (top == multiply || top == divide || top == substract || top == add))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">InfixToPostfix infixToPostfix = <span class="keyword">new</span> InfixToPostfix(<span class="string">"1+2*3+(4*5+6)*7"</span>);</span><br><span class="line">String result = infixToPostfix.infixToPostfix();</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="http://upload-images.jianshu.io/upload_images/6287954-aad61c605c1fda9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试结果"><br>与上面相同，这种转换需要O(N)时间。可以通过制定减法和加法有相同优先级以及乘法和除法有相同优先级二将减法和乘法添加到指令中去。需要注意的是，表达式a-b-c应该转化为ab-c-，而不是abc–。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;栈模型&quot;&gt;&lt;a href=&quot;#栈模型&quot; class=&quot;headerlink&quot; title=&quot;栈模型&quot;&gt;&lt;/a&gt;栈模型&lt;/h1&gt;&lt;p&gt;栈（Stack）是限制插入和删除只能在一个位子上进行的表，该位子是表的末端，叫做栈的顶（top）。对栈的基本操作有进栈（push）和
      
    
    </summary>
    
      <category term="数据结构" scheme="https://kylin1994.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://kylin1994.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈" scheme="https://kylin1994.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>二叉树(binary tree)</title>
    <link href="https://kylin1994.github.io/2018/03/14/%E4%BA%8C%E5%8F%89%E6%A0%91-binary-tree/"/>
    <id>https://kylin1994.github.io/2018/03/14/二叉树-binary-tree/</id>
    <published>2018-03-14T08:34:57.000Z</published>
    <updated>2019-06-02T00:03:14.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h1><p><strong>二叉树</strong>是n(n&gt;=0)个具有相同类型的元素的有限集合，当n=0时称为空二叉树，当n&gt;0时，数据元素被分为一个称为根（Root）的数据元素及两棵分别为左子树和右子树的数据元素的集合，左、右子树互不相交，且左、右子树都为二叉树。在二叉树中，一个元素也称为一个节点。</p><p>二叉树的子树是有序的，即若将其左、右子树颠倒，就将成为另一棵不同的二叉树。即使树中的节点只有一棵子树，也要明确指出其是左子树还是右子树。由于左、右子树的有序以及二叉树可以为空，因此，二叉树具有以下五种基本形态，即空二叉树、仅有根节点的二叉树、右子树为空的二叉树、左子树为空的二叉树、左右子树均为非空的二叉树，如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/6287954-83b9163f6887978c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二叉树的五种基本情形"></p><h1 id="二叉树的基本概念"><a href="#二叉树的基本概念" class="headerlink" title="二叉树的基本概念"></a>二叉树的基本概念</h1><ol><li>节点的度：节点所拥有子树的个数称为该节点的度。</li><li>叶子：度为0的节点称为叶子。</li><li>孩子：节点子树的根，称为该节点的孩子。二叉树中，孩子有左右之分，分别为左孩子和右孩子。</li><li>双亲：孩子节点的上层节点都称为该节点的双亲。</li><li>以某节点的根的子树中的除根节点之外的任意一个节点都称为该节点的子孙。</li><li>祖先：节点的祖先是从根到该节点所经分支上的所有节点。</li><li>节点的层次：从根节点起，跟为第一层，他的孩子为第二层，孩子的孩子为第三层，依次类推，即某个节点的层次为L层，那么他的孩子节点的层数为L+1层。</li><li>兄弟：同一双亲的孩子互为兄弟。</li><li>堂兄弟：其双亲在同一层的节点互为堂兄弟。</li><li>二叉树的度：二叉树中最大的节点度称为二叉树的度。</li><li>二叉树的深度：二叉树中节点的最大层次书被称为二叉树的深度。</li><li>满二叉树：在一棵二叉树中，所有分支节点都存在左子树和右子树，并且所有叶子节点都在同一层上，这样的二叉树被称为满二叉树。</li><li>完全二叉树：对深度为k的满二叉树中的节点从上至下、从左至右从1开始编号。对一棵具有n个节点、深度为k的二叉树，采用的同样的办法对树中的节点从上至下，从左至右从1开始连续编号，如果编号为i（i&lt;=n）的节点与满二叉树中编号为i的节点在同一位置，则称此二叉树为完全二叉树。对于一棵完全二叉树，其叶子节点只可能出现在最下层和倒数第二层，而最下层的叶子集中在树的最左部。</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/6287954-205b8867482704fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="满二叉树和完全二叉树"></p><h1 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h1><ol><li>一棵非空二叉树的第i层最多有2^(i-1)个节点。</li><li>深度为k的二叉树至多有2^k-1个节点。</li><li>对任何一棵二叉树T，如果叶子节点数为n0，度为2的节点数为n2，那么n0=n2+1。</li><li>具有n个节点的安全二叉树的深度k=log2N+1（这里解释一下，k=以2为底N的对数向下取整+1）。</li><li>对一棵具有n个节点的完全二叉树的从上至下，从左至右从1开始连续编号，那么对任意一个节点i有：<br>如果i=1,则节点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是i/2向下取整。<br>如果2i&gt;n，则节点无左孩子，为叶子节点；如果2i&lt;n，则其左孩子是2i。<br>如果2i+1&gt;n，则节点i无右孩子；如果2i+1&lt;=n，则其右孩子为2i+1。</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/6287954-aacfe74b67a2e587.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="性质5"></p><h1 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h1><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><p><strong>完全二叉树的顺序存储</strong><br>我们先看以下完全二叉树的顺序存储。要存储一棵完全二叉树，不仅需要二叉树的节点数据，还需要存储它的结构信息，即双亲和孩子关系信息。从上面的性质5可以看出，完全二叉树中节点i的左孩子为2i，右孩子为2i+1，双亲为i/2向下取整。因此，如果将完全二叉树从上至下，从左至右从1开始编号，把编号为i的节点放在线性存储单元的第i个位子，那么其左孩子存储在2i位子，右孩子存储在2i+1位子，则孩子和双亲的关系就体现出来了。<br><img src="http://upload-images.jianshu.io/upload_images/6287954-1dc8ace4107e3032.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="完全二叉树的顺序存储"><br><strong>一般二叉树的顺序存储</strong><br>对于一般二叉树而言，如果把它的节点按照从上至下、从左至右从1开始连续编号存储在一维的存储单元，那么无法反应其节点间的双亲孩子关系，即不能反映二叉树的结构关系，怎么办呢?可以把一般的二叉树补成一棵完全二叉树，这样，它就可以按照完全二叉树的顺序存储方式存储了，只是新补上去的节点只占位子，不存放节点数据。如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/6287954-b9e1bed6e4ad22a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一般二叉树的顺序存储"><br>对于一般二叉树，需要增加一些节点才能存储此二叉树的节点数据和结构关系，这样可能会造成存储空间的浪费，例如，对于深度为3的右偏斜二叉树，需要额外增加4个存储单位。当二叉树的深度更深时，则需要更多的节点，例如当深度为100的右偏斜二叉树，需要2^100-101个额外空间，为了采用顺序存储方式来存储此二叉树，把全世界所有计算机的存储空间加起来也不够！因此很有必要采用其他形式的存储方式。</p><p><img src="http://upload-images.jianshu.io/upload_images/6287954-0cf6c3e91d6a3ceb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="右偏斜二叉树的顺序存储"></p><h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><p>链表可以用来表示一维的线性结构，也可以用来表示非线性的二叉树结构。二叉树的链式存储结构常有二叉链表存储、三叉链表存储及线索链表。二叉链表中有两个指针域，分别指向其左、右孩子；三叉链表中除了指向其左、右孩子的指针域外，还有指向其双亲的指针域；线索链表是为了反映节点的前驱、后继而将二叉链表中空指针指向其前驱或后继而形成的链式存储结构。</p><p><img src="http://upload-images.jianshu.io/upload_images/6287954-4be462cd66c3a072.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二叉链表和三叉链表的结构"></p><p><strong>二叉链表存储</strong><br>链表中每一个节点包含3个域：数据域、左孩子指针域、右孩子指针域。左、右孩子指针域分别指向左孩子和右孩子的存储地址。</p><p><img src="http://upload-images.jianshu.io/upload_images/6287954-add8dfcea157ca59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二叉链表存储"></p><h2 id="二叉链表存储代码实现"><a href="#二叉链表存储代码实现" class="headerlink" title="二叉链表存储代码实现"></a>二叉链表存储代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> T data;</span><br><span class="line"><span class="keyword">private</span> BinaryTreeNode&lt;T&gt; leftChild;</span><br><span class="line"><span class="keyword">private</span> BinaryTreeNode&lt;T&gt; rightChild;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(data, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">(T data, BinaryTreeNode&lt;T&gt; leftChild, BinaryTreeNode&lt;T&gt; rightChild)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.leftChild = leftChild;</span><br><span class="line"><span class="keyword">this</span>.rightChild = rightChild;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode&lt;T&gt; <span class="title">getLeftChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> leftChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftChild</span><span class="params">(BinaryTreeNode&lt;T&gt; leftChild)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.leftChild = leftChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode&lt;T&gt; <span class="title">getRightChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rightChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightChild</span><span class="params">(BinaryTreeNode&lt;T&gt; rightChild)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.rightChild = rightChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>三叉链表存储</strong><br>在三叉链表中，除根节点的parent域为空外，其余节点的parent域都不为空，指向其双亲。因此在三叉链表中，查找孩子和双亲都是很快捷的，但是增加了一些额外空间开销。</p><p><img src="http://upload-images.jianshu.io/upload_images/6287954-695e3a55fc515656.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三叉链表存储结构"></p><h2 id="三叉链表存储实现"><a href="#三叉链表存储实现" class="headerlink" title="三叉链表存储实现"></a>三叉链表存储实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode3</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> T data;</span><br><span class="line"><span class="keyword">private</span> BinaryTreeNode3&lt;T&gt; leftChild;</span><br><span class="line"><span class="keyword">private</span> BinaryTreeNode3&lt;T&gt; parent;</span><br><span class="line"><span class="keyword">private</span> BinaryTreeNode3&lt;T&gt; rightChild;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶子节点构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode3</span><span class="params">(T data, BinaryTreeNode3&lt;T&gt; parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(data, <span class="keyword">null</span>, parent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般节点构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode3</span><span class="params">(T data, BinaryTreeNode3&lt;T&gt; leftChild, BinaryTreeNode3&lt;T&gt; parent,</span></span></span><br><span class="line"><span class="function"><span class="params">BinaryTreeNode3&lt;T&gt; rightChild)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.leftChild = leftChild;</span><br><span class="line"><span class="keyword">this</span>.parent = parent;</span><br><span class="line"><span class="keyword">this</span>.rightChild = rightChild;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode3&lt;T&gt; <span class="title">getLeftChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> leftChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftChild</span><span class="params">(BinaryTreeNode3&lt;T&gt; leftChild)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.leftChild = leftChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode3&lt;T&gt; <span class="title">getParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(BinaryTreeNode3&lt;T&gt; parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode3&lt;T&gt; <span class="title">getRightChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rightChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightChild</span><span class="params">(BinaryTreeNode3&lt;T&gt; rightChild)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.rightChild = rightChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h2 id="先序、中序、后续的递归遍历"><a href="#先序、中序、后续的递归遍历" class="headerlink" title="先序、中序、后续的递归遍历"></a>先序、中序、后续的递归遍历</h2><p>例子</p><p><img src="http://upload-images.jianshu.io/upload_images/6287954-0318fee1d0f8e2f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="遍历的二叉树"><br>代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitData</span><span class="params">(BinaryTreeNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">System.out.print(node.getData() + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">visitData(node);</span><br><span class="line">preOrder(node.getLeftChild());</span><br><span class="line">preOrder(node.getRightChild());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">inOrder(node.getLeftChild());</span><br><span class="line">visitData(node);</span><br><span class="line">inOrder(node.getRightChild());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">postOrder(node.getLeftChild());</span><br><span class="line">postOrder(node.getRightChild());</span><br><span class="line">visitData(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">BinaryTreeNode&lt;String&gt; g = <span class="keyword">new</span> BinaryTreeNode&lt;String&gt;(<span class="string">"g"</span>);</span><br><span class="line">BinaryTreeNode&lt;String&gt; c = <span class="keyword">new</span> BinaryTreeNode&lt;String&gt;(<span class="string">"c"</span>);</span><br><span class="line">BinaryTreeNode&lt;String&gt; d = <span class="keyword">new</span> BinaryTreeNode&lt;String&gt;(<span class="string">"d"</span>);</span><br><span class="line">BinaryTreeNode&lt;String&gt; b = <span class="keyword">new</span> BinaryTreeNode&lt;String&gt;(<span class="string">"b"</span>, c, d);</span><br><span class="line">BinaryTreeNode&lt;String&gt; f = <span class="keyword">new</span> BinaryTreeNode&lt;String&gt;(<span class="string">"f"</span>, g, <span class="keyword">null</span>);</span><br><span class="line">BinaryTreeNode&lt;String&gt; e = <span class="keyword">new</span> BinaryTreeNode&lt;String&gt;(<span class="string">"e"</span>, <span class="keyword">null</span>, f);</span><br><span class="line">BinaryTreeNode&lt;String&gt; a = <span class="keyword">new</span> BinaryTreeNode&lt;String&gt;(<span class="string">"a"</span>, b, e);</span><br><span class="line"></span><br><span class="line">BinaryTree&lt;String&gt; binaryTree = <span class="keyword">new</span> BinaryTree&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"preOder:"</span>);</span><br><span class="line">binaryTree.preOrder(a);</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"inOder:"</span>);</span><br><span class="line">binaryTree.inOrder(a);</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"postOder:"</span>);</span><br><span class="line">binaryTree.postOrder(a);</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果</p><p><img src="http://upload-images.jianshu.io/upload_images/6287954-b8ee2c5265e3a1fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="递归遍历的结果"></p><h3 id="非递归遍历的思想"><a href="#非递归遍历的思想" class="headerlink" title="非递归遍历的思想"></a>非递归遍历的思想</h3><p>当非递归遍历时，我们需要从根节点开始，从左到右深入到每一个叶子。当深入到一个叶子节点时，需要返回到其父节点，然后去深入其他分支。可以看出深入和返回是一对相反的操作，所以可以用到数据结构 <strong>栈</strong>来保存深入节点时树的结构关系。至于该遍历是先序、中序或是后序，这只取决于其访问 </p><h3 id="非递归的中序遍历"><a href="#非递归的中序遍历" class="headerlink" title="非递归的中序遍历"></a>非递归的中序遍历</h3><p>沿左子树深入时，深入一个节点入栈一个节点，沿左分支无法继续深入时（某个节点无左孩子），出栈，出站时同时访问节点数据，然后从该节点的右子树继续沿左子树深入，这样一直下去，最后从根节点的右子树返回时结束。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归的中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nrInOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; root)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 声明一个栈</span></span><br><span class="line">Stack&lt;BinaryTreeNode&lt;T&gt;&gt; stack = <span class="keyword">new</span> Stack&lt;BinaryTreeNode&lt;T&gt;&gt;();</span><br><span class="line"><span class="comment">// 当前节点</span></span><br><span class="line">BinaryTreeNode&lt;T&gt; p = root;</span><br><span class="line"><span class="comment">// 当节点和栈不同时为空时</span></span><br><span class="line"><span class="keyword">while</span> (!(p == <span class="keyword">null</span> &amp;&amp; stack.isEmpty())) &#123;</span><br><span class="line"><span class="comment">// 遍历p节点下的所有左孩子</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 将左孩子压栈</span></span><br><span class="line">stack.push(p);</span><br><span class="line">p = p.getLeftChild();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p = stack.pop();<span class="comment">// 出栈</span></span><br><span class="line">visitData(p);<span class="comment">// 出栈时访问数据</span></span><br><span class="line">p = p.getRightChild();<span class="comment">// 指向右孩子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="非递归的层次遍历"><a href="#非递归的层次遍历" class="headerlink" title="非递归的层次遍历"></a>非递归的层次遍历</h3><p>从根节点开始，根节点入队，访问其数据，然后根节点的左右孩子入队，根节点出队。此时相当于第一层遍历完毕。第二层数据已经入队。然后当前队首元素出队，访问数据，加入当前元素的左右孩子，依次类推直到队列为空。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BinaryTreeNode&lt;T&gt; root)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 声明一个队列</span></span><br><span class="line">Queue&lt;BinaryTreeNode&lt;T&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;BinaryTreeNode&lt;T&gt;&gt;();</span><br><span class="line"><span class="comment">// 如果二叉树为空，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根节点入队</span></span><br><span class="line">queue.add(root);</span><br><span class="line"><span class="comment">// 临时变量，用来保存上一次出队的元素</span></span><br><span class="line">BinaryTreeNode&lt;T&gt; temp;</span><br><span class="line"><span class="comment">// 遍历队列，直到队列为空</span></span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">temp = queue.remove();</span><br><span class="line"><span class="comment">// 访问刚才出队元素的数据</span></span><br><span class="line">visitData(temp);</span><br><span class="line"><span class="comment">// 若刚才出队的元素（节点）有左孩子，则左孩子入队</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != temp.getLeftChild()) &#123;</span><br><span class="line">queue.add(temp.getLeftChild());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若刚才出队的元素（节点）有左孩子，则左孩子入队</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != temp.getRightChild()) &#123;</span><br><span class="line">queue.add(temp.getRightChild());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二叉树的定义&quot;&gt;&lt;a href=&quot;#二叉树的定义&quot; class=&quot;headerlink&quot; title=&quot;二叉树的定义&quot;&gt;&lt;/a&gt;二叉树的定义&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;二叉树&lt;/strong&gt;是n(n&amp;gt;=0)个具有相同类型的元素的有限集合，当n=0时称为
      
    
    </summary>
    
      <category term="数据结构" scheme="https://kylin1994.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="https://kylin1994.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="数据结构" scheme="https://kylin1994.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
