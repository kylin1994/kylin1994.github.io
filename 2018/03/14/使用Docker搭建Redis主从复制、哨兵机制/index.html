<!DOCTYPE html>
<html lang="zh-Hans">


<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>
    使用Docker搭建Redis主从复制、哨兵机制 | Kylin Xiang&#39;s Blog
  </title>
  <meta name="description" content="IT/Java/Microservice">
  
  <meta name="keywords" content="
  Docker,Redis
  ">
  
  <meta name="author" content="Kylin Xiang">

  <meta http-equiv="Cache-Control" content="no-transform"/>
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="theme-color" content="#1e2327">
  <link rel="apple-touch-icon" href="https://github.githubassets.com/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://github.githubassets.com/apple-touch-icon-180x180.png">

  <link rel="icon" type="image/x-icon" href="https://github.githubassets.com/favicon.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet"
        href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  

  

  <script src="//cdnjs.cloudflare.com/ajax/libs/vue/1.0.25-csp/vue.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.11.2/moment.min.js"></script>
</head>

<body id="replica-app">

<nav class="navbar-wrapper">
  <div class="navbar">
    <div class="container clearfix">
      <a href="/" class="navbar-logo"><i class="fa fa-github"></i></a>

      <div class="navbar-search float-left desktop-only">
        <div class="navbar-search-form">
          <label for="gsc-i-id1">This website</label>
          <div id="google-search">
            <gcse:search></gcse:search>
          </div>
        </div>
      </div>

      <ul class="navbar-nav float-left">
        
        <li><a href="/archives">Archives</a></li>
        
        
        <li><a href="/categories">Categories</a></li>
        
        
        <li><a href="/tags">Tags</a></li>
        
        
        <li class="desktop-only"><a href="/atom.xml" target="_blank">RSS</a></li>
        
      </ul>

      <ul class="navbar-nav user-nav float-right desktop-only">
        <li class="user-nav-notification">
          <a><span class="user-nav-unread"></span><i class="fa fa-bell"></i></a>
        </li>
        <li>
          <a><i class="fa fa-plus"></i> <i class="fa fa-caret-down"></i></a>
        </li>
        <li class="user-nav-logo">
          <a><img src="https://octodex.github.com/images/baracktocat.jpg"> <i class="fa fa-caret-down"></i></i></a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="main-container">
  <header class="header-wrapper desktop-only">
  <div class="container header-site-detail">
    <ul class="header-toolbar">
      <li class="clearfix">
        <a href="/archives" class="header-toolbar-left"><i
                  class="fa fa-file-text"></i> Posts </a>
        <a href="/archives"
           class="header-toolbar-right"> 16 </a>
      </li>
      <li>
        <a href="/tags" class="header-toolbar-left"><i
                  class="fa fa-tags"></i> Tags </a>
        <a href="/tags"
           class="header-toolbar-right"> 20 </a>
      </li>
      <li>
        <a href="/categories" class="header-toolbar-left"><i
                  class="fa fa-folder-open"></i> Categories </a>
        <a href="/categories"
           class="header-toolbar-right"> 5 </a>
      </li>
    </ul>
    <h2 class="header-title">
      <i class="fa fa-book text-muted"></i>
      <a href="/">Kylin Xiang&#39;s Blog</a>
      
      
    </h2>
  </div>

  <div class="container">
    <div class="header-tab-wrapper clearfix">
      <span class="header-tab header-tab-selected"><i class="fa fa-thumbs-o-up"></i> Like</span>
      <span class="header-tab"><i class="fa fa-share-alt"></i> Share</span>
      <span class="header-tab"><i class="fa fa-comments-o"></i> Discussion</span>
      <span class="header-tab"><i class="fa fa-bookmark-o"></i> Bookmark </span>
      <span class="header-tab"><i class="fa fa-smile-o"></i> Smile <i class="fa fa-caret-down"></i></span>
    </div>
  </div>
</header>


<div class="post-container container">
  <h3>
    <i class="fa fa-user-o"></i>
    Kylin Xiang

    <span class="post-date float-right" title="{{moment(1521005867000).format('MMM DD, YYYY, h:mm:ss A')}}">
      <i class="fa fa-pencil-square-o"></i>
      {{moment(1521005867000).fromNow()}}
    </span>
  </h3>

  <article class="post-content">
    <h1>使用Docker搭建Redis主从复制、哨兵机制</h1>
    <h1 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h1><p>本文搭建如下图所示的redis拓扑结构，拓扑中共有3个哨兵，1和mater结点和2个slave结点。<br><img src="http://upload-images.jianshu.io/upload_images/6287954-78c11a101a34e462.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="redis拓扑结构"><br>拓扑信息：</p>
<table>
<thead>
<tr>
<th style="text-align:center">角色</th>
<th style="text-align:center">ip</th>
<th style="text-align:center">port</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">redis-master</td>
<td style="text-align:center">redis-master或者master或者master-sentinel或者master-sentinel2或者master-sentinel3或自动分配的ip</td>
<td style="text-align:center">6379</td>
</tr>
<tr>
<td style="text-align:center">redis-slave1</td>
<td style="text-align:center">容器启动时自动分配的ip</td>
<td style="text-align:center">6380</td>
</tr>
<tr>
<td style="text-align:center">redis-slave2</td>
<td style="text-align:center">容器启动时自动分配的ip</td>
<td style="text-align:center">6381</td>
</tr>
<tr>
<td style="text-align:center">redis-master-sentinel</td>
<td style="text-align:center">容器启动时自动分配的ip</td>
<td style="text-align:center">26379</td>
</tr>
<tr>
<td style="text-align:center">redis-master-sentinel2</td>
<td style="text-align:center">容器启动时自动分配的ip</td>
<td style="text-align:center">26380</td>
</tr>
<tr>
<td style="text-align:center">redis-master-sentinel3</td>
<td style="text-align:center">容器启动时自动分配的ip</td>
<td style="text-align:center">26381</td>
</tr>
</tbody>
</table>
<p>注：master或者master-sentinel或者master-sentinel2或者master-sentinel3都是主节点容器的别名。与之相关联的容器可以通过别称来代替ip访问容器。</p>
<h1 id="搭建主从复制结构"><a href="#搭建主从复制结构" class="headerlink" title="搭建主从复制结构"></a>搭建主从复制结构</h1><h2 id="master节点配置"><a href="#master节点配置" class="headerlink" title="master节点配置"></a>master节点配置</h2><h3 id="master节点配置文件"><a href="#master节点配置文件" class="headerlink" title="master节点配置文件"></a>master节点配置文件</h3><p><img src="http://upload-images.jianshu.io/upload_images/6287954-43a97ebc46f85167.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="master节点配置文件"></p>
<h3 id="master节点配置文件详解"><a href="#master节点配置文件详解" class="headerlink" title="master节点配置文件详解"></a>master节点配置文件详解</h3><ul>
<li><code>port</code>：端口号</li>
<li><code>daemonize</code>：redis采用的是单进程多线程的模式。当redis.conf中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。</li>
<li><code>logfile</code>：日志文件的名字，在工作目录下自动创建，会记录redis的运行日志。</li>
<li><code>dbfilename</code>：dump文件的名字，在工作目录下自动创建。</li>
<li><code>dir</code>：工作目录的路径。</li>
</ul>
<p>其他配置请参考redis中文官网：<a href="http://www.redis.cn" target="_blank" rel="noopener">www.redis.cn</a></p>
<h3 id="在docker中运行redis-master节点服务"><a href="#在docker中运行redis-master节点服务" class="headerlink" title="在docker中运行redis master节点服务"></a>在docker中运行redis master节点服务</h3><p><img src="http://upload-images.jianshu.io/upload_images/6287954-eeaded7d794d34f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="master节点docker命令"><br>命令说明：</p>
<ul>
<li><code>--name</code>: 命名容器为<code>redis-master</code>，一定不要忽略容器命名，为后面<code>--link</code>命令命名更容易记住名字。</li>
<li><code>-v</code>:将本地的配置文件<code>~/redis/redis-6379.conf</code>挂载到容器中的<code>/redis/redis-6379.conf</code></li>
</ul>
<p>容器启动后，进入容器挂载的目录，执行<code>redis-server redis-6379.conf</code>命令，使用<code>redis-6379.conf</code>配置启动redis服务。具体操作如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/6287954-f743e5d1eb791441.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="启动master节点"><br>执行上述命令之后，如果没有消息，那么就是最好的消息，说明redis-server已经成功启动了。可以通过<code>redis-6379.conf</code>中配置的日志文件来查看启动情况。具体操作如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/6287954-dfca1fe657e1a3dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看日志文件"><br>日志说明：</p>
<ul>
<li>第一行：redis正在启动</li>
<li>第二行：redis版本信息，64位，进程号等</li>
<li>第三行：加载配置</li>
<li>第四行：redis的运行模式为standalone，端口为6379</li>
<li>第五行：警告，这句话的翻译大概就是：对一个高负载的环境来说tcp设置128这个值，太小了。具体解决方案参考：<a href="https://www.cnblogs.com/faunjoe88/p/7158484.html" target="_blank" rel="noopener">https://www.cnblogs.com/faunjoe88/p/7158484.html</a></li>
<li>第六行：说明redis server已经成功初始化</li>
<li>第七行： 警告，THP的系统配置问题，具体参考：<a href="https://jingyan.baidu.com/article/da1091fb196ea7027849d6b0.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/da1091fb196ea7027849d6b0.html</a><br>上述警告对于demo来说可以忽略，但是对于生产环境，需要重新对系统进行相关配置之后，再重新启动容器。</li>
</ul>
<p>至此，master节点已经成功启动了。</p>
<h2 id="slave节点配置"><a href="#slave节点配置" class="headerlink" title="slave节点配置"></a>slave节点配置</h2><h3 id="slave节点配置文件"><a href="#slave节点配置文件" class="headerlink" title="slave节点配置文件"></a>slave节点配置文件</h3><p>两个slave节点的配置一模一样，除了端口号之外。slave1的端口为6380，slave2的端口号为6381。<br><img src="http://upload-images.jianshu.io/upload_images/6287954-4f18124158729a3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="slave1节点的配置文件"></p>
<h3 id="slave节点配置文件详解"><a href="#slave节点配置文件详解" class="headerlink" title="slave节点配置文件详解"></a>slave节点配置文件详解</h3><ul>
<li>前5项配置和master节点类似，请参考master节点配置说明。</li>
<li><p>这里重点说一下 <code>slaveof</code>命令，此命令用来给当前redis server节点指定一个master节点，自身作为master节点的slave节点。<code>slaveof</code>命令的格式为<code>slaveof &lt;ip&gt; &lt;port&gt;</code>，很明显，当前节点通过ip和port来定位将哪一个节点作为master节点，但是对于配置<code>slaveof redis-master 6379</code>来说，<code>redis-master</code>参数并不是一个ip。这里是因为在docker环境下，容器启动是ip是不定的，所以容器的通信可以通过<code>--link</code>选项来实现，而这里的<code>redis-master</code>就是master节点容器的名字，用容器名可以代替ip。具体参看下文。</p>
<h3 id="在docker中运行redis-slave节点服务"><a href="#在docker中运行redis-slave节点服务" class="headerlink" title="在docker中运行redis slave节点服务"></a>在docker中运行redis slave节点服务</h3><p><img src="http://upload-images.jianshu.io/upload_images/6287954-b3373fdc1a52e797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="启动slave节点容器"><br>命令说明：</p>
</li>
<li><p><code>--name</code>: 容器名为<code>redis-slave1</code></p>
</li>
<li><code>-v</code>: 将本地<code>~/redis/redis-6380.conf</code>挂载到容器目录<code>/redis/redis-6380.conf</code></li>
<li><code>--link</code>: 建立与master节点之间的容器间的通信，<code>redis-master</code>为master节点的容器名，<code>master</code>为<code>redis-master</code>的别名。因此，slave的配置文件redis-6380.conf中最后一项配置也可以配置为<code>slaveof master 6379</code>。</li>
</ul>
<p>容器启动后使用<code>redis-server redis-6380.conf</code>命令启动redis server服务。如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/6287954-c1d5f49157d9bbaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="启动redis server服务"><br><code>redis-server redis-6380.conf</code>命令执行后，如果没有任何消息，那么就是最好的消息，说明redis server已经成功启动。<br>下面可以通过查看日志文件来查看启动情况。如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/6287954-558fe52b3b7cd534.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看17slave2的日志"><br>日志分析：</p>
<ul>
<li>从第二行可以看出redis-server已经启动成功了。</li>
<li>Connecting to MASTER redis-master:6379说明已经连接到master节点，并且开始了数据的同步，从master节点复制到slave节点。</li>
<li>从最后6行可以看出，因为是新增的slave结点，所以master到slave的复制时全量复制（倒数第五行），部分复制不可用（倒数第六行）。复制一共经历了四个步骤（最后四行）：1. 从master接收数据 2.清理掉旧的数据 3.在内存中接在db 4.复制成功。</li>
</ul>
<h2 id="配置redis哨兵"><a href="#配置redis哨兵" class="headerlink" title="配置redis哨兵"></a>配置redis哨兵</h2><h3 id="redis哨兵配置文件"><a href="#redis哨兵配置文件" class="headerlink" title="redis哨兵配置文件"></a>redis哨兵配置文件</h3><p><img src="http://upload-images.jianshu.io/upload_images/6287954-dd34222eacccaa0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="redis-sentinel1配置文件"><br>配置说明：</p>
<ul>
<li><code>port daemonize logfile dir</code>配置和普通redis server节点相同。</li>
<li><p><code>sentinel monitor</code>：该命令的格式为<code>sentinel monitor &lt;master&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</code>。<br><code>&lt;master&gt;</code>：参数为哨兵监控的master节点的别名<br><code>&lt;ip&gt;</code>：参数为监控的master节点的ip（在docker中，容器间用<code>--link</code>命令通信，所以可以替换为目标容器的名字或别名）<br><code>&lt;port&gt;</code>：为监控的master结点的端口<br><code>&lt;quorum&gt;</code>：代表要判定master节点最终不可达所需要的票数。用于故障发现和判定。例如如果将quorum配置为2，代表至少要两个哨兵节点认为master节点不可达，那么这个不可达的判定才是客观的，对于<quorum>值设置的越小，那么达到下线的条件就越宽松，反之越严格。一般建议将其设置为哨兵节点的数量加1。</quorum></p>
</li>
<li><p><code>sentinel down-after-milliseconds</code>命令格式为<code>sentinel down-after-milliseconds &lt;master-name&gt; &lt;times&gt;</code><br><code>&lt;master&gt;</code>：参数为主节点的名称，这里为上面设置的mymaster<br><code>&lt;times&gt;</code>：sentinel节点定期会想master节点发送ping命令，如果超过times毫秒没有收到回复，则判定该节点不可达。down-after-milliseconds虽然以<master-name>为参数，但实际上对哨兵节点、主节点、从节点的判定同时有效，可以通过主节点来获取从节点和哨兵节点的信息。</master-name></p>
</li>
<li><p><code>sentinel parallel-syncs</code>格式为<code>sentinel parallel-syncs &lt;master-name&gt; &lt;nums&gt;</code><br>当哨兵节点集合对主节点的故障判定达到一致时，哨兵领导节点会做故障转移操作，选出新的主节点，原来的从节点会向新的主节点发起复制操作，parallel-syncs参数就是限制从节点向新的主节点发起复制的个数。若发起复制的从节点过多，那么可能会造成主节点阻塞。若发起复制的从节点过少，可能会造成数据在复制期间不一致的情况。<br><img src="http://upload-images.jianshu.io/upload_images/6287954-aa3af6a2a1805417.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sentinel parallel-syncs示意图"></p>
</li>
<li><p><code>sentinel failover-timeout</code> 格式为<code>sentinel failover-timeout &lt;master-name&gt; &lt;times&gt;</code><br>表示故障转移的超时时间。<br>其他配置请参加redis中文官网：<a href="http://www.redis.cn" target="_blank" rel="noopener">www.redis.cn</a></p>
</li>
</ul>
<h3 id="在docker容器中启动redis哨兵服务"><a href="#在docker容器中启动redis哨兵服务" class="headerlink" title="在docker容器中启动redis哨兵服务"></a>在docker容器中启动redis哨兵服务</h3><p>使用下图命令在容器中启动redis哨兵服务。<br><img src="http://upload-images.jianshu.io/upload_images/6287954-37398a32eecf09e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="docker启动redis哨兵命令"><br>其他两个哨兵服务只需要修改：<br><code>--name</code>参数（比如 <code>redis-master-sentinel2</code>)<br><code>-v</code>挂载相应的配置文件(比如<code>~/redis/redis-26380.conf:/redis/redis-62380.conf</code>)，–link参数给主节点去不同的别名(比如<code>redis-master:master-sentinel2</code>)。<br>在容器中启动redis-sentinel服务：<br><img src="http://upload-images.jianshu.io/upload_images/6287954-599cd762c04dbd30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在容器中启动redis-sentinel服务"><br>运行上述命令后没有消息，就是最好的消息。<br>下面可以查看工作目录下的日志文件来查看启动情况。如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/6287954-7965effb0c7662f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看哨兵节点的日志"><br>日志说明：</p>
<ul>
<li>从第四行可以看出，节点启动成功，以sentinel模式运行，端口为26379。</li>
<li>倒数第二行为sentinel的id信息</li>
<li>最后一行说明新加了一个哨兵节点监控到master节点，名字为mymaster，ip为172.17.0.2，quorum为2。</li>
</ul>
<p>至此，redis-sentinel节点配置完毕，其余两个sentinel节点请读者根据上面配置自行配置完成（很容易）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文从配置角度描述了怎么使用Docker搭建redis主从复制，并且添加了哨兵机制，但是并没有对redis进行详细剖析，这里强烈建议读者阅读相关书籍或是到redis官网了解redis运行机制。<br>若有问题，欢迎在评论区留言。<br>本文会定期更新，以便使用跟新版本的redis和docker。</p>

  </article>
</div>


    




</div>

<div class="footer-wrapper container">
  <footer class="footer clearfix">
    <div class="clearfix">
    <a href="https://kylin1994.github.io" class="footer-logo">
      <i class="fa fa-github"></i>
    </a>
    <ul class="footer-social-link">
      <li>© 2019 Kylin Xiang</li>
      <li><a href="https://kylin1994.github.io">Home</a></li>
      
    </ul>
    <div class="footer-theme-info">
      Theme <a href="//github.com/sabrinaluo/hexo-theme-replica">Replica</a>
      by <a href="//github.com/sabrinaluo">Hiitea</a> ❤ Powered by Hexo
    </div>
    </div>
    
  </footer>
</div>




<script src="/js/main.js"></script>

</body>
</html>
